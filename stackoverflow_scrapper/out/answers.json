[
    {
        "_id": 1,
        "_Respuesta__fecha": "2021-07-24 20:43:05Z",
        "_Respuesta__descripcion": "\nNote: The ideas here are pretty generic for Stack Overflow, indeed questions.\nDisclaimer: Writing a good question is hard.\nThe Good:\n\ndo include small* example DataFrame, either as runnable code:\n  In [1]: df = pd.DataFrame([[1, 2], [1, 3], [4, 6]], columns=['A', 'B'])\n\nor make it \"copy and pasteable\" using pd.read_clipboard(sep='\\s\\s+'), you can format the text for Stack Overflow highlight and use Ctrl+K (or prepend four spaces to each line), or place three tildes above and below your code with your code unindented:\n  In [2]: df\n  Out[2]:\n     A  B\n  0  1  2\n  1  1  3\n  2  4  6\n\ntest pd.read_clipboard(sep='\\s\\s+') yourself.\n* I really do mean small, the vast majority of example DataFrames could be fewer than 6 rowscitation needed, and I bet I can do it in 5 rows. Can you reproduce the error with df = df.head(), if not fiddle around to see if you can make up a small DataFrame which exhibits the issue you are facing.\n* Every rule has an exception, the obvious one is for performance issues  (in which case definitely use %timeit and possibly %prun), where you should generate (consider using np.random.seed so we have the exact same frame): df = pd.DataFrame(np.random.randn(100000000, 10)). Saying that, \"make this code fast for me\" is not strictly on topic for the site...\n\nwrite out the outcome you desire (similarly to above)\n  In [3]: iwantthis\n  Out[3]:\n     A  B\n  0  1  5\n  1  4  6\n\nExplain what the numbers come from: the 5 is sum of the B column for the rows where A is 1.\n\ndo show the code you've tried:\n  In [4]: df.groupby('A').sum()\n  Out[4]:\n     B\n  A\n  1  5\n  4  6\n\nBut say what's incorrect: the A column is in the index rather than a column.\n\ndo show you've done some research (search the documentation, search Stack\u00a0Overflow), and give a summary:\n\nThe docstring for sum simply states \"Compute sum of group values\"\n\n\nThe groupby documentation doesn't give any examples for this.\n\nAside: the answer here is to use df.groupby('A', as_index=False).sum().\n\nif it's relevant that you have Timestamp columns, e.g. you're resampling or something, then be explicit and apply pd.to_datetime to them for good measure**.\n  df['date'] = pd.to_datetime(df['date']) # this column ought to be date..\n\n** Sometimes this is the issue itself: they were strings.\n\n\nThe Bad:\n\ndon't include a MultiIndex, which we can't copy and paste (see above). This is kind of a grievance with Pandas' default display, but nonetheless annoying:\n  In [11]: df\n  Out[11]:\n       C\n  A B\n  1 2  3\n    2  6\n\nThe correct way is to include an ordinary DataFrame with a set_index call:\n  In [12]: df = pd.DataFrame([[1, 2, 3], [1, 2, 6]], columns=['A', 'B', 'C']).set_index(['A', 'B'])\n\n  In [13]: df\n  Out[13]:\n       C\n  A B\n  1 2  3\n    2  6\n\n\ndo provide insight to what it is when giving the outcome you want:\n     B\n  A\n  1  1\n  5  0\n\nBe specific about how you got the numbers (what are they)... double check they're correct.\n\nIf your code throws an error, do include the entire stack trace (this can be edited out later if it's too noisy). Show the line number (and the corresponding line of your code which it's raising against).\n\n\nThe Ugly:\n\ndon't link to a CSV file we don't have access to (ideally don't link to an external source at all...)\n  df = pd.read_csv('my_secret_file.csv')  # ideally with lots of parsing options\n\nMost data is proprietary we get that: Make up similar data and see if you can reproduce the problem (something small).\n\ndon't explain the situation vaguely in words, like you have a DataFrame which is \"large\", mention some of the column names in passing (be sure not to mention their dtypes). Try and go into lots of detail about something which is completely meaningless without seeing the actual context. Presumably no one is even going to read to the end of this paragraph.\nEssays are bad, it's easier with small examples.\n\ndon't include 10+ (100+??) lines of data munging before getting to your actual question.\nPlease, we see enough of this in our day jobs. We want to help, but not like this....\nCut the intro, and just show the relevant DataFrames (or small versions of them) in the step which is causing you trouble.\n\n\nAnyway, have fun learning Python, NumPy and Pandas!\n    ",
        "_Respuesta__votes": 402,
        "comentarios": [
            {
                "_id": 5,
                "_Comentario__descripcion": "+1 for the pd.read_clipboard(sep='\\s\\s+') tip. When I post SO questions that need a special but easily shared dataframe, like this one I build it in excel, copy it to my clipboard, then instruct SOers to do the same. Saves so much time!",
                "_Comentario__fecha": "2016-04-13 17:32:12Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "zelusp",
                "usuario_id": null
            },
            {
                "_id": 6,
                "_Comentario__descripcion": "the pd.read_clipboard(sep='\\s\\s+') suggestion does not seem to work if you're using Python on a remote server, which is where a lot of large data sets live.",
                "_Comentario__fecha": "2016-12-09 17:50:15Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "user5359531",
                "usuario_id": null
            },
            {
                "_id": 7,
                "_Comentario__descripcion": "Why pd.read_clipboard(sep='\\s\\s+'), and not a simpler pd.read_clipboard() (with the default \u2018s+\u2019)? The first need at least 2 whitespace characters, which may cause problems if there is only 1 (e. g. see such in the @JohnE 's answer).",
                "_Comentario__fecha": "2018-12-26 22:32:33Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "MarianD",
                "usuario_id": null
            },
            {
                "_id": 8,
                "_Comentario__descripcion": "@MarianD the reason that \\s\\s+ is so popular is that there is often one e.g. in a column name, but multiple is rarer, and pandas output nicely puts in at least two between columns. Since this is just for toy/small datasets it's pretty powerful/majority of cases. Note: tabs separated would be a different story, though stackoverflow replaces tabs with spaces, but if you have a tsv then just use \\t.",
                "_Comentario__fecha": "2018-12-27 20:45:57Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Andy Hayden",
                "usuario_id": null
            },
            {
                "_id": 9,
                "_Comentario__descripcion": "Ugh, i always use pd.read_clipboard(), when their are spaces, i do: pd.read_clipboard(sep='\\s+{2,}', engine='python') :P",
                "_Comentario__fecha": "2019-06-10 11:26:36Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "U12-Forward",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 2,
        "_Respuesta__fecha": "2021-07-24 21:01:22Z",
        "_Respuesta__descripcion": "\nHow to create sample datasets\nThis is to mainly to expand on AndyHayden's answer by providing examples of how you can create sample dataframes.  Pandas and (especially) NumPy give you a variety of tools for this such that you can generally create a reasonable facsimile of any real dataset with just a few lines of code.\nAfter importing NumPy and Pandas, be sure to provide a random seed if you want folks to be able to exactly reproduce your data and results.\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(123)\n\nA kitchen sink example\nHere's an example showing a variety of things you can do.  All kinds of useful sample dataframes could be created from a subset of this:\ndf = pd.DataFrame({\n\n    # some ways to create random data\n    'a':np.random.randn(6),\n    'b':np.random.choice( [5,7,np.nan], 6),\n    'c':np.random.choice( ['panda','python','shark'], 6),\n\n    # some ways to create systematic groups for indexing or groupby\n    # this is similar to R's expand.grid(), see note 2 below\n    'd':np.repeat( range(3), 2 ),\n    'e':np.tile(   range(2), 3 ),\n\n    # a date range and set of random dates\n    'f':pd.date_range('1/1/2011', periods=6, freq='D'),\n    'g':np.random.choice( pd.date_range('1/1/2011', periods=365,\n                          freq='D'), 6, replace=False)\n    })\n\nThis produces:\n          a   b       c  d  e          f          g\n0 -1.085631 NaN   panda  0  0 2011-01-01 2011-08-12\n1  0.997345   7   shark  0  1 2011-01-02 2011-11-10\n2  0.282978   5   panda  1  0 2011-01-03 2011-10-30\n3 -1.506295   7  python  1  1 2011-01-04 2011-09-07\n4 -0.578600 NaN   shark  2  0 2011-01-05 2011-02-27\n5  1.651437   7  python  2  1 2011-01-06 2011-02-03\n\nSome notes:\n\nnp.repeat and np.tile (columns d and e) are very useful for creating groups and indices in a very regular way.  For 2 columns, this can be used to easily duplicate r's expand.grid() but is also more flexible in ability to provide a subset of all permutations.  However, for 3 or more columns the syntax quickly becomes unwieldy.\nFor a more direct replacement for R's expand.grid() see the itertools solution in the pandas cookbook or the np.meshgrid solution shown here.  Those will allow any number of dimensions.\nYou can do quite a bit with np.random.choice.  For example, in column g, we have a random selection of six dates from 2011.  Additionally, by setting replace=False we can assure these dates are unique -- very handy if we want to use this as an index with unique values.\n\nFake stock market data\nIn addition to taking subsets of the above code, you can further combine the techniques to do just about anything.  For example, here's a short example that combines np.tile and date_range to create sample ticker data for 4 stocks covering the same dates:\nstocks = pd.DataFrame({\n    'ticker':np.repeat( ['aapl','goog','yhoo','msft'], 25 ),\n    'date':np.tile( pd.date_range('1/1/2011', periods=25, freq='D'), 4 ),\n    'price':(np.random.randn(100).cumsum() + 10) })\n\nNow we have a sample dataset with 100 lines (25 dates per ticker), but we have only used 4 lines to do it, making it easy for everyone else to reproduce without copying and pasting 100 lines of code.  You can then display subsets of the data if it helps to explain your question:\n>>> stocks.head(5)\n\n        date      price ticker\n0 2011-01-01   9.497412   aapl\n1 2011-01-02  10.261908   aapl\n2 2011-01-03   9.438538   aapl\n3 2011-01-04   9.515958   aapl\n4 2011-01-05   7.554070   aapl\n\n>>> stocks.groupby('ticker').head(2)\n\n         date      price ticker\n0  2011-01-01   9.497412   aapl\n1  2011-01-02  10.261908   aapl\n25 2011-01-01   8.277772   goog\n26 2011-01-02   7.714916   goog\n50 2011-01-01   5.613023   yhoo\n51 2011-01-02   6.397686   yhoo\n75 2011-01-01  11.736584   msft\n76 2011-01-02  11.944519   msft\n\n    ",
        "_Respuesta__votes": 78,
        "comentarios": [
            {
                "_id": 10,
                "_Comentario__descripcion": "Great answer. After writing this question I actually did write a very short, simple implementation of expand.grid() that's included in the pandas cookbook, you could include that in your answer as well. Your answer shows how to create more complex datasets than my expand_grid() function could handle, which is great.",
                "_Comentario__fecha": "2015-05-24 23:29:16Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Marius",
                "usuario_id": null
            },
            {
                "_id": 11,
                "_Comentario__descripcion": "This is a really useful example and I'll be using it as a base for examples. Many thanks!",
                "_Comentario__fecha": "2020-11-08 05:42:32Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Serge de Gosson de Varennes",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 3,
        "_Respuesta__fecha": "2018-01-01 09:39:28Z",
        "_Respuesta__descripcion": "\nDiary of an Answerer\n\nMy best advice for asking questions would be to play on the psychology of the people who answer questions.  Being one of those people, I can give insight into why I answer certain questions and why I don't answer others.\n\nMotivations\n\nI'm motivated to answer questions for several reasons\n\n\nStackoverflow.com has been a tremendously valuable resource to me.  I wanted to give back.\nIn my efforts to give back, I've found this site to be an even more powerful resource than before.  Answering questions is a learning experience for me and I like to learn.  Read this answer and comment from another vet.  This kind of interaction makes me happy.\nI like points!\nSee #3.\nI like interesting problems.\n\n\nAll my purest intentions are great and all, but I get that satisfaction if I answer 1 question or 30.  What drives my choices for which questions to answer has a huge component of point maximization.\n\nI'll also spend time on interesting problems but that is few and far between and doesn't help an asker who needs a solution to a non-interesting question.  Your best bet to get me to answer a question is to serve that question up on a platter ripe for me to answer it with as little effort as possible.  If I'm looking at two questions and one has code I can copy paste to create all the variables I need... I'm taking that one!  I'll come back to the other one if I have time, maybe.\n\nMain Advice\n\nMake it easy for the people answering questions.\n\n\nProvide code that creates variables that are needed.\nMinimize that code.  If my eyes glaze over as I look at the post, I'm on to the next question or getting back to whatever else I'm doing.\nThink about what you're asking and be specific.  We want to see what you've done because natural languages (English) are inexact and confusing.  Code samples of what you've tried help resolve inconsistencies in a natural language description.\nPLEASE show what you expect!!!  I have to sit down and try things.  I almost never know the answer to a question without trying some things out.  If I don't see an example of what you're looking for, I might pass on the question because I don't feel like guessing.\n\n\nYour reputation is more than just your reputation.\n\nI like points (I mentioned that above).  But those points aren't really really my reputation.  My real reputation is an amalgamation of what others on the site think of me.  I strive to be fair and honest and I hope others can see that.  What that means for an asker is, we remember the behaviors of askers.  If you don't select answers and upvote good answers, I remember.  If you behave in ways I don't like or in ways I do like, I remember.  This also plays into which questions I'll answer.\n\n\n\nAnyway, I can probably go on, but I'll spare all of you who actually read this.\n    ",
        "_Respuesta__votes": 55,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 4,
        "_Respuesta__fecha": "2020-06-20 09:12:55Z",
        "_Respuesta__descripcion": "\nThe Challenge One of the most challenging aspects of responding to SO questions is the time it takes to recreate the problem (including the data).  Questions which don't have a clear way to reproduce the data are less likely to be answered.  Given that you are taking the time to write a question and you have an issue that you'd like help with, you can easily help yourself by providing data that others can then use to help solve your problem.\nThe instructions provided by @Andy for writing good Pandas questions are an excellent place to start.  For more information, refer to how to ask and how to create Minimal, Complete, and Verifiable examples.\nPlease clearly state your question upfront.  After taking the time to write your question and any sample code, try to read it and provide an 'Executive Summary' for your reader which summarizes the problem and clearly states the question.\nOriginal question:\n\nI have this data...\nI want to do this...\nI want my result to look like this...\nHowever, when I try to do [this], I get the following problem...\nI've tried to find solutions by doing [this] and [that].\nHow do I fix it?\n\nDepending on the amount of data, sample code and error stacks provided, the reader needs to go a long way before understanding what the problem is.  Try restating your question so that the question itself is on top, and then provide the necessary details.\nRevised Question:\n\nQustion:  How can I do [this]?\nI've tried to find solutions by doing [this] and [that].\nWhen I've tried to do [this], I get the following problem...\nI'd like my final results to look like this...\nHere is some minimal code that can reproduce my problem...\nAnd here is how to recreate my sample data:\ndf = pd.DataFrame({'A': [...], 'B': [...], ...})\n\nPROVIDE SAMPLE DATA IF NEEDED!!!\nSometimes just the head or tail of the DataFrame is all that is needed.  You can also use the methods proposed by @JohnE to create larger datasets that can be reproduced by others.  Using his example to generate a 100 row DataFrame of stock prices:\nstocks = pd.DataFrame({ \n    'ticker':np.repeat( ['aapl','goog','yhoo','msft'], 25 ),\n    'date':np.tile( pd.date_range('1/1/2011', periods=25, freq='D'), 4 ),\n    'price':(np.random.randn(100).cumsum() + 10) })\n\nIf this was your actual data, you may just want to include the head and/or tail of the dataframe as follows (be sure to anonymize any sensitive data):\n>>> stocks.head(5).to_dict()\n{'date': {0: Timestamp('2011-01-01 00:00:00'),\n  1: Timestamp('2011-01-01 00:00:00'),\n  2: Timestamp('2011-01-01 00:00:00'),\n  3: Timestamp('2011-01-01 00:00:00'),\n  4: Timestamp('2011-01-02 00:00:00')},\n 'price': {0: 10.284260107718254,\n  1: 11.930300761831457,\n  2: 10.93741046217319,\n  3: 10.884574289565609,\n  4: 11.78005850418319},\n 'ticker': {0: 'aapl', 1: 'aapl', 2: 'aapl', 3: 'aapl', 4: 'aapl'}}\n\n>>> pd.concat([stocks.head(), stocks.tail()], ignore_index=True).to_dict()\n{'date': {0: Timestamp('2011-01-01 00:00:00'),\n  1: Timestamp('2011-01-01 00:00:00'),\n  2: Timestamp('2011-01-01 00:00:00'),\n  3: Timestamp('2011-01-01 00:00:00'),\n  4: Timestamp('2011-01-02 00:00:00'),\n  5: Timestamp('2011-01-24 00:00:00'),\n  6: Timestamp('2011-01-25 00:00:00'),\n  7: Timestamp('2011-01-25 00:00:00'),\n  8: Timestamp('2011-01-25 00:00:00'),\n  9: Timestamp('2011-01-25 00:00:00')},\n 'price': {0: 10.284260107718254,\n  1: 11.930300761831457,\n  2: 10.93741046217319,\n  3: 10.884574289565609,\n  4: 11.78005850418319,\n  5: 10.017209045035006,\n  6: 10.57090128181566,\n  7: 11.442792747870204,\n  8: 11.592953372130493,\n  9: 12.864146419530938},\n 'ticker': {0: 'aapl',\n  1: 'aapl',\n  2: 'aapl',\n  3: 'aapl',\n  4: 'aapl',\n  5: 'msft',\n  6: 'msft',\n  7: 'msft',\n  8: 'msft',\n  9: 'msft'}}\n\nYou may also want to provide a description of the DataFrame (using only the relevant columns).  This makes it easier for others to check the data types of each column and identify other common errors (e.g. dates as string vs. datetime64 vs. object):\nstocks.info()\n<class 'pandas.core.frame.DataFrame'>\nInt64Index: 100 entries, 0 to 99\nData columns (total 3 columns):\ndate      100 non-null datetime64[ns]\nprice     100 non-null float64\nticker    100 non-null object\ndtypes: datetime64[ns](1), float64(1), object(1)\n\nNOTE:  If your DataFrame has a MultiIndex:\nIf your DataFrame has a multiindex, you must first reset before calling to_dict.  You then need to recreate the index using set_index:\n# MultiIndex example.  First create a MultiIndex DataFrame.\ndf = stocks.set_index(['date', 'ticker'])\n>>> df\n                       price\ndate       ticker           \n2011-01-01 aapl    10.284260\n           aapl    11.930301\n           aapl    10.937410\n           aapl    10.884574\n2011-01-02 aapl    11.780059\n...\n\n# After resetting the index and passing the DataFrame to `to_dict`, make sure to use \n# `set_index` to restore the original MultiIndex.  This DataFrame can then be restored.\n\nd = df.reset_index().to_dict()\ndf_new = pd.DataFrame(d).set_index(['date', 'ticker'])\n>>> df_new.head()\n                       price\ndate       ticker           \n2011-01-01 aapl    10.284260\n           aapl    11.930301\n           aapl    10.937410\n           aapl    10.884574\n2011-01-02 aapl    11.780059\n\n    ",
        "_Respuesta__votes": 34,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 5,
        "_Respuesta__fecha": "2020-11-08 03:20:49Z",
        "_Respuesta__descripcion": "\nHere is my version of dput - the standard R tool to produce reproducible reports - for Pandas DataFrames.\nIt will probably fail for more complex frames, but it seems to do the job in simple cases:\nimport pandas as pd\ndef dput(x):\n    if isinstance(x,pd.Series):\n        return \"pd.Series(%s,dtype='%s',index=pd.%s)\" % (list(x),x.dtype,x.index)\n    if isinstance(x,pd.DataFrame):\n        return \"pd.DataFrame({\" + \", \".join([\n            \"'%s': %s\" % (c,dput(x[c])) for c in x.columns]) + (\n                \"}, index=pd.%s)\" % (x.index))\n    raise NotImplementedError(\"dput\",type(x),x)\n\nnow,\ndf = pd.DataFrame({'a':[1,2,3,4,2,1,3,1]})\nassert df.equals(eval(dput(df)))\ndu = pd.get_dummies(df.a,\"foo\")\nassert du.equals(eval(dput(du)))\ndi = df\ndi.index = list('abcdefgh')\nassert di.equals(eval(dput(di)))\n\nNote that this produces a much more verbose output than DataFrame.to_dict, e.g.,\n\npd.DataFrame({\n  'foo_1':pd.Series([1, 0, 0, 0, 0, 1, 0, 1],dtype='uint8',index=pd.RangeIndex(start=0, stop=8, step=1)),\n  'foo_2':pd.Series([0, 1, 0, 0, 1, 0, 0, 0],dtype='uint8',index=pd.RangeIndex(start=0, stop=8, step=1)),\n  'foo_3':pd.Series([0, 0, 1, 0, 0, 0, 1, 0],dtype='uint8',index=pd.RangeIndex(start=0, stop=8, step=1)),\n  'foo_4':pd.Series([0, 0, 0, 1, 0, 0, 0, 0],dtype='uint8',index=pd.RangeIndex(start=0, stop=8, step=1))},\n  index=pd.RangeIndex(start=0, stop=8, step=1))\n\n\nvs\n\n{'foo_1': {0: 1, 1: 0, 2: 0, 3: 0, 4: 0, 5: 1, 6: 0, 7: 1}, \n 'foo_2': {0: 0, 1: 1, 2: 0, 3: 0, 4: 1, 5: 0, 6: 0, 7: 0}, \n 'foo_3': {0: 0, 1: 0, 2: 1, 3: 0, 4: 0, 5: 0, 6: 1, 7: 0}, \n 'foo_4': {0: 0, 1: 0, 2: 0, 3: 1, 4: 0, 5: 0, 6: 0, 7: 0}}\n\n\nfor du above, but it preserves column types.\nE.g., in the above test case,\ndu.equals(pd.DataFrame(du.to_dict()))\n==> False\n\nbecause du.dtypes is uint8 and pd.DataFrame(du.to_dict()).dtypes is int64.\n    ",
        "_Respuesta__votes": 19,
        "comentarios": [
            {
                "_id": 12,
                "_Comentario__descripcion": "it is clearer, though i admit i don't see why i would want to use it over to_dict",
                "_Comentario__fecha": "2017-02-23 16:55:01Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Paul H",
                "usuario_id": null
            },
            {
                "_id": 13,
                "_Comentario__descripcion": "Because it preserves column types. More specifically, du.equals(eval(dput(df))).",
                "_Comentario__fecha": "2017-02-23 16:57:25Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "sds",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 7,
        "_Respuesta__fecha": "2021-04-02 01:51:27Z",
        "_Respuesta__descripcion": "\nYou misunderstand how boolean expressions work; they don't work like an English sentence and guess that you are talking about the same comparison for all names here. You are looking for:\nif x == 1 or y == 1 or z == 1:\n\nx and y are otherwise evaluated on their own (False if 0, True otherwise).\nYou can shorten that using a containment test against a tuple:\nif 1 in (x, y, z):\n\nor better still:\nif 1 in {x, y, z}:\n\nusing a set to take advantage of the constant-cost membership test (i.e. in takes a fixed amount of time whatever the left-hand operand is).\nExplanation\nWhen you use or, python sees each side of the operator as separate expressions. The expression x or y == 1 is treated as first a boolean test for x, then if that is False, the expression y == 1 is tested.\nThis is due to operator precedence. The or operator has a lower precedence than the == test, so the latter is evaluated first.\nHowever, even if this were not the case, and the expression x or y or z == 1 was actually interpreted as (x or y or z) == 1 instead, this would still not do what you expect it to do.\nx or y or z would evaluate to the first argument that is 'truthy', e.g. not False, numeric 0 or empty (see boolean expressions for details on what Python considers false in a boolean context).\nSo for the values x = 2; y = 1; z = 0, x or y or z would resolve to 2, because that is the first true-like value in the arguments. Then 2 == 1 would be False, even though y == 1 would be True.\nThe same would apply to the inverse; testing multiple values against a single variable; x == 1 or 2 or 3 would fail for the same reasons. Use x == 1 or x == 2 or x == 3 or x in {1, 2, 3}.\n    ",
        "_Respuesta__votes": 991,
        "comentarios": [
            {
                "_id": 21,
                "_Comentario__descripcion": "I wouldn't be so quick to go for the set version.  Tuple's are very cheap to create and iterate over.  On my machine at least, tuples are faster than sets so long as the size of the tuple is around 4-8 elements.  If you have to scan more than that, use a set, but if you are looking for an item out of 2-4 possibilities, a tuple is still faster!  If you can arrange for the most likely case to be first in the tuple, the win is even bigger: (my test: timeit.timeit('0 in {seq}'.format(seq=tuple(range(9, -1, -1)))))",
                "_Comentario__fecha": "2013-10-24 15:27:12Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "SingleNegationElimination",
                "usuario_id": null
            },
            {
                "_id": 22,
                "_Comentario__descripcion": "@dequestarmappartialsetattr: In Python 3.3 and up, the set is stored as a constant, bypassing the creation time altogether, eliminating the creation time. Tuples can be cheap to create as Python caches a bundle of them to avoid memory churn, making that the biggest difference with sets here.",
                "_Comentario__fecha": "2013-10-24 15:29:51Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Martijn Pieters\u2666",
                "usuario_id": null
            },
            {
                "_id": 23,
                "_Comentario__descripcion": "@dequestarmappartialsetattr: If you time just the membership test, for integers sets and tuples are equally fast for the ideal scenario; matching the first element. After that tuples lose out to sets.",
                "_Comentario__fecha": "2013-10-24 15:37:11Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Martijn Pieters\u2666",
                "usuario_id": null
            },
            {
                "_id": 24,
                "_Comentario__descripcion": "@MartijnPieters: Using the set literal notation for this test isn't a savings unless the contents of the set literal are also literals, right? if 1 in {x, y, z}: can't cache the set, because x, y and z could change, so either solution needs to build a tuple or set from scratch, and I suspect whatever lookup savings you might get when checking for membership would be swamped by greater set creation time.",
                "_Comentario__fecha": "2016-09-04 00:37:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ShadowRanger",
                "usuario_id": null
            },
            {
                "_id": 25,
                "_Comentario__descripcion": "@ShadowRanger: yes, peephole optimisation (be it for in [...] or in {...}) only works if the contents of the list or set are immutable literals too.",
                "_Comentario__fecha": "2016-09-04 07:58:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Martijn Pieters\u2666",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 8,
        "_Respuesta__fecha": "2017-10-25 14:45:52Z",
        "_Respuesta__descripcion": "\nYour problem is more easily addressed with a dictionary structure like:\n\nx = 0\ny = 1\nz = 3\nd = {0: 'c', 1:'d', 2:'e', 3:'f'}\nmylist = [d[k] for k in [x, y, z]]\n\n    ",
        "_Respuesta__votes": 108,
        "comentarios": [
            {
                "_id": 26,
                "_Comentario__descripcion": "Or even d = \"cdef\" which leads to MyList = [\"cdef\"[k] for k in [x, y, z]]",
                "_Comentario__fecha": "2013-10-24 15:39:35Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "aragaer",
                "usuario_id": null
            },
            {
                "_id": 27,
                "_Comentario__descripcion": "or map(lambda i: 'cdef'[i], [x, y, z])",
                "_Comentario__fecha": "2014-05-08 14:36:49Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "dansalmo",
                "usuario_id": null
            },
            {
                "_id": 28,
                "_Comentario__descripcion": "Aside from the list comprehension which I'm not yet fully accustomed to, most of us had the same reflex: build that dict !",
                "_Comentario__fecha": "2019-03-10 18:57:53Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "LoneWanderer",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 9,
        "_Respuesta__fecha": "2019-05-07 09:30:20Z",
        "_Respuesta__descripcion": "\nAs stated by Martijn Pieters, the correct, and fastest, format is:\n\nif 1 in {x, y, z}:\n\n\nUsing his advice you would now have separate if-statements so that Python will read each statement whether the former were True or False. Such as:\n\nif 0 in {x, y, z}:\n    mylist.append(\"c\")\nif 1 in {x, y, z}:\n    mylist.append(\"d\")\nif 2 in {x, y, z}:\n    mylist.append(\"e\")\n...\n\n\nThis will work, but if you are comfortable using dictionaries (see what I did there), you can clean this up by making an initial dictionary mapping the numbers to the letters you want, then just using a for-loop:\n\nnum_to_letters = {0: \"c\", 1: \"d\", 2: \"e\", 3: \"f\"}\nfor number in num_to_letters:\n    if number in {x, y, z}:\n        mylist.append(num_to_letters[number])\n\n    ",
        "_Respuesta__votes": 71,
        "comentarios": [
            {
                "_id": 29,
                "_Comentario__descripcion": "@VisioN You mean for number in num_to_letters? You don't need .keys(), dicts iterate over keys by default. Regarding using a string, you mean something like this, right? for i, c in enumerate('cdef'): if i in {x, y, z}: mylist.append(c) Agreed, that would be simpler. Or better yet, s = 'cdef'; mylist = [s[i] for i in [x, y, z]]",
                "_Comentario__fecha": "2020-11-28 22:03:13Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "wjandrea",
                "usuario_id": null
            },
            {
                "_id": 30,
                "_Comentario__descripcion": "@wjandrea Yes, you are right, it's my mistake! I completely forgot about the default behaviour. Unfortunately, I cannot edit my comment, so I have deleted it since you have highlighted the better approach in your comment.",
                "_Comentario__fecha": "2020-11-29 11:09:08Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "VisioN",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 10,
        "_Respuesta__fecha": "2013-07-11 21:24:59Z",
        "_Respuesta__descripcion": "\nThe direct way to write x or y or z == 0 is\n\nif any(map((lambda value: value == 0), (x,y,z))):\n    pass # write your logic.\n\n\nBut I dont think, you like it. :)\nAnd this way is ugly.\n\nThe other way (a better) is:\n\n0 in (x, y, z)\n\n\nBTW lots of ifs could be written as something like this\n\nmy_cases = {\n    0: Mylist.append(\"c\"),\n    1: Mylist.append(\"d\")\n    # ..\n}\n\nfor key in my_cases:\n    if key in (x,y,z):\n        my_cases[key]()\n        break\n\n    ",
        "_Respuesta__votes": 50,
        "comentarios": [
            {
                "_id": 31,
                "_Comentario__descripcion": "In your example of the dict instead of a key, you will get errors because the return value of .append is None, and calling None gives an AttributeError.  In general I agree with this method, though.",
                "_Comentario__fecha": "2014-02-08 20:57:33Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "SethMMorton",
                "usuario_id": null
            },
            {
                "_id": 32,
                "_Comentario__descripcion": "the dict instead of a key is wrong, you will get Mylist=['c', 'd'] when the dictionary get initialized even if you commented out \"for..loop\" part",
                "_Comentario__fecha": "2019-04-07 01:41:32Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mahmoud Elshahat",
                "usuario_id": null
            },
            {
                "_id": 33,
                "_Comentario__descripcion": "In your first example filter would be better than map, as it will return only instances where lambda evaluates to true",
                "_Comentario__fecha": "2019-09-16 05:17:22Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Alex",
                "usuario_id": null
            },
            {
                "_id": 34,
                "_Comentario__descripcion": "A comprehension is much simpler than a map of a lambda: any(v == 0 for v in (x, y, z))",
                "_Comentario__fecha": "2020-02-08 05:21:05Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "wjandrea",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 11,
        "_Respuesta__fecha": "2015-08-13 18:06:52Z",
        "_Respuesta__descripcion": "\nIf you ARE very very lazy, you can put the values inside an array. Such as\n\nlist = []\nlist.append(x)\nlist.append(y)\nlist.append(z)\nnums = [add numbers here]\nletters = [add corresponding letters here]\nfor index in range(len(nums)):\n    for obj in list:\n        if obj == num[index]:\n            MyList.append(letters[index])\n            break\n\n\nYou can also put the numbers and letters in a dictionary and do it, but this is probably a LOT more complicated than simply if statements. That's what you get for trying to be extra lazy :)\n\nOne more thing, your \n\nif x or y or z == 0:\n\n\nwill compile, but not in the way you want it to. When you simply put a variable in an if statement (example)\n\nif b\n\n\nthe program will check if the variable is not null. Another way to write the above statement (which makes more sense) is \n\nif bool(b)\n\n\nBool is an inbuilt function in python which basically does the command of verifying a boolean statement (If you don't know what that is, it is what you are trying to make in your if statement right now :))\n\nAnother lazy way I found is :\n\nif any([x==0, y==0, z==0])\n\n    ",
        "_Respuesta__votes": 36,
        "comentarios": [
            {
                "_id": 35,
                "_Comentario__descripcion": "-1 There's a lot of bad practice here. list is a Python builtin; use another name instead, like xyz for example. Why do you construct the list in four steps when you can do one, i.e. xyz = [x, y, z]? Don't use parallel lists, use a dict instead. All in all, this solution is much more convoluted than ThatGuyRussell's. Also for the last part, why not do a comprehension, i.e. any(v == 0 for v in (x, y, z))? Also arrays are something else in Python.",
                "_Comentario__fecha": "2020-02-08 05:36:16Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "wjandrea",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 12,
        "_Respuesta__fecha": "2014-06-05 11:31:39Z",
        "_Respuesta__descripcion": "\nTo check if a value is contained within a set of variables you can use the inbuilt modules           itertools and operator.\n\nFor example:\n\nImports:\n\nfrom itertools import repeat\nfrom operator import contains\n\n\nDeclare variables:\n\nx = 0\ny = 1\nz = 3\n\n\nCreate mapping of values (in the order you want to check):\n\ncheck_values = (0, 1, 3)\n\n\nUse itertools to allow repetition of the variables:\n\ncheck_vars = repeat((x, y, z))\n\n\nFinally, use the map function to create an iterator:\n\nchecker = map(contains, check_vars, check_values)\n\n\nThen, when checking for the values (in the original order), use next():\n\nif next(checker)  # Checks for 0\n    # Do something\n    pass\nelif next(checker)  # Checks for 1\n    # Do something\n    pass\n\n\netc...\n\nThis has an advantage over the lambda x: x in (variables) because operator is an inbuilt module and is faster and more efficient than using lambda which has to create a custom in-place function.\n\nAnother option for checking if there is a non-zero (or False) value in a list:\n\nnot (x and y and z)\n\n\nEquivalent:\n\nnot all((x, y, z))\n\n    ",
        "_Respuesta__votes": 33,
        "comentarios": [
            {
                "_id": 36,
                "_Comentario__descripcion": "This doesn't answer the OP's question.  It only covers the first case in the provided example.",
                "_Comentario__fecha": "2014-06-04 17:39:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "wallacer",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 13,
        "_Respuesta__fecha": "2015-02-10 14:58:02Z",
        "_Respuesta__descripcion": "\nI think this will handle it better:\n\nmy_dict = {0: \"c\", 1: \"d\", 2: \"e\", 3: \"f\"}\n\ndef validate(x, y, z):\n    for ele in [x, y, z]:\n        if ele in my_dict.keys():\n            return my_dict[ele]\n\n\nOutput:\n\nprint validate(0, 8, 9)\nc\nprint validate(9, 8, 9)\nNone\nprint validate(9, 8, 2)\ne\n\n    ",
        "_Respuesta__votes": 31,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 14,
        "_Respuesta__fecha": "2018-04-01 13:10:46Z",
        "_Respuesta__descripcion": "\nSet is the good approach here, because it orders the variables, what seems to be your goal here. {z,y,x} is {0,1,3} whatever the order of the parameters.\n\n>>> [\"cdef\"[i] for i in {z,x,y}]\n['c', 'd', 'f']\n\n\nThis way, the whole solution is O(n).\n    ",
        "_Respuesta__votes": 31,
        "comentarios": [
            {
                "_id": 37,
                "_Comentario__descripcion": "You should add a description of what your code accomplishes and how it does it. Short answers using only code is discouraged",
                "_Comentario__fecha": "2015-06-10 04:19:22Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Raniz",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 15,
        "_Respuesta__fecha": "2018-09-04 11:59:05Z",
        "_Respuesta__descripcion": "\nAll of the excellent answers provided here concentrate on the specific requirement of the original poster and concentrate on the if 1 in {x,y,z} solution put forward by Martijn Pieters.\nWhat they ignore is the broader implication of the question:\nHow do I test one variable against multiple values?\nThe solution provided will not work for partial hits if using strings for example:\nTest if the string \"Wild\" is in multiple values\n\n>>> x = \"Wild things\"\n>>> y = \"throttle it back\"\n>>> z = \"in the beginning\"\n>>> if \"Wild\" in {x, y, z}: print (True)\n... \n\n\nor\n\n>>> x = \"Wild things\"\n>>> y = \"throttle it back\"\n>>> z = \"in the beginning\"\n>>> if \"Wild\" in [x, y, z]: print (True)\n... \n\n\nfor this scenario it's easiest to convert to a string\n\n>>> [x, y, z]\n['Wild things', 'throttle it back', 'in the beginning']\n>>> {x, y, z}\n{'in the beginning', 'throttle it back', 'Wild things'}\n>>> \n\n>>> if \"Wild\" in str([x, y, z]): print (True)\n... \nTrue\n>>> if \"Wild\" in str({x, y, z}): print (True)\n... \nTrue\n\n\nIt should be noted however, as mentioned by @codeforester, that word boundries are lost with this method, as in:    \n\n>>> x=['Wild things', 'throttle it back', 'in the beginning']\n>>> if \"rot\" in str(x): print(True)\n... \nTrue\n\n\nthe 3 letters rot do exist in combination in the list but not as an individual word. Testing for \" rot \" would fail but if one of the list items were \"rot in hell\", that would fail as well.\nThe upshot being, be careful with your search criteria if using this method and be aware that it does have this limitation.\n    ",
        "_Respuesta__votes": 31,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 16,
        "_Respuesta__fecha": "2018-09-04 03:53:17Z",
        "_Respuesta__descripcion": "\nIf you want to use if, else statements following is another solution:\n\nmyList = []\naList = [0, 1, 3]\n\nfor l in aList:\n    if l==0: myList.append('c')\n    elif l==1: myList.append('d')\n    elif l==2: myList.append('e')\n    elif l==3: myList.append('f')\n\nprint(myList)\n\n    ",
        "_Respuesta__votes": 30,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 17,
        "_Respuesta__fecha": "2015-06-29 07:03:58Z",
        "_Respuesta__descripcion": "\nThis code may be helpful\n\nL ={x, y, z}\nT= ((0,\"c\"),(1,\"d\"),(2,\"e\"),(3,\"f\"),)\nList2=[]\nfor t in T :\nif t[0] in L :\n    List2.append(t[1])\n    break;\n\n    ",
        "_Respuesta__votes": 27,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 18,
        "_Respuesta__fecha": "2015-02-27 01:48:29Z",
        "_Respuesta__descripcion": "\nd = {0:'c', 1:'d', 2:'e', 3: 'f'}\nx, y, z = (0, 1, 3)\nprint [v for (k,v) in d.items() if x==k or y==k or z==k]\n\n    ",
        "_Respuesta__votes": 26,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 19,
        "_Respuesta__fecha": "2018-12-03 05:13:18Z",
        "_Respuesta__descripcion": "\nYou can try the method shown below. In this method, you will have the freedom to specify/input the number of variables that you wish to enter.\n\nmydict = {0:\"c\", 1:\"d\", 2:\"e\", 3:\"f\"}\nmylist= []\n\nnum_var = int(raw_input(\"How many variables? \")) #Enter 3 when asked for input.\n\nfor i in range(num_var): \n    ''' Enter 0 as first input, 1 as second input and 3 as third input.'''\n    globals()['var'+str('i').zfill(3)] = int(raw_input(\"Enter an integer between 0 and 3 \"))\n    mylist += mydict[globals()['var'+str('i').zfill(3)]]\n\nprint mylist\n>>> ['c', 'd', 'f']\n\n    ",
        "_Respuesta__votes": 13,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 20,
        "_Respuesta__fecha": "2017-06-05 06:50:28Z",
        "_Respuesta__descripcion": "\nOne line solution:\n\nmylist = [{0: 'c', 1: 'd', 2: 'e', 3: 'f'}[i] for i in [0, 1, 2, 3] if i in (x, y, z)]\n\n\nOr:\n\nmylist = ['cdef'[i] for i in range(4) if i in (x, y, z)]\n\n    ",
        "_Respuesta__votes": 11,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 21,
        "_Respuesta__fecha": "2020-07-11 00:08:50Z",
        "_Respuesta__descripcion": "\nThe most pythonic way of representing your pseudo-code in Python would be:\nx = 0\ny = 1\nz = 3\nmylist = []\n\nif any(v == 0 for v in (x, y, z)):\n    mylist.append(\"c\")\nif any(v == 1 for v in (x, y, z)):\n    mylist.append(\"d\")\nif any(v == 2 for v in (x, y, z)):\n    mylist.append(\"e\")\nif any(v == 3 for v in (x, y, z)):\n    mylist.append(\"f\")\n\n    ",
        "_Respuesta__votes": 10,
        "comentarios": [
            {
                "_id": 38,
                "_Comentario__descripcion": "This approach is more universal than ` if 2 in (x, y, z): mylist.append('e')` because allows arbitrary comparisons (e.g. if any(v >= 42 for v in (x, y, z)): ).  And performance of all 3 methods (2 in {x,y,z}, 2 in (x,y,z), any(_v == 2 for _v in (x,y,z))) seems to be almost the same in CPython3.6 (see Gist)",
                "_Comentario__fecha": "2019-05-04 04:47:11Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "imposeren",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 22,
        "_Respuesta__fecha": "2019-04-10 17:49:04Z",
        "_Respuesta__descripcion": "\nMaybe you need direct formula for output bits set.\n\nx=0 or y=0 or z=0   is equivalent to x*y*z = 0\n\nx=1 or y=1 or z=1   is equivalent to (x-1)*(y-1)*(z-1)=0\n\nx=2 or y=2 or z=2   is equivalent to (x-2)*(y-2)*(z-2)=0\n\n\nLet's map to bits: 'c':1 'd':0xb10 'e':0xb100 'f':0xb1000\n\nRelation of isc (is 'c'):\n\nif xyz=0 then isc=1 else isc=0\n\n\nUse math if formula https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&t=315\n\n[c]: (xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))\n\n[d]: ((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))\n\n...\n\nConnect these formulas by following logic:\n\n\nlogic and is the sum of squares of equations\nlogic or is the product of equations\n\n\nand you'll have a total equation\nexpress sum and you have total formula of sum\n\nthen sum&1 is c, sum&2 is d, sum&4 is e, sum&5 is f\n\nAfter this you may form predefined array where index of string elements would correspond to ready string.\n\narray[sum] gives you the string.\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 23,
        "_Respuesta__fecha": "2018-11-06 14:26:24Z",
        "_Respuesta__descripcion": "\nIt can be done easily as \n\nfor value in [var1,var2,var3]:\n     li.append(\"targetValue\")\n\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 24,
        "_Respuesta__fecha": "2018-09-20 02:18:55Z",
        "_Respuesta__descripcion": "\nTo test multiple variables with one single value: if 1 in {a,b,c}:\n\nTo test multiple values with one variable: if a in {1, 2, 3}:\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 25,
        "_Respuesta__fecha": "2018-08-27 09:45:00Z",
        "_Respuesta__descripcion": "\nLooks like you're building some kind of Caesar cipher.\n\nA much more generalized approach is this:\n\ninput_values = (0, 1, 3)\norigo = ord('c')\n[chr(val + origo) for val in inputs]\n\n\noutputs\n\n['c', 'd', 'f']\n\n\nNot sure if it's a desired side effect of your code, but the order of your output will always be sorted.\n\nIf this is what you want, the final line can be changed to:\n\nsorted([chr(val + origo) for val in inputs])\n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 26,
        "_Respuesta__fecha": "2018-07-31 16:54:00Z",
        "_Respuesta__descripcion": "\nYou can use dictionary :\n\nx = 0\ny = 1\nz = 3\nlist=[]\ndict = {0: 'c', 1: 'd', 2: 'e', 3: 'f'}\nif x in dict:\n    list.append(dict[x])\nelse:\n    pass\n\nif y in dict:\n    list.append(dict[y])\nelse:\n    pass\nif z in dict:\n    list.append(dict[z])\nelse:\n    pass\n\nprint list\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [
            {
                "_id": 39,
                "_Comentario__descripcion": "This may append same more then once this. Set?",
                "_Comentario__fecha": "2019-02-19 04:49:25Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Serg",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 27,
        "_Respuesta__fecha": "2019-10-11 12:17:15Z",
        "_Respuesta__descripcion": "\nWithout dict, try this solution:\n\nx, y, z = 0, 1, 3    \noffset = ord('c')\n[chr(i + offset) for i in (x,y,z)]\n\n\nand gives:\n\n['c', 'd', 'f']\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 28,
        "_Respuesta__fecha": "2019-09-09 18:23:24Z",
        "_Respuesta__descripcion": "\nYou can unite this\n\nx = 0\ny = 1\nz = 3\n\n\nin one variable.\n\nIn [1]: xyz = (0,1,3,) \nIn [2]: mylist = []\n\n\nChange our conditions as:\n\nIn [3]: if 0 in xyz: \n    ...:     mylist.append(\"c\") \n    ...: if 1 in xyz: \n    ...:     mylist.append(\"d\") \n    ...: if 2 in xyz: \n    ...:     mylist.append(\"e\") \n    ...: if 3 in xyz:  \n    ...:     mylist.append(\"f\") \n\n\nOutput:\n\nIn [21]: mylist                                                                                \nOut[21]: ['c', 'd', 'f']\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 29,
        "_Respuesta__fecha": "2019-04-08 05:18:38Z",
        "_Respuesta__descripcion": "\nThis will help you.\n\ndef test_fun(val):\n    x = 0\n    y = 1\n    z = 2\n    myList = []\n    if val in (x, y, z) and val == 0:\n        myList.append(\"C\")\n    if val in (x, y, z) and val == 1:\n        myList.append(\"D\")\n    if val in (x, y, z) and val == 2:\n        myList.append(\"E\")\n\ntest_fun(2);\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 30,
        "_Respuesta__fecha": "2019-11-06 11:20:35Z",
        "_Respuesta__descripcion": "\nProblem\n\nWhile the pattern for testing multiple values\n\n>>> 2 in {1, 2, 3}\nTrue\n>>> 5 in {1, 2, 3}\nFalse\n\n\nis very readable and is working in many situation, there is one pitfall:\n\n>>> 0 in {True, False}\nTrue\n\n\nBut we want to have\n\n>>> (0 is True) or (0 is False)\nFalse\n\n\nSolution\n\nOne generalization of the previous expression is based on the answer from ytpillai:\n\n>>> any([0 is True, 0 is False])\nFalse\n\n\nwhich can be written as\n\n>>> any(0 is item for item in (True, False))\nFalse\n\n\nWhile this expression returns the right result it is not as readable as the first expression :-(\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 31,
        "_Respuesta__fecha": "2020-09-24 15:21:04Z",
        "_Respuesta__descripcion": "\nyou can develop it through two ways\n    def compareVariables(x,y,z):\n        mylist = []\n        if x==0 or y==0 or z==0:\n            mylist.append('c')\n        if  x==1 or y==1 or z==1:\n            mylist.append('d')\n        if  x==2 or y==2 or z==2:\n            mylist.append('e')\n        if  x==3 or y==3 or z==3:\n            mylist.append('f')\n        else:\n            print(\"wrong input value!\")\n        print('first:',mylist)\n\n        compareVariables(1, 3, 2)\n\nOr\n    def compareVariables(x,y,z):\n        mylist = []\n        if 0 in (x,y,z):\n             mylist.append('c')\n        if 1 in (x,y,z):\n             mylist.append('d')\n        if 2 in (x,y,z):\n             mylist.append('e')\n        if 3 in (x,y,z):\n             mylist.append('f')\n        else:\n             print(\"wrong input value!\")\n        print('second:',mylist)\n\n        compareVariables(1, 3, 2)\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 32,
        "_Respuesta__fecha": "2021-04-11 19:30:17Z",
        "_Respuesta__descripcion": "\nThe or does not work like that, as explained by this answer.\nWhile the generic answer would be use\nif 0 in (x, y, z):\n    ...\n\nthis is not the best one for the specific problem. In your case you're doing repeated tests, therefore it is worthwhile to compose a set of these variables:\nvalues = {x, y, z}\n\nif 0 in values:\n    mylist.append(\"c\")\n\nif 1 in values:\n    mylist.append(\"d\")\n\nWe can simplify this using a dictionary - this will result in the same values:\nmappings = {0: \"c\", 1: \"d\", ...}\nfor k in mappings:\n    if k in values:\n        mylist.append(mappings[k])\n\nOr if the ordering of the mylist is arbitrary, you can loop over the values instead and match them to the mappings:\nmappings = {0: \"c\", 1: \"d\", ...}\nfor v in (x, y, z):\n    if v in mappings:\n        mylist.append(mappings[v])\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 33,
        "_Respuesta__fecha": "2021-04-12 01:33:17Z",
        "_Respuesta__descripcion": "\nHere is one more way to do it:\nx = 0\ny = 1\nz = 3\nmylist = []\n\nif any(i in [0] for i in[x,y,z]):\n    mylist.append(\"c\")\nif any(i in [1] for i in[x,y,z]):\n    mylist.append(\"d\")\nif any(i in [2] for i in[x,y,z]):\n    mylist.append(\"e\")\nif any(i in [3] for i in[x,y,z]):\n    mylist.append(\"f\")\n\nIt is a mix of list comprehension and any keyword.\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [
            {
                "_id": 40,
                "_Comentario__descripcion": "Why i in [0] instead of just i == 0?",
                "_Comentario__fecha": "2021-04-12 17:08:48Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Tomerikoo",
                "usuario_id": null
            },
            {
                "_id": 41,
                "_Comentario__descripcion": "For a single comparison like in this question, you can use \"==\" but if you want multiple comparisons with multiple variables, then you can use the \"in\" operator like: if any(i in [0,5,4,9,7] for i in[x,y,z] )",
                "_Comentario__fecha": "2021-04-13 01:21:26Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Abhishek Kumar Saw",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 35,
        "_Respuesta__fecha": "2020-06-06 17:56:58Z",
        "_Respuesta__descripcion": "\nThe simplest way to accomplish this is to put the input method in a while loop. Use continue when you get bad input, and break out of the loop when you're satisfied.\n\nWhen Your Input Might Raise an Exception\n\nUse try and except to detect when the user enters data that can't be parsed.\n\nwhile True:\n    try:\n        # Note: Python 2.x users should use raw_input, the equivalent of 3.x's input\n        age = int(input(\"Please enter your age: \"))\n    except ValueError:\n        print(\"Sorry, I didn't understand that.\")\n        #better try again... Return to the start of the loop\n        continue\n    else:\n        #age was successfully parsed!\n        #we're ready to exit the loop.\n        break\nif age >= 18: \n    print(\"You are able to vote in the United States!\")\nelse:\n    print(\"You are not able to vote in the United States.\")\n\n\nImplementing Your Own Validation Rules\n\nIf you want to reject values that Python can successfully parse, you can add your own validation logic.\n\nwhile True:\n    data = input(\"Please enter a loud message (must be all caps): \")\n    if not data.isupper():\n        print(\"Sorry, your response was not loud enough.\")\n        continue\n    else:\n        #we're happy with the value given.\n        #we're ready to exit the loop.\n        break\n\nwhile True:\n    data = input(\"Pick an answer from A to D:\")\n    if data.lower() not in ('a', 'b', 'c', 'd'):\n        print(\"Not an appropriate choice.\")\n    else:\n        break\n\n\nCombining Exception Handling and Custom Validation\n\nBoth of the above techniques can be combined into one loop.\n\nwhile True:\n    try:\n        age = int(input(\"Please enter your age: \"))\n    except ValueError:\n        print(\"Sorry, I didn't understand that.\")\n        continue\n\n    if age < 0:\n        print(\"Sorry, your response must not be negative.\")\n        continue\n    else:\n        #age was successfully parsed, and we're happy with its value.\n        #we're ready to exit the loop.\n        break\nif age >= 18: \n    print(\"You are able to vote in the United States!\")\nelse:\n    print(\"You are not able to vote in the United States.\")\n\n\nEncapsulating it All in a Function\n\nIf you need to ask your user for a lot of different values, it might be useful to put this code in a function, so you don't have to retype it every time.\n\ndef get_non_negative_int(prompt):\n    while True:\n        try:\n            value = int(input(prompt))\n        except ValueError:\n            print(\"Sorry, I didn't understand that.\")\n            continue\n\n        if value < 0:\n            print(\"Sorry, your response must not be negative.\")\n            continue\n        else:\n            break\n    return value\n\nage = get_non_negative_int(\"Please enter your age: \")\nkids = get_non_negative_int(\"Please enter the number of children you have: \")\nsalary = get_non_negative_int(\"Please enter your yearly earnings, in dollars: \")\n\n\nPutting It All Together\n\nYou can extend this idea to make a very generic input function:\n\ndef sanitised_input(prompt, type_=None, min_=None, max_=None, range_=None):\n    if min_ is not None and max_ is not None and max_ < min_:\n        raise ValueError(\"min_ must be less than or equal to max_.\")\n    while True:\n        ui = input(prompt)\n        if type_ is not None:\n            try:\n                ui = type_(ui)\n            except ValueError:\n                print(\"Input type must be {0}.\".format(type_.__name__))\n                continue\n        if max_ is not None and ui > max_:\n            print(\"Input must be less than or equal to {0}.\".format(max_))\n        elif min_ is not None and ui < min_:\n            print(\"Input must be greater than or equal to {0}.\".format(min_))\n        elif range_ is not None and ui not in range_:\n            if isinstance(range_, range):\n                template = \"Input must be between {0.start} and {0.stop}.\"\n                print(template.format(range_))\n            else:\n                template = \"Input must be {0}.\"\n                if len(range_) == 1:\n                    print(template.format(*range_))\n                else:\n                    expected = \" or \".join((\n                        \", \".join(str(x) for x in range_[:-1]),\n                        str(range_[-1])\n                    ))\n                    print(template.format(expected))\n        else:\n            return ui\n\n\nWith usage such as:\n\nage = sanitised_input(\"Enter your age: \", int, 1, 101)\nanswer = sanitised_input(\"Enter your answer: \", str.lower, range_=('a', 'b', 'c', 'd'))\n\n\nCommon Pitfalls, and Why you Should Avoid Them\n\nThe Redundant Use of Redundant input Statements\n\nThis method works but is generally considered poor style:\n\ndata = input(\"Please enter a loud message (must be all caps): \")\nwhile not data.isupper():\n    print(\"Sorry, your response was not loud enough.\")\n    data = input(\"Please enter a loud message (must be all caps): \")\n\n\nIt might look attractive initially because it's shorter than the while True method, but it violates the Don't Repeat Yourself principle of software development. This increases the likelihood of bugs in your system. What if you want to backport to 2.7 by changing input to raw_input, but accidentally change only the first input above? It's a SyntaxError just waiting to happen.\n\nRecursion Will Blow Your Stack\n\nIf you've just learned about recursion, you might be tempted to use it in get_non_negative_int so you can dispose of the while loop.\n\ndef get_non_negative_int(prompt):\n    try:\n        value = int(input(prompt))\n    except ValueError:\n        print(\"Sorry, I didn't understand that.\")\n        return get_non_negative_int(prompt)\n\n    if value < 0:\n        print(\"Sorry, your response must not be negative.\")\n        return get_non_negative_int(prompt)\n    else:\n        return value\n\n\nThis appears to work fine most of the time, but if the user enters invalid data enough times, the script will terminate with a RuntimeError: maximum recursion depth exceeded. You may think \"no fool would make 1000 mistakes in a row\", but you're underestimating the ingenuity of fools!\n    ",
        "_Respuesta__votes": 852,
        "comentarios": [
            {
                "_id": 52,
                "_Comentario__descripcion": "Its fun reading it with many examples, kudos. Underrated lesson: \"Don't underestimate the ingenuity of fools!\"",
                "_Comentario__fecha": "2017-01-03 02:02:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "vpibano",
                "usuario_id": null
            },
            {
                "_id": 53,
                "_Comentario__descripcion": "Not only would I have upvoted both the Q&A anyway, as they're great, but you sealed the deal with \"dickety six\". Well done, @Kevin.",
                "_Comentario__fecha": "2018-02-02 15:58:58Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "erekalper",
                "usuario_id": null
            },
            {
                "_id": 54,
                "_Comentario__descripcion": "Don't estimate the ingenuity of fools... and clever attackers. A DOS attack would be easiest for this sort of thing, but others may be possible.",
                "_Comentario__fecha": "2019-04-28 02:53:37Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Solomon Ucko",
                "usuario_id": null
            },
            {
                "_id": 55,
                "_Comentario__descripcion": "@JArunMani I don't think it would be poor style, but might be a little less readable. You will indeed have only one input per loop and the loop will become very short, but the condition might become pretty long...",
                "_Comentario__fecha": "2020-05-09 08:40:15Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Tomerikoo",
                "usuario_id": null
            },
            {
                "_id": 56,
                "_Comentario__descripcion": "@laundmo,certainly I release the code blocks that I wrote into the public domain. Feel free to use them in any context, without my explicit permission or knowledge. Regarding the non-code-block segments, If you want to paste my entire answer into a \"Learn Python\" book you're writing, let's talk royalties ;-)",
                "_Comentario__fecha": "2020-07-24 13:50:12Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Kevin",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 36,
        "_Respuesta__fecha": "2018-02-24 16:44:54Z",
        "_Respuesta__descripcion": "\nWhy would you do a while True and then break out of this loop while you can also just put your requirements in the while statement since all you want is to stop once you have the age?\n\nage = None\nwhile age is None:\n    input_value = input(\"Please enter your age: \")\n    try:\n        # try and convert the string input to a number\n        age = int(input_value)\n    except ValueError:\n        # tell the user off\n        print(\"{input} is not a number, please enter a number only\".format(input=input_value))\nif age >= 18:\n    print(\"You are able to vote in the United States!\")\nelse:\n    print(\"You are not able to vote in the United States.\")\n\n\nThis would result in the following:\n\nPlease enter your age: *potato*\npotato is not a number, please enter a number only\nPlease enter your age: *5*\nYou are not able to vote in the United States.\n\n\nthis will work since age will never have a value that will not make sense and the code follows the logic of your \"business process\"\n    ",
        "_Respuesta__votes": 50,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 37,
        "_Respuesta__fecha": "2018-12-21 18:25:22Z",
        "_Respuesta__descripcion": "\nThough the accepted answer is amazing. I would also like to share a quick hack for this problem. (This takes care of the negative age problem as well.) \n\nf=lambda age: (age.isdigit() and ((int(age)>=18  and \"Can vote\" ) or \"Cannot vote\")) or \\\nf(input(\"invalid input. Try again\\nPlease enter your age: \"))\nprint(f(input(\"Please enter your age: \")))\n\n\nP.S. This code is for python 3.x.\n    ",
        "_Respuesta__votes": 26,
        "comentarios": [
            {
                "_id": 57,
                "_Comentario__descripcion": "Note that this code is recursive, but recursion isn't necessary here, and as Kevin said, it can blow your stack.",
                "_Comentario__fecha": "2016-01-31 08:12:08Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "PM 2Ring",
                "usuario_id": null
            },
            {
                "_id": 58,
                "_Comentario__descripcion": "@PM2Ring - you are right. But my purpose here was just to show how \"short circuiting\" can minimise (beautify) long pieces of code.",
                "_Comentario__fecha": "2016-02-03 08:58:15Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "aaveg",
                "usuario_id": null
            },
            {
                "_id": 59,
                "_Comentario__descripcion": "Why would you assign a lambda to a variable, just use def instead. def f(age): is far clearer than f = lambda age:",
                "_Comentario__fecha": "2017-05-16 22:29:33Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "GP89",
                "usuario_id": null
            },
            {
                "_id": 60,
                "_Comentario__descripcion": "In some cases, you may need the age just once and then there is no use of that function. One may want to use a function and throw it away after the job is done. Also, this may not be the best way, but it definitely is a different way of doing it (which was the purpose of my solution).",
                "_Comentario__fecha": "2017-05-16 23:17:04Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "aaveg",
                "usuario_id": null
            },
            {
                "_id": 61,
                "_Comentario__descripcion": "@aaveg how would you turn this code to actually save the age provided by the user?",
                "_Comentario__fecha": "2019-07-04 20:04:31Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Tytire Recubans",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 38,
        "_Respuesta__fecha": "2020-06-20 09:12:55Z",
        "_Respuesta__descripcion": "\nFunctional approach or \"look mum no loops!\":\nfrom itertools import chain, repeat\n\nprompts = chain([\"Enter a number: \"], repeat(\"Not a number! Try again: \"))\nreplies = map(input, prompts)\nvalid_response = next(filter(str.isdigit, replies))\nprint(valid_response)\n\nEnter a number:  a\nNot a number! Try again:  b\nNot a number! Try again:  1\n1\n\nor if you want to have a \"bad input\" message separated from an input prompt as in other answers:\nprompt_msg = \"Enter a number: \"\nbad_input_msg = \"Sorry, I didn't understand that.\"\nprompts = chain([prompt_msg], repeat('\\n'.join([bad_input_msg, prompt_msg])))\nreplies = map(input, prompts)\nvalid_response = next(filter(str.isdigit, replies))\nprint(valid_response)\n\nEnter a number:  a\nSorry, I didn't understand that.\nEnter a number:  b\nSorry, I didn't understand that.\nEnter a number:  1\n1\n\nHow does it work?\n\n\nprompts = chain([\"Enter a number: \"], repeat(\"Not a number! Try again: \"))\n\nThis combination of itertools.chain and itertools.repeat will create an iterator\nwhich will yield strings \"Enter a number: \" once, and \"Not a number! Try again: \" an infinite number of times:\nfor prompt in prompts:\n    print(prompt)\n\nEnter a number: \nNot a number! Try again: \nNot a number! Try again: \nNot a number! Try again: \n# ... and so on\n\n\nreplies = map(input, prompts) - here map will apply all the prompts strings from the previous step to the input function. E.g.:\nfor reply in replies:\n    print(reply)\n\nEnter a number:  a\na\nNot a number! Try again:  1\n1\nNot a number! Try again:  it doesn't care now\nit doesn't care now\n# and so on...\n\n\nWe use filter and str.isdigit to filter out those strings that contain only digits:\nonly_digits = filter(str.isdigit, replies)\nfor reply in only_digits:\n    print(reply)\n\nEnter a number:  a\nNot a number! Try again:  1\n1\nNot a number! Try again:  2\n2\nNot a number! Try again:  b\nNot a number! Try again: # and so on...\n\nAnd to get only the first digits-only string we use next.\n\nOther validation rules:\n\nString methods: Of course you can use other string methods like str.isalpha to get only alphabetic strings, or str.isupper to get only uppercase. See docs for the full list.\n\nMembership testing:\nThere are several different ways to perform it. One of them is by using __contains__ method:\nfrom itertools import chain, repeat\n\nfruits = {'apple', 'orange', 'peach'}\nprompts = chain([\"Enter a fruit: \"], repeat(\"I don't know this one! Try again: \"))\nreplies = map(input, prompts)\nvalid_response = next(filter(fruits.__contains__, replies))\nprint(valid_response)\n\nEnter a fruit:  1\nI don't know this one! Try again:  foo\nI don't know this one! Try again:  apple\napple\n\n\nNumbers comparison:\nThere are useful comparison methods which we can use here. For example, for __lt__ (<):\nfrom itertools import chain, repeat\n\nprompts = chain([\"Enter a positive number:\"], repeat(\"I need a positive number! Try again:\"))\nreplies = map(input, prompts)\nnumeric_strings = filter(str.isnumeric, replies)\nnumbers = map(float, numeric_strings)\nis_positive = (0.).__lt__\nvalid_response = next(filter(is_positive, numbers))\nprint(valid_response)\n\nEnter a positive number: a\nI need a positive number! Try again: -5\nI need a positive number! Try again: 0\nI need a positive number! Try again: 5\n5.0\n\nOr, if you don't like using dunder methods (dunder = double-underscore), you can always define your own function, or use the ones from the operator module.\n\nPath existance:\nHere one can use pathlib library and its Path.exists method:\nfrom itertools import chain, repeat\nfrom pathlib import Path\n\nprompts = chain([\"Enter a path: \"], repeat(\"This path doesn't exist! Try again: \"))\nreplies = map(input, prompts)\npaths = map(Path, replies)\nvalid_response = next(filter(Path.exists, paths))\nprint(valid_response)\n\nEnter a path:  a b c\nThis path doesn't exist! Try again:  1\nThis path doesn't exist! Try again:  existing_file.txt\nexisting_file.txt\n\n\n\nLimiting number of tries:\nIf you don't want to torture a user by asking him something an infinite number of times, you can specify a limit in a call of itertools.repeat. This can be combined with providing a default value to the next function:\nfrom itertools import chain, repeat\n\nprompts = chain([\"Enter a number:\"], repeat(\"Not a number! Try again:\", 2))\nreplies = map(input, prompts)\nvalid_response = next(filter(str.isdigit, replies), None)\nprint(\"You've failed miserably!\" if valid_response is None else 'Well done!')\n\nEnter a number: a\nNot a number! Try again: b\nNot a number! Try again: c\nYou've failed miserably!\n\nPreprocessing input data:\nSometimes we don't want to reject an input if the user accidentally supplied it IN CAPS or with a space in the beginning or an end of the string. To take these simple mistakes into account we can preprocess the input data by applying str.lower and str.strip methods. For example, for the case of membership testing the code will look like this:\nfrom itertools import chain, repeat\n\nfruits = {'apple', 'orange', 'peach'}\nprompts = chain([\"Enter a fruit: \"], repeat(\"I don't know this one! Try again: \"))\nreplies = map(input, prompts)\nlowercased_replies = map(str.lower, replies)\nstripped_replies = map(str.strip, lowercased_replies)\nvalid_response = next(filter(fruits.__contains__, stripped_replies))\nprint(valid_response)\n\nEnter a fruit:  duck\nI don't know this one! Try again:     Orange\norange\n\nIn the case when you have many functions to use for preprocessing, it might be easier to use a function performing a function composition. For example, using the one from here:\nfrom itertools import chain, repeat\n\nfrom lz.functional import compose\n\nfruits = {'apple', 'orange', 'peach'}\nprompts = chain([\"Enter a fruit: \"], repeat(\"I don't know this one! Try again: \"))\nreplies = map(input, prompts)\nprocess = compose(str.strip, str.lower)  # you can add more functions here\nprocessed_replies = map(process, replies)\nvalid_response = next(filter(fruits.__contains__, processed_replies))\nprint(valid_response)\n\nEnter a fruit:  potato\nI don't know this one! Try again:   PEACH\npeach\n\nCombining validation rules:\nFor a simple case, for example, when the program asks for age between 1 and 120, one can just add another filter:\nfrom itertools import chain, repeat\n\nprompt_msg = \"Enter your age (1-120): \"\nbad_input_msg = \"Wrong input.\"\nprompts = chain([prompt_msg], repeat('\\n'.join([bad_input_msg, prompt_msg])))\nreplies = map(input, prompts)\nnumeric_replies = filter(str.isdigit, replies)\nages = map(int, numeric_replies)\npositive_ages = filter((0).__lt__, ages)\nnot_too_big_ages = filter((120).__ge__, positive_ages)\nvalid_response = next(not_too_big_ages)\nprint(valid_response)\n\nBut in the case when there are many rules, it's better to implement a function performing a logical conjunction. In the following example I will use a ready one from here:\nfrom functools import partial\nfrom itertools import chain, repeat\n\nfrom lz.logical import conjoin\n\n\ndef is_one_letter(string: str) -> bool:\n    return len(string) == 1\n\n\nrules = [str.isalpha, str.isupper, is_one_letter, 'C'.__le__, 'P'.__ge__]\n\nprompt_msg = \"Enter a letter (C-P): \"\nbad_input_msg = \"Wrong input.\"\nprompts = chain([prompt_msg], repeat('\\n'.join([bad_input_msg, prompt_msg])))\nreplies = map(input, prompts)\nvalid_response = next(filter(conjoin(*rules), replies))\nprint(valid_response)\n\nEnter a letter (C-P):  5\nWrong input.\nEnter a letter (C-P):  f\nWrong input.\nEnter a letter (C-P):  CDE\nWrong input.\nEnter a letter (C-P):  Q\nWrong input.\nEnter a letter (C-P):  N\nN\n\nUnfortunately, if someone needs a custom message for each failed case, then, I'm afraid, there is no pretty functional way. Or, at least, I couldn't find one.\n    ",
        "_Respuesta__votes": 23,
        "comentarios": [
            {
                "_id": 62,
                "_Comentario__descripcion": "What a thorough and wonderful answer, the explanation breakdown was great.",
                "_Comentario__fecha": "2019-09-05 16:32:10Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Locane",
                "usuario_id": null
            },
            {
                "_id": 63,
                "_Comentario__descripcion": "Using your style, how would one go about stripping whitespace and lower-casing the input for membership testing? I don't want to create a set that must include both upper and lowercase examples. I would also like to allow for whitespace input mistakes.",
                "_Comentario__fecha": "2019-09-06 03:53:35Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Austin",
                "usuario_id": null
            },
            {
                "_id": 64,
                "_Comentario__descripcion": "@Austin I added a new section on preprocessing. Take a look.",
                "_Comentario__fecha": "2019-09-06 13:19:06Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Georgy",
                "usuario_id": null
            },
            {
                "_id": 65,
                "_Comentario__descripcion": "That reminds me of ReactiveX. But perhaps that was inspired by functional languages in the first place?",
                "_Comentario__fecha": "2020-06-06 18:02:11Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mateen Ulhaq",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 39,
        "_Respuesta__fecha": "2020-06-20 09:12:55Z",
        "_Respuesta__descripcion": "\nUsing Click:\nClick is a library for command-line interfaces and it provides functionality for asking a valid response from a user.\nSimple example:\nimport click\n\nnumber = click.prompt('Please enter a number', type=float)\nprint(number)\n\nPlease enter a number: \n a\nError: a is not a valid floating point value\nPlease enter a number: \n 10\n10.0\n\nNote how it converted the string value to a float automatically.\nChecking if a value is within a range:\nThere are different custom types provided. To get a number in a specific range we can use IntRange:\nage = click.prompt(\"What's your age?\", type=click.IntRange(1, 120))\nprint(age)\n\nWhat's your age?: \n a\nError: a is not a valid integer\nWhat's your age?: \n 0\nError: 0 is not in the valid range of 1 to 120.\nWhat's your age?: \n 5\n5\n\nWe can also specify just one of the limits, min or max:\nage = click.prompt(\"What's your age?\", type=click.IntRange(min=14))\nprint(age)\n\nWhat's your age?: \n 0\nError: 0 is smaller than the minimum valid value 14.\nWhat's your age?: \n 18\n18\n\nMembership testing:\nUsing click.Choice type. By default this check is case-sensitive.\nchoices = {'apple', 'orange', 'peach'}\nchoice = click.prompt('Provide a fruit', type=click.Choice(choices, case_sensitive=False))\nprint(choice)\n\nProvide a fruit (apple, peach, orange): \n banana\nError: invalid choice: banana. (choose from apple, peach, orange)\nProvide a fruit (apple, peach, orange): \n OrAnGe\norange\n\nWorking with paths and files:\nUsing a click.Path type we can check for existing paths and also resolve them:\npath = click.prompt('Provide path', type=click.Path(exists=True, resolve_path=True))\nprint(path)\n\nProvide path: \n nonexistent\nError: Path \"nonexistent\" does not exist.\nProvide path: \n existing_folder\n'/path/to/existing_folder\n\nReading and writing files can be done by click.File:\nfile = click.prompt('In which file to write data?', type=click.File('w'))\nwith file.open():\n    file.write('Hello!')\n# More info about `lazy=True` at:\n# https://click.palletsprojects.com/en/7.x/arguments/#file-opening-safety\nfile = click.prompt('Which file you wanna read?', type=click.File(lazy=True))\nwith file.open():\n    print(file.read())\n\nIn which file to write data?: \n         # <-- provided an empty string, which is an illegal name for a file\nIn which file to write data?: \n some_file.txt\nWhich file you wanna read?: \n nonexistent.txt\nError: Could not open file: nonexistent.txt: No such file or directory\nWhich file you wanna read?: \n some_file.txt\nHello!\n\nOther examples:\nPassword confirmation:\npassword = click.prompt('Enter password', hide_input=True, confirmation_prompt=True)\nprint(password)\n\nEnter password: \n \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\nRepeat for confirmation: \n \u00b7\nError: the two entered values do not match\nEnter password: \n \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\nRepeat for confirmation: \n \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\nqwerty\n\nDefault values:\nIn this case, simply pressing Enter (or whatever key you use) without entering a value, will give you a default one:\nnumber = click.prompt('Please enter a number', type=int, default=42)\nprint(number)\n\nPlease enter a number [42]: \n a\nError: a is not a valid integer\nPlease enter a number [42]: \n \n42\n\n    ",
        "_Respuesta__votes": 16,
        "comentarios": [
            {
                "_id": 66,
                "_Comentario__descripcion": "Thanks, this is perfect. Looping with a number selection in a valid range was exactly what i was looking for.",
                "_Comentario__fecha": "2020-06-15 11:57:19Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Amir",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 40,
        "_Respuesta__fecha": "2017-05-23 12:34:45Z",
        "_Respuesta__descripcion": "\nSo, I was messing around with something similar to this recently, and I came up with the following solution, which uses a way of getting input that rejects junk, before it's even checked in any logical way.\n\nread_single_keypress() courtesy https://stackoverflow.com/a/6599441/4532996\n\ndef read_single_keypress() -> str:\n    \"\"\"Waits for a single keypress on stdin.\n    -- from :: https://stackoverflow.com/a/6599441/4532996\n    \"\"\"\n\n    import termios, fcntl, sys, os\n    fd = sys.stdin.fileno()\n    # save old state\n    flags_save = fcntl.fcntl(fd, fcntl.F_GETFL)\n    attrs_save = termios.tcgetattr(fd)\n    # make raw - the way to do this comes from the termios(3) man page.\n    attrs = list(attrs_save) # copy the stored version to update\n    # iflag\n    attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK\n                  | termios.ISTRIP | termios.INLCR | termios. IGNCR\n                  | termios.ICRNL | termios.IXON )\n    # oflag\n    attrs[1] &= ~termios.OPOST\n    # cflag\n    attrs[2] &= ~(termios.CSIZE | termios. PARENB)\n    attrs[2] |= termios.CS8\n    # lflag\n    attrs[3] &= ~(termios.ECHONL | termios.ECHO | termios.ICANON\n                  | termios.ISIG | termios.IEXTEN)\n    termios.tcsetattr(fd, termios.TCSANOW, attrs)\n    # turn off non-blocking\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags_save & ~os.O_NONBLOCK)\n    # read a single keystroke\n    try:\n        ret = sys.stdin.read(1) # returns a single character\n    except KeyboardInterrupt:\n        ret = 0\n    finally:\n        # restore old state\n        termios.tcsetattr(fd, termios.TCSAFLUSH, attrs_save)\n        fcntl.fcntl(fd, fcntl.F_SETFL, flags_save)\n    return ret\n\ndef until_not_multi(chars) -> str:\n    \"\"\"read stdin until !(chars)\"\"\"\n    import sys\n    chars = list(chars)\n    y = \"\"\n    sys.stdout.flush()\n    while True:\n        i = read_single_keypress()\n        _ = sys.stdout.write(i)\n        sys.stdout.flush()\n        if i not in chars:\n            break\n        y += i\n    return y\n\ndef _can_you_vote() -> str:\n    \"\"\"a practical example:\n    test if a user can vote based purely on keypresses\"\"\"\n    print(\"can you vote? age : \", end=\"\")\n    x = int(\"0\" + until_not_multi(\"0123456789\"))\n    if not x:\n        print(\"\\nsorry, age can only consist of digits.\")\n        return\n    print(\"your age is\", x, \"\\nYou can vote!\" if x >= 18 else \"Sorry! you can't vote\")\n\n_can_you_vote()\n\n\nYou can find the complete module here.\n\nExample:\n\n$ ./input_constrain.py\ncan you vote? age : a\nsorry, age can only consist of digits.\n$ ./input_constrain.py \ncan you vote? age : 23<RETURN>\nyour age is 23\nYou can vote!\n$ _\n\n\nNote that the nature of this implementation is it closes stdin as soon as something that isn't a digit is read. I didn't hit enter after a, but I needed to after the numbers.\n\nYou could merge this with the thismany() function in the same module to only allow, say, three digits.\n    ",
        "_Respuesta__votes": 13,
        "comentarios": [
            {
                "_id": 67,
                "_Comentario__descripcion": "If you're already detecting key strokes, why allow characters at all and throw errors around, when you can just silently ignore them, until you get the desired number?",
                "_Comentario__fecha": "2020-10-31 14:27:28Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Kebman",
                "usuario_id": null
            },
            {
                "_id": 68,
                "_Comentario__descripcion": "@Kebman you could do that but it might be less obvious to the user what they can type",
                "_Comentario__fecha": "2020-11-01 13:50:25Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "cat",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 41,
        "_Respuesta__fecha": "2020-10-30 07:12:59Z",
        "_Respuesta__descripcion": "\nYeah I'm 6 years late from the \ud83c\udf89 but this question deserves more up-to-date answer.\nSeparation of concerns\nI am a big fan of Unix philosophy \"Do one thing and do it well\". In this type of problem, it is better practice to split the problem to\n\nAsk input with get_input until the input is ok.\nValidate in validator function. You could write different validators for different input queries.\n\nAsking for input\nIt can be kept as simple as (Python 3+)\ndef myvalidator(value):\n    try:\n        value = int(value)\n    except ValueError:\n        return False\n    return value >= 0\n\ndef get_input(prompt, validator, on_validationerror):\n    while True:\n        value = input(prompt)\n        if validator(value):\n            return value\n        print(on_validationerror)\n\nExample\nIn [2]: get_input('Give a positive number: ', myvalidator, 'Please, try again')\nGive a positive number: foobar\nPlease, try again\nGive a positive number: -10\nPlease, try again\nGive a positive number: 42\nOut[2]: '42'\n\n\nPython 3.8+ Note\nIn Python 3.8+ you could use the walrus operator\ndef get_input(prompt, validator, on_validationerror):\n    while not validator(value := input(prompt)):\n        print(on_validationerror)\n    return value \n\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 42,
        "_Respuesta__fecha": "2016-06-23 10:34:14Z",
        "_Respuesta__descripcion": "\ndef validate_age(age):\n    if age >=0 :\n        return True\n    return False\n\nwhile True:\n    try:\n        age = int(raw_input(\"Please enter your age:\"))\n        if validate_age(age): break\n    except ValueError:\n        print \"Error: Invalid age.\"\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 43,
        "_Respuesta__fecha": "2018-12-01 11:17:14Z",
        "_Respuesta__descripcion": "\nBuilding upon Daniel Q's and Patrick Artner's excellent suggestions,\nhere is an even more generalized solution.\n\n# Assuming Python3\nimport sys\n\nclass ValidationError(ValueError):  # thanks Patrick Artner\n    pass\n\ndef validate_input(prompt, cast=str, cond=(lambda x: True), onerror=None):\n    if onerror==None: onerror = {}\n    while True:\n        try:\n            data = cast(input(prompt))\n            if not cond(data): raise ValidationError\n            return data\n        except tuple(onerror.keys()) as e:  # thanks Daniel Q\n            print(onerror[type(e)], file=sys.stderr)\n\n\nI opted for explicit if and raise statements instead of an assert,\nbecause assertion checking may be turned off,\nwhereas validation should always be on to provide robustness.\n\nThis may be used to get different kinds of input,\nwith different validation conditions.\nFor example:\n\n# No validation, equivalent to simple input:\nanystr = validate_input(\"Enter any string: \")\n\n# Get a string containing only letters:\nletters = validate_input(\"Enter letters: \",\n    cond=str.isalpha,\n    onerror={ValidationError: \"Only letters, please!\"})\n\n# Get a float in [0, 100]:\npercentage = validate_input(\"Percentage? \",\n    cast=float, cond=lambda x: 0.0<=x<=100.0,\n    onerror={ValidationError: \"Must be between 0 and 100!\",\n             ValueError: \"Not a number!\"})\n\n\nOr, to answer the original question:\n\nage = validate_input(\"Please enter your age: \",\n        cast=int, cond=lambda a:0<=a<150,\n        onerror={ValidationError: \"Enter a plausible age, please!\",\n                 ValueError: \"Enter an integer, please!\"})\nif age >= 18: \n    print(\"You are able to vote in the United States!\")\nelse:\n    print(\"You are not able to vote in the United States.\")\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 44,
        "_Respuesta__fecha": "2020-09-11 14:11:56Z",
        "_Respuesta__descripcion": "\nUse try-except to handle the error and repeat it again:\nwhile True:\n    try:\n        age = int(input(\"Please enter your age: \"))\n        if age >= 18:\n            print(\"You are able to vote in the United States!\")\n        else:\n            print(\"You are not able to vote in the United States.\")\n    except Exception as e:\n        print(\"please enter number\")\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [
            {
                "_id": 69,
                "_Comentario__descripcion": "You are missing a break statement, and the print(\"please enter number\") is unnecessary.",
                "_Comentario__fecha": "2020-09-11 14:13:27Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Georgy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 45,
        "_Respuesta__fecha": "2017-04-30 09:29:28Z",
        "_Respuesta__descripcion": "\nTry this one:- \n\ndef takeInput(required):\n  print 'ooo or OOO to exit'\n  ans = raw_input('Enter: ')\n\n  if not ans:\n      print \"You entered nothing...!\"\n      return takeInput(required) \n\n      ##  FOR Exit  ## \n  elif ans in ['ooo', 'OOO']:\n    print \"Closing instance.\"\n    exit()\n\n  else:\n    if ans.isdigit():\n      current = 'int'\n    elif set('[~!@#$%^&*()_+{}\":/\\']+$').intersection(ans):\n      current = 'other'\n    elif isinstance(ans,basestring):\n      current = 'str'        \n    else:\n      current = 'none'\n\n  if required == current :\n    return ans\n  else:\n    return takeInput(required)\n\n## pass the value in which type you want [str/int/special character(as other )]\nprint \"input: \", takeInput('str')\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 46,
        "_Respuesta__fecha": "2016-06-06 07:15:17Z",
        "_Respuesta__descripcion": "\nWhile a try/except block will work, a much faster and cleaner way to accomplish this task would be to use str.isdigit().\n\nwhile True:\n    age = input(\"Please enter your age: \")\n    if age.isdigit():\n        age = int(age)\n        break\n    else:\n        print(\"Invalid number '{age}'. Try again.\".format(age=age))\n\nif age >= 18: \n    print(\"You are able to vote in the United States!\")\nelse:\n    print(\"You are not able to vote in the United States.\")\n\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 47,
        "_Respuesta__fecha": "2018-12-18 06:54:35Z",
        "_Respuesta__descripcion": "\nGood question! You can try the following code for this. =)\n\nThis code uses ast.literal_eval() to find the data type of the input (age). Then it follows the following algorithm:\n\n\n  \n  Ask user to input her/his age.\n  \n  1.1. If age is float or int data type:\n  \n  \n  Check if age>=18. If age>=18, print appropriate output and exit.\n  Check if 0<age<18. If 0<age<18, print appropriate output and exit.\n  If age<=0, ask the user to input a valid number for age again, (i.e. go back to step 1.) \n  \n  \n  1.2. If age is not float or int data type, then ask user to input her/his age again (i.e. go back to step 1.) \n  \n\n\nHere is the code.\n\nfrom ast import literal_eval\n\n''' This function is used to identify the data type of input data.'''\ndef input_type(input_data):\n    try:\n        return type(literal_eval(input_data))\n    except (ValueError, SyntaxError):\n        return str\n\nflag = True\n\nwhile(flag):\n    age = raw_input(\"Please enter your age: \")\n\n    if input_type(age)==float or input_type(age)==int:\n        if eval(age)>=18: \n            print(\"You are able to vote in the United States!\") \n            flag = False \n        elif eval(age)>0 and eval(age)<18: \n            print(\"You are not able to vote in the United States.\") \n            flag = False\n        else: print(\"Please enter a valid number as your age.\")\n\n    else: print(\"Sorry, I didn't understand that.\") \n\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 48,
        "_Respuesta__fecha": "2019-07-01 14:17:43Z",
        "_Respuesta__descripcion": "\nYou can always apply simple if-else logic and add one more if logic to your code along with a for loop.\n\nwhile True:\n     age = int(input(\"Please enter your age: \"))\n     if (age >= 18)  : \n         print(\"You are able to vote in the United States!\")\n     if (age < 18) & (age > 0):\n         print(\"You are not able to vote in the United States.\")\n     else:\n         print(\"Wrong characters, the input must be numeric\")\n         continue\n\n\nThis will be an infinite loo and you would be asked to enter the age, indefinitely.\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [
            {
                "_id": 70,
                "_Comentario__descripcion": "This doesn't really answer the question. The question was about getting a user input until they give a valid response, not indefinitely.",
                "_Comentario__fecha": "2019-07-01 10:25:41Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Georgy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 49,
        "_Respuesta__fecha": "2020-08-17 17:21:22Z",
        "_Respuesta__descripcion": "\nBelow code may help.\nage=(lambda i,f: f(i,f))(input(\"Please enter your age: \"),lambda i,f: i if i.isdigit() else f(input(\"Please enter your age: \"),f))\nprint(\"You are able to vote in the united states\" if int(age)>=18 else \"You are not able to vote in the united states\",end='')\n\nIf you want to have maximum tries, say 3, use below code\nage=(lambda i,n,f: f(i,n,f))(input(\"Please enter your age: \"),1,lambda i,n,f: i if i.isdigit() else (None if n==3 else f(input(\"Please enter your age: \"),n+1,f)))\nprint(\"You are able to vote in the united states\" if age and int(age)>=18 else \"You are not able to vote in the united states\",end='')\n\nNote: This uses recursion.\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 50,
        "_Respuesta__fecha": "2016-11-03 07:49:29Z",
        "_Respuesta__descripcion": "\nYou can write more general logic to allow user to enter only specific number of times, as the same use-case arises in many real-world applications.\n\ndef getValidInt(iMaxAttemps = None):\n  iCount = 0\n  while True:\n    # exit when maximum attempt limit has expired\n    if iCount != None and iCount > iMaxAttemps:\n       return 0     # return as default value\n\n    i = raw_input(\"Enter no\")\n    try:\n       i = int(i)\n    except ValueError as e:\n       print \"Enter valid int value\"\n    else:\n       break\n\n    return i\n\nage = getValidInt()\n# do whatever you want to do.\n\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [
            {
                "_id": 71,
                "_Comentario__descripcion": "you forget to increase the iCount value after each loop",
                "_Comentario__fecha": "2017-03-01 08:49:03Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Hoai-Thu Vuong",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 51,
        "_Respuesta__fecha": "2018-01-03 00:59:37Z",
        "_Respuesta__descripcion": "\nYou can make the input statement a while True loop so it repeatedly asks for the users input and then break that loop if the user enters the response you would like. And you can use try and except blocks to handle invalid responses.\n\nwhile True:\n\n    var = True\n\n    try:\n        age = int(input(\"Please enter your age: \"))\n\n    except ValueError:\n        print(\"Invalid input.\")\n        var = False\n\n    if var == True:\n        if age >= 18:\n                print(\"You are able to vote in the United States.\")\n                break\n        else:\n            print(\"You are not able to vote in the United States.\")\n\n\nThe var variable is just so that if the user enters a string instead of a integer the program wont return \"You are not able to vote in the United States.\"\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 52,
        "_Respuesta__fecha": "2018-07-07 09:28:33Z",
        "_Respuesta__descripcion": "\nUse \"while\" statement till user enter a true value and if the input value is not a number or it's a null value skip it and try to ask again and so on. \nIn example I tried to answer truly your question. If we suppose that our age is between 1 and 150 then input value accepted, else it's a wrong value.\nFor terminating program, the user can use 0 key and enter it as a value.\n\n\n  Note: Read comments top of code.\n\n\n# If your input value is only a number then use \"Value.isdigit() == False\".\n# If you need an input that is a text, you should remove \"Value.isdigit() == False\".\ndef Input(Message):\n    Value = None\n    while Value == None or Value.isdigit() == False:\n        try:        \n            Value = str(input(Message)).strip()\n        except InputError:\n            Value = None\n    return Value\n\n# Example:\nage = 0\n# If we suppose that our age is between 1 and 150 then input value accepted,\n# else it's a wrong value.\nwhile age <=0 or age >150:\n    age = int(Input(\"Please enter your age: \"))\n    # For terminating program, the user can use 0 key and enter it as an a value.\n    if age == 0:\n        print(\"Terminating ...\")\n        exit(0)\n\nif age >= 18 and age <=150: \n    print(\"You are able to vote in the United States!\")\nelse:\n    print(\"You are not able to vote in the United States.\")\n\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 53,
        "_Respuesta__fecha": "2018-11-08 12:04:20Z",
        "_Respuesta__descripcion": "\nOne more solution for using input validation using a customized ValidationError and a (optional) range validation for integer inputs:\n\nclass ValidationError(ValueError): \n    \"\"\"Special validation error - its message is supposed to be printed\"\"\"\n    pass\n\ndef RangeValidator(text,num,r):\n    \"\"\"Generic validator - raises 'text' as ValidationError if 'num' not in range 'r'.\"\"\"\n    if num in r:\n        return num\n    raise ValidationError(text)\n\ndef ValidCol(c): \n    \"\"\"Specialized column validator providing text and range.\"\"\"\n    return RangeValidator(\"Columns must be in the range of 0 to 3 (inclusive)\", \n                          c, range(4))\n\ndef ValidRow(r): \n    \"\"\"Specialized row validator providing text and range.\"\"\"\n    return RangeValidator(\"Rows must be in the range of 5 to 15(exclusive)\",\n                          r, range(5,15))\n\n\nUsage:\n\ndef GetInt(text, validator=None):\n    \"\"\"Aks user for integer input until a valid integer is given. If provided, \n    a 'validator' function takes the integer and either raises a \n    ValidationError to be printed or returns the valid number. \n    Non integers display a simple error message.\"\"\"\n    print()\n    while True:\n        n = input(text)\n        try:\n            n = int(n)\n\n            return n if validator is None else validator(n)\n\n        except ValueError as ve:\n            # prints ValidationErrors directly - else generic message:\n            if isinstance(ve, ValidationError):\n                print(ve)\n            else:\n                print(\"Invalid input: \", n)\n\n\ncolumn = GetInt(\"Pleased enter column: \", ValidCol)\nrow = GetInt(\"Pleased enter row: \", ValidRow)\nprint( row, column)\n\n\nOutput:\n\nPleased enter column: 22\nColumns must be in the range of 0 to 3 (inclusive)\nPleased enter column: -2\nColumns must be in the range of 0 to 3 (inclusive)\nPleased enter column: 2\nPleased enter row: a\nInvalid input:  a\nPleased enter row: 72\nRows must be in the range of 5 to 15(exclusive)\nPleased enter row: 9  \n\n9, 2\n\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 54,
        "_Respuesta__fecha": "2019-04-15 13:56:05Z",
        "_Respuesta__descripcion": "\nPersistent user input using recursive function:\n\nString\n\ndef askName():\n    return input(\"Write your name: \").strip() or askName()\n\nname = askName()\n\n\nInteger\n\ndef askAge():\n    try: return int(input(\"Enter your age: \"))\n    except ValueError: return askAge()\n\nage = askAge()\n\n\nand finally, the question requirement:\n\ndef askAge():\n    try: return int(input(\"Enter your age: \"))\n    except ValueError: return askAge()\n\nage = askAge()\n\nresponseAge = [\n    \"You are able to vote in the United States!\",\n    \"You are not able to vote in the United States.\",\n][int(age < 18)]\n\nprint(responseAge)\n\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 55,
        "_Respuesta__fecha": "2021-06-30 00:03:48Z",
        "_Respuesta__descripcion": "\nUse isdigit() to check if a string represents a valid integer.\nYou could use a recursive function.\ndef ask():\n    answer = input(\"Please enter amount to convert: \")\n    if not answer.isdigit():\n        print(\"Invalid\")\n        return ask()\n\n    return int(answer)\n\nGdp = ask()\n\nOr a while loop\nwhile True:\n    answer = input(\"Please enter amount to convert: \")\n    if not answer.isdigit():\n        print(\"Invalid\")\n        continue\n\n    Gbp = int(answer)\n\n    ",
        "_Respuesta__votes": -1,
        "comentarios": [
            {
                "_id": 72,
                "_Comentario__descripcion": "You're missing a return from the function. You return the recursive call, but that call returns None... And you while loop is infinite...",
                "_Comentario__fecha": "2021-05-04 19:16:01Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Tomerikoo",
                "usuario_id": null
            },
            {
                "_id": 73,
                "_Comentario__descripcion": "@Tomerikoo It recursively asks until the answer is valid, which I think is what was asked. I meant to write it in a way where you can put any code inside the recursive function or while loop. This was actually written for a different question, which got marked as a duplicate to this one so I posted it here instead.",
                "_Comentario__fecha": "2021-05-05 16:15:49Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Rein F",
                "usuario_id": null
            },
            {
                "_id": 74,
                "_Comentario__descripcion": "What I mean is that you should test your code with some scenarios. In the first case, the Gbp = int(answer) should probably be return int(answer) and in the second there should probably be a break somewhere",
                "_Comentario__fecha": "2021-05-05 16:55:40Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Tomerikoo",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 56,
        "_Respuesta__fecha": "2019-12-24 03:33:56Z",
        "_Respuesta__descripcion": "\nThe simple solution would be:\n\nwhile True:\n    age = int(input(\"Please enter your age: \"))\n\n    if (age<=0) or (age>120):\n        print('Sorry, I did not understand that.Please try again')\n        continue\n    else:\n\n        if age>=18:\n            print(\"You are able to vote in the United States!\")\n        else:\n            print(\"You are not able to vote in the United States.\")\n        break\n\n\nExplanation of above code:\nIn order for a valid age,it should be positive and should not be more than normal physical age,say for example maximum age is 120.\n\nThen we can ask user for age and if age input is negative or more than 120,we consider it invalid input and ask the user to try again.\n\nOnce the valid input is entered, we perform a check (using nested if-else statement) whether the age is >=18 or vice versa and print a message whether the user is eligible to vote\n    ",
        "_Respuesta__votes": -2,
        "comentarios": [
            {
                "_id": 75,
                "_Comentario__descripcion": "\"Please enter your age: dickety six\"': same crash as stated in the question...",
                "_Comentario__fecha": "2020-05-16 22:28:35Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "BDL",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 58,
        "_Respuesta__fecha": "2020-06-12 16:56:19Z",
        "_Respuesta__descripcion": "\nYou can use dictionaries to accomplish this. Dictionaries are stores of keys and values. \n\n>>> dct = {'x': 1, 'y': 2, 'z': 3}\n>>> dct\n{'y': 2, 'x': 1, 'z': 3}\n>>> dct[\"y\"]\n2\n\n\nYou can use variable key names to achieve the effect of variable variables without the security risk.\n\n>>> x = \"spam\"\n>>> z = {x: \"eggs\"}\n>>> z[\"spam\"]\n'eggs'\n\n\nFor cases where you're thinking of doing something like\n\nvar1 = 'foo'\nvar2 = 'bar'\nvar3 = 'baz'\n...\n\n\na list may be more appropriate than a dict. A list represents an ordered sequence of objects, with integer indices:\n\nlst = ['foo', 'bar', 'baz']\nprint(lst[1])           # prints bar, because indices start at 0\nlst.append('potatoes')  # lst is now ['foo', 'bar', 'baz', 'potatoes']\n\n\nFor ordered sequences, lists are more convenient than dicts with integer keys, because lists support iteration in index order, slicing, append, and other operations that would require awkward key management with a dict.\n    ",
        "_Respuesta__votes": 365,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 59,
        "_Respuesta__fecha": "2016-04-21 15:23:52Z",
        "_Respuesta__descripcion": "\nUse the built-in getattr function to get an attribute on an object by name.  Modify the name as needed.\n\nobj.spam = 'eggs'\nname = 'spam'\ngetattr(obj, name)  # returns 'eggs'\n\n    ",
        "_Respuesta__votes": 104,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 60,
        "_Respuesta__fecha": "2017-04-24 02:03:14Z",
        "_Respuesta__descripcion": "\nIt's not a good idea. If you are accessing a global variable you can use globals().\n\n>>> a = 10\n>>> globals()['a']\n10\n\n\nIf you want to access a variable in the local scope you can use locals(), but you cannot assign values to the returned dict.\n\nA better solution is to use getattr or store your variables in a dictionary and then access them by name.\n    ",
        "_Respuesta__votes": 80,
        "comentarios": [
            {
                "_id": 77,
                "_Comentario__descripcion": "locals().update({'new_local_var':'some local value'}) works just fine for me in Python 3.7.6; so I'm not sure what you mean when you say you cannot assign values through it.",
                "_Comentario__fecha": "2020-03-19 09:04:55Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Jim Dennis",
                "usuario_id": null
            },
            {
                "_id": 78,
                "_Comentario__descripcion": "Given x = \"foo\" and locals()[\"x\"] = \"bar\" using print x gives the output bar for Jython 2.5.2. This was tested with an On Demand Automation Script in maximo.",
                "_Comentario__fecha": "2020-03-30 22:52:39Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Preacher",
                "usuario_id": null
            },
            {
                "_id": 79,
                "_Comentario__descripcion": "The documentation of locals() specifically says: \"The contents of this dictionary should not be modified.\" (emphasis mine)",
                "_Comentario__fecha": "2021-06-23 21:14:16Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "martineau",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 61,
        "_Respuesta__fecha": "2016-08-16 10:41:07Z",
        "_Respuesta__descripcion": "\nNew coders sometimes write code like this:\n\nmy_calculator.button_0 = tkinter.Button(root, text=0)\nmy_calculator.button_1 = tkinter.Button(root, text=1)\nmy_calculator.button_2 = tkinter.Button(root, text=2)\n...\n\n\nThe coder is then left with a pile of named variables, with a coding effort of O(m * n), where m is the number of named variables and n is the number of times that group of variables needs to be accessed (including creation). The more astute beginner observes that the only difference in each of those lines is a number that changes based on a rule, and decides to use a loop. However, they get stuck on how to dynamically create those variable names, and may try something like this:\n\nfor i in range(10):\n    my_calculator.('button_%d' % i) = tkinter.Button(root, text=i)\n\n\nThey soon find that this does not work.\n\nIf the program requires arbitrary variable \"names,\" a dictionary is the best choice, as explained in other answers. However, if you're simply trying to create many variables and you don't mind referring to them with a sequence of integers, you're probably looking for a list. This is particularly true if your data are homogeneous, such as daily temperature readings, weekly quiz scores, or a grid of graphical widgets.\n\nThis can be assembled as follows:\n\nmy_calculator.buttons = []\nfor i in range(10):\n    my_calculator.buttons.append(tkinter.Button(root, text=i))\n\n\nThis list can also be created in one line with a comprehension:\n\nmy_calculator.buttons = [tkinter.Button(root, text=i) for i in range(10)]\n\n\nThe result in either case is a populated list, with the first element accessed with my_calculator.buttons[0], the next with my_calculator.buttons[1], and so on. The \"base\" variable name becomes the name of the list and the varying identifier is used to access it.\n\nFinally, don't forget other data structures, such as the set - this is similar to a dictionary, except that each \"name\" doesn't have a value attached to it. If you simply need a \"bag\" of objects, this can be a great choice. Instead of something like this:\n\nkeyword_1 = 'apple'\nkeyword_2 = 'banana'\n\nif query == keyword_1 or query == keyword_2:\n    print('Match.')\n\n\nYou will have this:\n\nkeywords = {'apple', 'banana'}\nif query in keywords:\n    print('Match.')\n\n\nUse a list for a sequence of similar objects, a set for an arbitrarily-ordered bag of objects, or a dict for a bag of names with associated values.\n    ",
        "_Respuesta__votes": 54,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 62,
        "_Respuesta__fecha": "2009-09-03 12:42:00Z",
        "_Respuesta__descripcion": "\nWhenever you want to use variable variables, it's probably better to use a dictionary. So instead of writing\n\n$foo = \"bar\"\n$$foo = \"baz\"\n\n\nyou write \n\nmydict = {}\nfoo = \"bar\"\nmydict[foo] = \"baz\"\n\n\nThis way you won't accidentally overwrite previously existing variables (which is the security aspect) and you can have different \"namespaces\".\n    ",
        "_Respuesta__votes": 42,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 63,
        "_Respuesta__fecha": "2018-11-27 15:34:22Z",
        "_Respuesta__descripcion": "\nUse globals()\n\nYou can actually assign variables to global scope dynamically, for instance, if you want 10 variables that can be accessed on a global scope i_1, i_2 ... i_10:\n\nfor i in range(10):\n    globals()['i_{}'.format(i)] = 'a'\n\n\nThis will assign 'a' to all of these 10 variables, of course you can change the value dynamically as well. All of these variables can be accessed now like other globally declared variable:\n\n>>> i_5\n'a'\n\n    ",
        "_Respuesta__votes": 18,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 64,
        "_Respuesta__fecha": "2019-05-13 14:39:12Z",
        "_Respuesta__descripcion": "\nInstead of a dictionary you can also use namedtuple from the collections module, which makes access easier.\n\nFor example:\n\n# using dictionary\nvariables = {}\nvariables[\"first\"] = 34\nvariables[\"second\"] = 45\nprint(variables[\"first\"], variables[\"second\"])\n\n# using namedtuple\nVariables = namedtuple('Variables', ['first', 'second'])\nvars = Variables(34, 45)\nprint(vars.first, vars.second)\n\n    ",
        "_Respuesta__votes": 14,
        "comentarios": [
            {
                "_id": 80,
                "_Comentario__descripcion": "Keep in mind namedtuples are immutable so they're a bit different than simply dicts with dot notation. Having said that, both options promote good design principles and don't abuse the global namespace like half the answers in this thread do.",
                "_Comentario__fecha": "2020-10-17 02:23:49Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ggorlen",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 65,
        "_Respuesta__fecha": "2019-05-24 13:22:33Z",
        "_Respuesta__descripcion": "\nThe SimpleNamespace class could be used to create new attributes with setattr, or subclass SimpleNamespace and create your own function to add new attribute names (variables). \n\nfrom types import SimpleNamespace\n\nvariables = {\"b\":\"B\",\"c\":\"C\"}\na = SimpleNamespace(**variables)\nsetattr(a,\"g\",\"G\")\na.g = \"G+\"\nsomething = a.a\n\n    ",
        "_Respuesta__votes": 12,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 66,
        "_Respuesta__fecha": "2017-10-23 19:24:10Z",
        "_Respuesta__descripcion": "\nIf you don't want to use any object, you can still use setattr() inside your current module:\n\nimport sys\ncurrent_module = module = sys.modules[__name__]  # i.e the \"file\" where your code is written\nsetattr(current_module, 'variable_name', 15)  # 15 is the value you assign to the var\nprint(variable_name)  # >>> 15, created from a string\n\n    ",
        "_Respuesta__votes": 11,
        "comentarios": [
            {
                "_id": 81,
                "_Comentario__descripcion": "This does not work with __dict__ variable however. I wonder if there is a general mechanism to create any global variable dynamically.",
                "_Comentario__fecha": "2018-01-30 18:25:02Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Alexey",
                "usuario_id": null
            },
            {
                "_id": 82,
                "_Comentario__descripcion": "globals() can do this",
                "_Comentario__fecha": "2018-01-31 07:42:21Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Guillaume Lebreton",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 67,
        "_Respuesta__fecha": "2020-10-17 07:06:59Z",
        "_Respuesta__descripcion": "\nYou have to use globals() built in method  to achieve that behaviour:\ndef var_of_var(k, v):\n    globals()[k] = v\n\nprint variable_name # NameError: name 'variable_name' is not defined\nsome_name = 'variable_name'\nglobals()[some_name] = 123\nprint(variable_name) # 123\n\nsome_name = 'variable_name2'\nvar_of_var(some_name, 456)\nprint(variable_name2) # 456\n\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 68,
        "_Respuesta__fecha": "2017-05-23 12:10:47Z",
        "_Respuesta__descripcion": "\nI'm am answering the question: How to get the value of a variable given its name in a string?\nwhich is closed as a duplicate with a link to this question. \n\nIf the variables in question are part of an object (part of a class for example) then some useful functions to achieve exactly that are hasattr, getattr, and setattr. \n\nSo for example you can have:\n\nclass Variables(object):\n    def __init__(self):\n        self.foo = \"initial_variable\"\n    def create_new_var(self,name,value):\n        setattr(self,name,value)\n    def get_var(self,name):\n        if hasattr(self,name):\n            return getattr(self,name)\n        else:\n            raise(\"Class does not have a variable named: \"+name)\n\n\nThen you can do:\n\nv = Variables()\nv.get_var(\"foo\")\n\n\n\n  \"initial_variable\"\n\n\nv.create_new_var(v.foo,\"is actually not initial\")\nv.initial_variable\n\n\n\n  \"is actually not initial\"\n\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 69,
        "_Respuesta__fecha": "2019-12-14 09:39:02Z",
        "_Respuesta__descripcion": "\nI have tried both in python 3.7.3, you can use either globals() or vars()\n\n>>> food #Error\n>>> milkshake #Error\n>>> food=\"bread\"\n>>> drink=\"milkshake\"\n>>> globals()[food] = \"strawberry flavor\"\n>>> vars()[drink] = \"chocolate flavor\"\n>>> bread\n'strawberry flavor'\n>>> milkshake\n'chocolate flavor'\n>>> globals()[drink]\n'chocolate flavor'\n>>> vars()[food]\n'strawberry flavor'\n\n\n\n\nReference:\nhttps://www.daniweb.com/programming/software-development/threads/111526/setting-a-string-as-a-variable-name#post548936\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 70,
        "_Respuesta__fecha": "2016-06-09 12:10:59Z",
        "_Respuesta__descripcion": "\nThe consensus is to use a dictionary for this - see the other answers. This is a good idea for most cases, however, there are many aspects arising from this:\n\n\nyou'll yourself be responsible for this dictionary, including garbage collection (of in-dict variables) etc.\nthere's either no locality or globality for variable variables, it depends on the globality of the dictionary\nif you want to rename a variable name, you'll have to do it manually\nhowever, you are much more flexible, e.g. \n\n\nyou can decide to overwrite existing variables or  ...\n... choose to implement const variables\nto raise an exception on overwriting for different types\netc.\n\n\n\nThat said, I've implemented a variable variables manager-class which provides some of the above ideas. It works for python 2 and 3.\n\nYou'd use the class like this:\n\nfrom variableVariablesManager import VariableVariablesManager\n\nmyVars = VariableVariablesManager()\nmyVars['test'] = 25\nprint(myVars['test'])\n\n# define a const variable\nmyVars.defineConstVariable('myconst', 13)\ntry:\n    myVars['myconst'] = 14 # <- this raises an error, since 'myconst' must not be changed\n    print(\"not allowed\")\nexcept AttributeError as e:\n    pass\n\n# rename a variable\nmyVars.renameVariable('myconst', 'myconstOther')\n\n# preserve locality\ndef testLocalVar():\n    myVars = VariableVariablesManager()\n    myVars['test'] = 13\n    print(\"inside function myVars['test']:\", myVars['test'])\ntestLocalVar()\nprint(\"outside function myVars['test']:\", myVars['test'])\n\n# define a global variable\nmyVars.defineGlobalVariable('globalVar', 12)\ndef testGlobalVar():\n    myVars = VariableVariablesManager()\n    print(\"inside function myVars['globalVar']:\", myVars['globalVar'])\n    myVars['globalVar'] = 13\n    print(\"inside function myVars['globalVar'] (having been changed):\", myVars['globalVar'])\ntestGlobalVar()\nprint(\"outside function myVars['globalVar']:\", myVars['globalVar'])\n\n\nIf you wish to allow overwriting of variables with the same type only:\n\nmyVars = VariableVariablesManager(enforceSameTypeOnOverride = True)\nmyVars['test'] = 25\nmyVars['test'] = \"Cat\" # <- raises Exception (different type on overwriting)\n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 71,
        "_Respuesta__fecha": "2021-03-09 16:18:44Z",
        "_Respuesta__descripcion": "\n# Python 3.8.2 (default, Feb 26 2020, 02:56:10)\n\nVariable variables in Python\n\"\"\"\n<?php\n$a = 'hello';\n$e = 'wow'\n?>\n<?php\n$$a = 'world';\n?>\n<?php\necho \"$a ${$a}\\n\";\necho \"$a ${$a[1]}\\n\";\n?>\n<?php\necho \"$a $hello\";\n?>\n\"\"\"\n\na = 'hello'  #<?php $a = 'hello'; ?>\ne = 'wow'   #<?php $e = 'wow'; ?>\nvars()[a] = 'world' #<?php $$a = 'world'; ?>\nprint(a, vars()[a]) #<?php echo \"$a ${$a}\\n\"; ?>\nprint(a, vars()[vars()['a'][1]]) #<?php echo \"$a ${$a[1]}\\n\"; ?>\nprint(a, hello) #<?php echo \"$a $hello\"; ?>\n\nOutput:\nhello world\nhello wow\nhello world\n\n\nUsing globals(), locals(), or vars() will produce the same results\n# Python 3.8.2 (default, Feb 26 2020, 02:56:10)\n\n#<?php $a = 'hello'; ?>\n#<?php $e = 'wow'; ?>\n#<?php $$a = 'world'; ?>\n#<?php echo \"$a ${$a}\\n\"; ?>\n#<?php echo \"$a ${$a[1]}\\n\"; ?>\n#<?php echo \"$a $hello\"; ?>\n\nprint('locals():\\n')\na = 'hello'\ne = 'wow'\nlocals()[a] = 'world'\nprint(a, locals()[a])\nprint(a, locals()[locals()['a'][1]])\nprint(a, hello)\n\nprint('\\n\\nglobals():\\n')\na = 'hello'\ne = 'wow'\nglobals()[a] = 'world'\nprint(a, globals()[a])\nprint(a, globals()[globals()['a'][1]])\nprint(a, hello)\n\nOutput:\nlocals():\n\nhello world\nhello wow\nhello world\n\n\nglobals():\n\nhello world\nhello wow\nhello world\n\n\nBonus (creating variables from strings)\n# Python 2.7.16 (default, Jul 13 2019, 16:01:51)\n# [GCC 8.3.0] on linux2\n\nCreating variables and unpacking tuple:\ng = globals()\nlistB = []\nfor i in range(10):\n    g[\"num%s\" % i] = i ** 10\n    listB.append(\"num{0}\".format(i))\n\ndef printNum():\n    print \"Printing num0 to num9:\"\n    for i in range(10):\n        print \"num%s = \" % i, \n        print g[\"num%s\" % i]\n\nprintNum()\n\nlistA = []\nfor i in range(10):\n    listA.append(i)\n\nlistA = tuple(listA)\nprint listA, '\"Tuple to unpack\"'\n\nlistB = str(str(listB).strip(\"[]\").replace(\"'\", \"\") + \" = listA\")\n\nprint listB\n\nexec listB\n\nprintNum()\n\nOutput:\nPrinting num0 to num9:\nnum0 =  0\nnum1 =  1\nnum2 =  1024\nnum3 =  59049\nnum4 =  1048576\nnum5 =  9765625\nnum6 =  60466176\nnum7 =  282475249\nnum8 =  1073741824\nnum9 =  3486784401\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) \"Tuple to unpack\"\nnum0, num1, num2, num3, num4, num5, num6, num7, num8, num9 = listA\nPrinting num0 to num9:\nnum0 =  0\nnum1 =  1\nnum2 =  2\nnum3 =  3\nnum4 =  4\nnum5 =  5\nnum6 =  6\nnum7 =  7\nnum8 =  8\nnum9 =  9\n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 72,
        "_Respuesta__fecha": "2021-01-30 01:15:36Z",
        "_Respuesta__descripcion": "\nIt should be extremely risky...\nbut you can use exec():\na = 'b=5'\nexec(a)\nc = b*2\nprint (c)\n\nResult:\n10\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 73,
        "_Respuesta__fecha": "2017-08-11 21:13:57Z",
        "_Respuesta__descripcion": "\nAny set of variables can also be wrapped up in a class. \n\"Variable\" variables may be added to the class instance during runtime by directly accessing the built-in dictionary through __dict__ attribute. \n\nThe following code defines Variables class, which adds variables (in this case attributes) to its instance during the construction. Variable names are taken from a specified list (which, for example, could have been generated by program code):\n\n# some list of variable names\nL = ['a', 'b', 'c']\n\nclass Variables:\n    def __init__(self, L):\n        for item in L:\n            self.__dict__[item] = 100\n\nv = Variables(L)\nprint(v.a, v.b, v.c)\n#will produce 100 100 100\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 75,
        "_Respuesta__fecha": "2020-02-24 19:27:21Z",
        "_Respuesta__descripcion": "\nIt's pretty simple really:\n\na[start:stop]  # items start through stop-1\na[start:]      # items start through the rest of the array\na[:stop]       # items from the beginning through stop-1\na[:]           # a copy of the whole array\n\n\nThere is also the step value, which can be used with any of the above:\n\na[start:stop:step] # start through not past stop, by step\n\n\nThe key point to remember is that the :stop value represents the first value that is not in the selected slice. So, the difference between stop and start is the number of elements selected (if step is 1, the default).\n\nThe other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So:\n\na[-1]    # last item in the array\na[-2:]   # last two items in the array\na[:-2]   # everything except the last two items\n\n\nSimilarly, step may be a negative number:\n\na[::-1]    # all items in the array, reversed\na[1::-1]   # the first two items, reversed\na[:-3:-1]  # the last two items, reversed\na[-3::-1]  # everything except the last two items, reversed\n\n\nPython is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.\n\nRelation to slice() object\n\nThe slicing operator [] is actually being used in the above code with a slice() object using the : notation (which is only valid within []), i.e.:\n\na[start:stop:step]\n\n\nis equivalent to:\n\na[slice(start, stop, step)]\n\n\nSlice objects also behave slightly differently depending on the number of arguments, similarly to range(), i.e. both slice(stop) and slice(start, stop[, step]) are supported.\nTo skip specifying a given argument, one might use None, so that e.g. a[start:] is equivalent to a[slice(start, None)] or a[::-1] is equivalent to a[slice(None, None, -1)].\n\nWhile the :-based notation is very helpful for simple slicing, the explicit use of slice() objects simplifies the programmatic generation of slicing.\n    ",
        "_Respuesta__votes": 5549,
        "comentarios": [
            {
                "_id": 93,
                "_Comentario__descripcion": "Slicing builtin types returns a copy but that's not universal.  Notably, slicing NumPy arrays returns a view that shares memory with the original.",
                "_Comentario__fecha": "2013-09-23 00:13:06Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Beni Cherniavsky-Paskin",
                "usuario_id": null
            },
            {
                "_id": 94,
                "_Comentario__descripcion": "This is a beautiful answer with the votes to prove it, but it misses one thing: you can substitute None for any of the empty spaces. For example [None:None] makes a whole copy. This is useful when you need to specify the end of the range using a variable and need to include the last item.",
                "_Comentario__fecha": "2019-01-16 18:49:18Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            },
            {
                "_id": 95,
                "_Comentario__descripcion": "Note that contrary to usual Python slices (see above), in Pandas Dataframes both the start and the stop are included when present in the index. For further info see the Pandas indexing documentation.",
                "_Comentario__fecha": "2019-05-29 12:54:33Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "vreyespue",
                "usuario_id": null
            },
            {
                "_id": 96,
                "_Comentario__descripcion": "What really annoys me is that python says that when you don't set the start and the end, they default to 0 and the length of sequence. So, in theory, when you use \"abcdef\"[::-1] it should be transformed to \"abcdef\"[0:6:-1], but these two expressions does not get the same output. I feel that something is missing in python documentation since the creation of the language.",
                "_Comentario__fecha": "2019-06-30 14:00:10Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "axell-brendow",
                "usuario_id": null
            },
            {
                "_id": 97,
                "_Comentario__descripcion": "And I know that \"abcdef\"[::-1] is transformed to \"abcdef\"[6:-7:-1], so, the best way to explain would be: let len be the length of the sequence. If step is positive, the defaults for start and end are 0 and len. Else if step is negative, the defaults for start and end are len and -len - 1.",
                "_Comentario__fecha": "2019-06-30 14:22:35Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "axell-brendow",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 76,
        "_Respuesta__fecha": "2017-09-18 11:02:56Z",
        "_Respuesta__descripcion": "\nThe Python tutorial talks about it (scroll down a bit until you get to the part about slicing).\n\nThe ASCII art diagram is helpful too for remembering how slices work:\n\n +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n 0   1   2   3   4   5   6\n-6  -5  -4  -3  -2  -1\n\n\n\n  One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n.\n\n    ",
        "_Respuesta__votes": 610,
        "comentarios": [
            {
                "_id": 98,
                "_Comentario__descripcion": "This suggestion works for positive stride, but does not for a negative stride. From the diagram, I expect a[-4,-6,-1] to be yP but it is ty. What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.",
                "_Comentario__fecha": "2019-05-27 20:05:24Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "aguadopd",
                "usuario_id": null
            },
            {
                "_id": 99,
                "_Comentario__descripcion": "But there's no way to collapse to an empty set starting from the end (like x[:0] does when starting from the beginning), so you have to special-case small arrays.  :/",
                "_Comentario__fecha": "2019-07-06 20:07:48Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "endolith",
                "usuario_id": null
            },
            {
                "_id": 100,
                "_Comentario__descripcion": "@aguadopd You are absolutely right. The solution is to have the indices shifted to the right, centered just below the characters, and notice that the stop is always excluded. See another response just below.",
                "_Comentario__fecha": "2021-04-05 21:32:00Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Javier Ruiz",
                "usuario_id": null
            },
            {
                "_id": 101,
                "_Comentario__descripcion": "Addendum to my comment: see my answer with diagrams below: stackoverflow.com/a/56332104/2343869",
                "_Comentario__fecha": "2021-04-15 01:04:50Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "aguadopd",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 77,
        "_Respuesta__fecha": "2019-05-07 12:16:22Z",
        "_Respuesta__descripcion": "\nEnumerating the possibilities allowed by the grammar:\n\n>>> seq[:]                # [seq[0],   seq[1],          ..., seq[-1]    ]\n>>> seq[low:]             # [seq[low], seq[low+1],      ..., seq[-1]    ]\n>>> seq[:high]            # [seq[0],   seq[1],          ..., seq[high-1]]\n>>> seq[low:high]         # [seq[low], seq[low+1],      ..., seq[high-1]]\n>>> seq[::stride]         # [seq[0],   seq[stride],     ..., seq[-1]    ]\n>>> seq[low::stride]      # [seq[low], seq[low+stride], ..., seq[-1]    ]\n>>> seq[:high:stride]     # [seq[0],   seq[stride],     ..., seq[high-1]]\n>>> seq[low:high:stride]  # [seq[low], seq[low+stride], ..., seq[high-1]]\n\n\nOf course, if (high-low)%stride != 0, then the end point will be a little lower than high-1.\n\nIf stride is negative, the ordering is changed a bit since we're counting down:\n\n>>> seq[::-stride]        # [seq[-1],   seq[-1-stride],   ..., seq[0]    ]\n>>> seq[high::-stride]    # [seq[high], seq[high-stride], ..., seq[0]    ]\n>>> seq[:low:-stride]     # [seq[-1],   seq[-1-stride],   ..., seq[low+1]]\n>>> seq[high:low:-stride] # [seq[high], seq[high-stride], ..., seq[low+1]]\n\n\nExtended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.\n\n>>> class slicee:\n...     def __getitem__(self, item):\n...         return repr(item)\n...\n>>> slicee()[0, 1:2, ::5, ...]\n'(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'\n\n    ",
        "_Respuesta__votes": 459,
        "comentarios": [
            {
                "_id": 102,
                "_Comentario__descripcion": "Actually there is still something left out e.g. if I type 'apple'[4:-4:-1] I get 'elp', python is translating the -4 to a 1 maybe?",
                "_Comentario__fecha": "2018-01-01 16:39:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "liyuan",
                "usuario_id": null
            },
            {
                "_id": 103,
                "_Comentario__descripcion": "note that backticks are deprecated in favour of repr",
                "_Comentario__fecha": "2019-01-27 01:36:46Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "wjandrea",
                "usuario_id": null
            },
            {
                "_id": 104,
                "_Comentario__descripcion": "@liyuan The type implementing __getitem__ is; your example is equivalent to apple[slice(4, -4, -1)].",
                "_Comentario__fecha": "2019-09-10 14:26:28Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "chepner",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 78,
        "_Respuesta__fecha": "2019-01-02 16:44:22Z",
        "_Respuesta__descripcion": "\nThe answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:\n\n                +---+---+---+---+---+---+\n                | P | y | t | h | o | n |\n                +---+---+---+---+---+---+\nSlice position: 0   1   2   3   4   5   6\nIndex position:   0   1   2   3   4   5\n\n>>> p = ['P','y','t','h','o','n']\n# Why the two sets of numbers:\n# indexing gives items, not lists\n>>> p[0]\n 'P'\n>>> p[5]\n 'n'\n\n# Slicing gives lists\n>>> p[0:1]\n ['P']\n>>> p[0:2]\n ['P','y']\n\n\nOne heuristic is, for a slice from zero to n, think: \"zero is the beginning, start at the beginning and take n items in a list\".\n\n>>> p[5] # the last of six items, indexed from zero\n 'n'\n>>> p[0:5] # does NOT include the last item!\n ['P','y','t','h','o']\n>>> p[0:6] # not p[0:5]!!!\n ['P','y','t','h','o','n']\n\n\nAnother heuristic is, \"for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning\"\n\n>>> p[0:4] # Start at the beginning and count out 4 items\n ['P','y','t','h']\n>>> p[1:4] # Take one item off the front\n ['y','t','h']\n>>> p[2:4] # Take two items off the front\n ['t','h']\n# etc.\n\n\nThe first rule of slice assignment is that since slicing returns a list, slice assignment requires a list (or other iterable):\n\n>>> p[2:3]\n ['t']\n>>> p[2:3] = ['T']\n>>> p\n ['P','y','T','h','o','n']\n>>> p[2:3] = 't'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can only assign an iterable\n\n\nThe second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:\n\n>>> p[2:4]\n ['T','h']\n>>> p[2:4] = ['t','r']\n>>> p\n ['P','y','t','r','o','n']\n\n\nThe third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:\n\n>>> p = ['P','y','t','h','o','n'] # Start over\n>>> p[2:4] = ['s','p','a','m']\n>>> p\n ['P','y','s','p','a','m','o','n']\n\n\nThe trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around indexing an empty slice:\n\n>>> p = ['P','y','t','h','o','n']\n>>> p[0:4]\n ['P','y','t','h']\n>>> p[1:4]\n ['y','t','h']\n>>> p[2:4]\n ['t','h']\n>>> p[3:4]\n ['h']\n>>> p[4:4]\n []\n\n\nAnd then once you've seen that, slice assignment to the empty slice makes sense too:\n\n>>> p = ['P','y','t','h','o','n']\n>>> p[2:4] = ['x','y'] # Assigned list is same length as slice\n>>> p\n ['P','y','x','y','o','n'] # Result is same length\n>>> p = ['P','y','t','h','o','n']\n>>> p[3:4] = ['x','y'] # Assigned list is longer than slice\n>>> p\n ['P','y','t','x','y','o','n'] # The result is longer\n>>> p = ['P','y','t','h','o','n']\n>>> p[4:4] = ['x','y']\n>>> p\n ['P','y','t','h','x','y','o','n'] # The result is longer still\n\n\nNote that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.\n\nBacking up a little bit, what happens when you keep going with our procession of counting up the slice beginning?\n\n>>> p = ['P','y','t','h','o','n']\n>>> p[0:4]\n ['P','y','t','h']\n>>> p[1:4]\n ['y','t','h']\n>>> p[2:4]\n ['t','h']\n>>> p[3:4]\n ['h']\n>>> p[4:4]\n []\n>>> p[5:4]\n []\n>>> p[6:4]\n []\n\n\nWith slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.\n\n>>> p[5:3:-1]\n ['n','o']\n\n\nThere are some weird consequences to the \"once you're done, you're done\" rule:\n\n>>> p[4:4]\n []\n>>> p[5:4]\n []\n>>> p[6:4]\n []\n>>> p[6]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n\n\nIn fact, compared to indexing, Python slicing is bizarrely error-proof:\n\n>>> p[100:200]\n []\n>>> p[int(2e99):int(1e99)]\n []\n\n\nThis can come in handy sometimes, but it can also lead to somewhat strange behavior:\n\n>>> p\n ['P', 'y', 't', 'h', 'o', 'n']\n>>> p[int(2e99):int(1e99)] = ['p','o','w','e','r']\n>>> p\n ['P', 'y', 't', 'h', 'o', 'n', 'p', 'o', 'w', 'e', 'r']\n\n\nDepending on your application, that might... or might not... be what you were hoping for there!\n\n\n\nBelow is the text of my original answer. It has been useful to many people, so I didn't want to delete it.\n\n>>> r=[1,2,3,4]\n>>> r[1:1]\n[]\n>>> r[1:1]=[9,8]\n>>> r\n[1, 9, 8, 2, 3, 4]\n>>> r[1:1]=['blah']\n>>> r\n[1, 'blah', 9, 8, 2, 3, 4]\n\n\nThis may also clarify the difference between slicing and indexing.\n    ",
        "_Respuesta__votes": 380,
        "comentarios": [
            {
                "_id": 105,
                "_Comentario__descripcion": "Excellent explanation. But the logic behind slicing is very non-intuitive.",
                "_Comentario__fecha": "2020-08-19 10:06:49Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Moss",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 79,
        "_Respuesta__fecha": "2020-06-20 09:12:55Z",
        "_Respuesta__descripcion": "\n\nExplain Python's slice notation\n\nIn short, the colons (:) in subscript notation (subscriptable[subscriptarg]) make slice notation - which has the optional arguments, start, stop, step:\nsliceable[start:stop:step]\n\nPython slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.\nImportant Definitions\nTo begin with, let's define a few terms:\n\nstart: the beginning index of the slice, it will include the element at this index unless it is the same as stop, defaults to 0, i.e. the first index. If it's negative, it means to start n items from the end.\nstop: the ending index of the slice, it does not include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.\nstep: the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.\n\nHow Indexing Works\nYou can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the start and stop, and for the step, you simply decrement your index. This example is from the documentation's tutorial, but I've modified it slightly to indicate which item in a sequence each index references:\n +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n   0   1   2   3   4   5 \n  -6  -5  -4  -3  -2  -1\n\nHow Slicing Works\nTo use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually implement the __getitem__ method of the sequence, according to the Python data model.)\nSlice notation works like this:\nsequence[start:stop:step]\n\nAnd recall that there are defaults for start, stop, and step, so to access the defaults, simply leave out the argument.\nSlice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:\nmy_list[-9:]\n\nWhen I see this, I read the part in the brackets as \"9th from the end, to the end.\" (Actually, I abbreviate it mentally as \"-9, on\")\nExplanation:\nThe full notation is\nmy_list[-9:None:None]\n\nand to substitute the defaults (actually when step is negative, stop's default is -len(my_list) - 1, so None for stop really just means it goes to whichever end step takes it to):\nmy_list[-9:len(my_list):1]\n\nThe colon, :,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is\nlist_copy = sequence[:]\n\nAnd clearing them is with:\ndel my_list[:]\n\n(Python 3 gets a list.copy and list.clear method.)\nWhen step is negative, the defaults for start and stop change\nBy default, when the step argument is empty (or None), it is assigned to +1.\nBut you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.\nThus a negative slice will change the defaults for start and stop!\nConfirming this in the source\nI like to encourage users to read the source as well as the documentation. The source code for slice objects and this logic is found here. First we determine if step is negative:\n\n step_is_negative = step_sign < 0;\n\n\nIf so, the lower bound is -1  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this -1 is different from a -1 that users may pass indexes in Python indicating the last item.)\n\nif (step_is_negative) {\n    lower = PyLong_FromLong(-1L);\n    if (lower == NULL)\n        goto error;\n\n    upper = PyNumber_Add(length, lower);\n    if (upper == NULL)\n        goto error;\n}\n\n\nOtherwise step is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.\n\nelse {\n    lower = _PyLong_Zero;\n    Py_INCREF(lower);\n    upper = length;\n    Py_INCREF(upper);\n}\n\n\nThen, we may need to apply the defaults for start and stop - the default then for start is calculated as the upper bound when step is negative:\n\nif (self->start == Py_None) {\n    start = step_is_negative ? upper : lower;\n    Py_INCREF(start);\n}\n\n\nand stop, the lower bound:\n\nif (self->stop == Py_None) {\n    stop = step_is_negative ? lower : upper;\n    Py_INCREF(stop);\n}\n\n\nGive your slices a descriptive name!\nYou may find it useful to separate forming the slice from passing it to the list.__getitem__ method (that's what the square brackets do). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.\nHowever, you can't just assign some integers separated by colons to a variable. You need to use the slice object:\nlast_nine_slice = slice(-9, None)\n\nThe second argument, None, is required, so that the first argument is interpreted as the start argument otherwise it would be the stop argument.\nYou can then pass the slice object to your sequence:\n>>> list(range(100))[last_nine_slice]\n[91, 92, 93, 94, 95, 96, 97, 98, 99]\n\nIt's interesting that ranges also take slices:\n>>> range(100)[last_nine_slice]\nrange(91, 100)\n\nMemory Considerations:\nSince slices of Python lists create new objects in memory, another important function to be aware of is itertools.islice. Typically you'll want to iterate over a slice, not just have it created statically in memory. islice is perfect for this. A caveat, it doesn't support negative arguments to start, stop, or step, so if that's an issue you may need to calculate indices or reverse the iterable in advance.\nlength = 100\nlast_nine_iter = itertools.islice(list(range(length)), length-9, None, 1)\nlist_last_nine = list(last_nine_iter)\n\nand now:\n>>> list_last_nine\n[91, 92, 93, 94, 95, 96, 97, 98, 99]\n\nThe fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.\n    ",
        "_Respuesta__votes": 267,
        "comentarios": [
            {
                "_id": 106,
                "_Comentario__descripcion": "I like the idea of naming slices. I would suggest (start:stop) notation is misleading and (start_at:stop_before) notation may have preventing me searching out this Q&A in the first place.",
                "_Comentario__fecha": "2020-09-29 23:59:26Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "WinEunuuchs2Unix",
                "usuario_id": null
            },
            {
                "_id": 107,
                "_Comentario__descripcion": "@WinEunuuchs2Unix that's great feedback - this is a standard Python behavior, but it could be made clearer in that sort of way, so I'll consider updating my material to include this semantic.",
                "_Comentario__fecha": "2020-09-30 01:37:49Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Aaron Hall\u2666",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 80,
        "_Respuesta__fecha": "2009-02-03 23:15:02Z",
        "_Respuesta__descripcion": "\nAnd a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:\n\n>>> x = [1,2,3,4,5,6]\n>>> x[::-1]\n[6,5,4,3,2,1]\n\n\nEasy way to reverse sequences!\n\nAnd if you wanted, for some reason, every second item in the reversed sequence:\n\n>>> x = [1,2,3,4,5,6]\n>>> x[::-2]\n[6,4,2]\n\n    ",
        "_Respuesta__votes": 151,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 81,
        "_Respuesta__fecha": "2017-07-10 16:59:26Z",
        "_Respuesta__descripcion": "\nIn Python 2.7\n\nSlicing in Python\n\n[a:b:c]\n\nlen = length of string, tuple or list\n\nc -- default is +1. The sign of c indicates forward or backward, absolute value of c indicates steps. Default is forward with step size 1. Positive means forward, negative means backward.\n\na --  When c is positive or blank, default is 0. When c is negative, default is -1.\n\nb --  When c is positive or blank, default is len. When c is negative, default is -(len+1).\n\n\nUnderstanding index assignment is very important.\n\nIn forward direction, starts at 0 and ends at len-1\n\nIn backward direction, starts at -1 and ends at -len\n\n\nWhen you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:\n\n-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1\n\n\nBut this range continues in both directions infinitely:\n\n...,-len -2 ,-len-1,-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1, len, len +1, len+2 , ....\n\n\nFor example:\n\n             0    1    2   3    4   5   6   7   8   9   10   11\n             a    s    t   r    i   n   g\n    -9  -8  -7   -6   -5  -4   -3  -2  -1\n\n\nIf your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.\n\nOne last thing: if a and b are equal, then also you get an empty list:\n\n>>> l1\n[2, 3, 4]\n\n>>> l1[:]\n[2, 3, 4]\n\n>>> l1[::-1] # a default is -1 , b default is -(len+1)\n[4, 3, 2]\n\n>>> l1[:-4:-1] # a default is -1\n[4, 3, 2]\n\n>>> l1[:-3:-1] # a default is -1\n[4, 3]\n\n>>> l1[::] # c default is +1, so a default is 0, b default is len\n[2, 3, 4]\n\n>>> l1[::-1] # c is -1 , so a default is -1 and b default is -(len+1)\n[4, 3, 2]\n\n\n>>> l1[-100:-200:-1] # Interesting\n[]\n\n>>> l1[-1:-200:-1] # Interesting\n[4, 3, 2]\n\n\n>>> l1[-1:-1:1]\n[]\n\n\n>>> l1[-1:5:1] # Interesting\n[4]\n\n\n>>> l1[1:-7:1]\n[]\n\n>>> l1[1:-7:-1] # Interesting\n[3, 2]\n\n>>> l1[:-2:-2] # a default is -1, stop(b) at -2 , step(c) by 2 in reverse direction\n[4]\n\n    ",
        "_Respuesta__votes": 103,
        "comentarios": [
            {
                "_id": 108,
                "_Comentario__descripcion": "another one interesting example: a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]; a[:-2:-2] which results to [9]",
                "_Comentario__fecha": "2017-07-10 13:59:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Deviacium",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 82,
        "_Respuesta__fecha": "2011-09-06 06:50:08Z",
        "_Respuesta__descripcion": "\nFound this great table at http://wiki.python.org/moin/MovingToPythonFromOtherLanguages\n\nPython indexes and slices for a six-element list.\nIndexes enumerate the elements, slices enumerate the spaces between the elements.\n\nIndex from rear:    -6  -5  -4  -3  -2  -1      a=[0,1,2,3,4,5]    a[1:]==[1,2,3,4,5]\nIndex from front:    0   1   2   3   4   5      len(a)==6          a[:5]==[0,1,2,3,4]\n                   +---+---+---+---+---+---+    a[0]==0            a[:-2]==[0,1,2,3]\n                   | a | b | c | d | e | f |    a[5]==5            a[1:2]==[1]\n                   +---+---+---+---+---+---+    a[-1]==5           a[1:-1]==[1,2,3,4]\nSlice from front:  :   1   2   3   4   5   :    a[-2]==4\nSlice from rear:   :  -5  -4  -3  -2  -1   :\n                                                b=a[:]\n                                                b==[0,1,2,3,4,5] (shallow copy of a)\n    ",
        "_Respuesta__votes": 98,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 83,
        "_Respuesta__fecha": "2019-01-02 16:40:20Z",
        "_Respuesta__descripcion": "\nAfter using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a for loop...\n\n(from:to:step)\n\n\nAny of them are optional:\n\n(:to:step)\n(from::step)\n(from:to)\n\n\nThen the negative indexing just needs you to add the length of the string to the negative indices to understand it.\n\nThis works for me anyway...\n    ",
        "_Respuesta__votes": 68,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 84,
        "_Respuesta__fecha": "2019-01-02 16:46:18Z",
        "_Respuesta__descripcion": "\nI find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.\n\nIt's instructive to understand range() first:\n\ndef range(start=0, stop, step=1):  # Illegal syntax, but that's the effect\n    i = start\n    while (i < stop if step > 0 else i > stop):\n        yield i\n        i += step\n\n\nBegin from start, increment by step, do not reach stop.  Very simple.\n\nThe thing to remember about negative step is that stop is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. 'abcde'[1:-2][::-1] slices off one char from left, two from right, then reverses. (See also reversed().)\n\nSequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:\n\nTODO: The code below had a bug with \"never go outside the sequence\" when abs(step)>1; I think I patched it to be correct, but it's hard to understand.\n\ndef this_is_how_slicing_works(seq, start=None, stop=None, step=1):\n    if start is None:\n        start = (0 if step > 0 else len(seq)-1)\n    elif start < 0:\n        start += len(seq)\n    if not 0 <= start < len(seq):  # clip if still outside bounds\n        start = (0 if step > 0 else len(seq)-1)\n    if stop is None:\n        stop = (len(seq) if step > 0 else -1)  # really -1, not last element\n    elif stop < 0:\n        stop += len(seq)\n    for i in range(start, stop, step):\n        if 0 <= i < len(seq):\n            yield seq[i]\n\n\nDon't worry about the is None details - just remember that omitting start and/or stop always does the right thing to give you the whole sequence.\n\nNormalizing negative indexes first allows start and/or stop to be counted from the end independently: 'abcde'[1:-2] == 'abcde'[1:3] == 'bc' despite range(1,-2) == [].\nThe normalization is sometimes thought of as \"modulo the length\", but note it adds the length just once: e.g. 'abcde'[-53:42] is just the whole string.\n    ",
        "_Respuesta__votes": 52,
        "comentarios": [
            {
                "_id": 109,
                "_Comentario__descripcion": "The this_is_how_slicing_works is not the same as python slice. E.G. [0, 1, 2][-5:3:3] will get [0] in python, but list(this_is_how_slicing_works([0, 1, 2], -5, 3, 3)) get [1].",
                "_Comentario__fecha": "2016-10-29 12:56:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Eastsun",
                "usuario_id": null
            },
            {
                "_id": 110,
                "_Comentario__descripcion": "@Eastsun Oops, you're right!  A clearer case: range(4)[-200:200:3] == [0, 3] but list(this_is_how_slicing_works([0, 1, 2, 3], -200, 200, 3)) == [2]. My if 0 <= i < len(seq): was an attempt to implement \"never go outside the sequence\" simply but is wrong for step>1.  I'll rewrite it later today (with tests).",
                "_Comentario__fecha": "2016-10-30 12:36:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Beni Cherniavsky-Paskin",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 85,
        "_Respuesta__fecha": "2009-02-06 21:16:28Z",
        "_Respuesta__descripcion": "\nI use the \"an index points between elements\" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:\n\nmylist[X:Y]\n\n\nX is the index of the first element you want.\nY is the index of the first element you don't want.\n    ",
        "_Respuesta__votes": 42,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 86,
        "_Respuesta__fecha": "2017-02-11 19:56:15Z",
        "_Respuesta__descripcion": "\nIndex:\n      ------------>\n  0   1   2   3   4\n+---+---+---+---+---+\n| a | b | c | d | e |\n+---+---+---+---+---+\n  0  -4  -3  -2  -1\n      <------------\n\nSlice:\n    <---------------|\n|--------------->\n:   1   2   3   4   :\n+---+---+---+---+---+\n| a | b | c | d | e |\n+---+---+---+---+---+\n:  -4  -3  -2  -1   :\n|--------------->\n    <---------------|\n\n\nI hope this will help you to model the list in Python.\n\nReference: http://wiki.python.org/moin/MovingToPythonFromOtherLanguages\n    ",
        "_Respuesta__votes": 42,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 87,
        "_Respuesta__fecha": "2017-05-23 12:34:44Z",
        "_Respuesta__descripcion": "\nPython slicing notation:\n\na[start:end:step]\n\n\n\nFor start and end, negative values are interpreted as being relative to the end of the sequence.\nPositive indices for end indicate the position after the last element to be included.\nBlank values are defaulted as follows: [+0:-0:1].\nUsing a negative step reverses the interpretation of start and end\n\n\nThe notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:\n\nm[::,0:2:] ## slice the first two columns\n\n\nSlices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use deepcopy().\n    ",
        "_Respuesta__votes": 38,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 88,
        "_Respuesta__fecha": "2019-09-26 07:58:01Z",
        "_Respuesta__descripcion": "\nThis is how I teach slices to newbies:\n\nUnderstanding the difference between indexing and slicing:\n\nWiki Python has this amazing picture which clearly distinguishes indexing and slicing.\n\n\n\nIt is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.\n\nIndexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.\n\nIn [122]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [123]: alpha\nOut[123]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [124]: alpha[0]\nOut[124]: 'a'\n\nIn [127]: alpha[0] = 'A'\n\nIn [128]: alpha\nOut[128]: ['A', 'b', 'c', 'd', 'e', 'f']\n\nIn [129]: alpha[0,1]\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-129-c7eb16585371> in <module>()\n----> 1 alpha[0,1]\n\nTypeError: list indices must be integers, not tuple\n\n\nSlicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.\n\nYou can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.\n\nThe interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.\n\nIn [130]: alpha[0:1]\nOut[130]: ['A']\n\nIn [131]: alpha[0:1] = 'a'\n\nIn [132]: alpha\nOut[132]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [133]: alpha[0:2] = ['A', 'B']\n\nIn [134]: alpha\nOut[134]: ['A', 'B', 'c', 'd', 'e', 'f']\n\nIn [135]: alpha[2:2] = ['x', 'xx']\n\nIn [136]: alpha\nOut[136]: ['A', 'B', 'x', 'xx', 'c', 'd', 'e', 'f']\n\n\nSlicing With Step:\n\nTill now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.\n\nIn [137]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [142]: alpha[1:5:2]\nOut[142]: ['b', 'd']\n\nIn [143]: alpha[-1:-5:-2]\nOut[143]: ['f', 'd']\n\nIn [144]: alpha[1:5:-2]\nOut[144]: []\n\nIn [145]: alpha[-1:-5:2]\nOut[145]: []\n\n\nHow Python Figures Out Missing Parameters:\n\nWhen slicing, if you leave out any parameter, Python tries to figure it out automatically.\n\nIf you check the source code of CPython, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.\n\nThis function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.\n\ndef py_slice_get_indices_ex(obj, start=None, stop=None, step=None):\n\n    length = len(obj)\n\n    if step is None:\n        step = 1\n    if step == 0:\n        raise Exception(\"Step cannot be zero.\")\n\n    if start is None:\n        start = 0 if step > 0 else length - 1\n    else:\n        if start < 0:\n            start += length\n        if start < 0:\n            start = 0 if step > 0 else -1\n        if start >= length:\n            start = length if step > 0 else length - 1\n\n    if stop is None:\n        stop = length if step > 0 else -1\n    else:\n        if stop < 0:\n            stop += length\n        if stop < 0:\n            stop = 0 if step > 0 else -1\n        if stop >= length:\n            stop = length if step > 0 else length - 1\n\n    if (step < 0 and stop >= start) or (step > 0 and start >= stop):\n        slice_length = 0\n    elif step < 0:\n        slice_length = (stop - start + 1)/(step) + 1\n    else:\n        slice_length = (stop - start - 1)/(step) + 1\n\n    return (start, stop, step, slice_length)\n\n\nThis is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.\n\nIn [21]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [22]: s = slice(None, None, None)\n\nIn [23]: s\nOut[23]: slice(None, None, None)\n\nIn [24]: s.indices(len(alpha))\nOut[24]: (0, 6, 1)\n\nIn [25]: range(*s.indices(len(alpha)))\nOut[25]: [0, 1, 2, 3, 4, 5]\n\nIn [26]: s = slice(None, None, -1)\n\nIn [27]: range(*s.indices(len(alpha)))\nOut[27]: [5, 4, 3, 2, 1, 0]\n\nIn [28]: s = slice(None, 3, -1)\n\nIn [29]: range(*s.indices(len(alpha)))\nOut[29]: [5, 4]\n\n\nNote: This post was originally written in my blog, The Intelligence Behind Python Slices.\n    ",
        "_Respuesta__votes": 36,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 89,
        "_Respuesta__fecha": "2013-04-19 16:28:16Z",
        "_Respuesta__descripcion": "\nYou can also use slice assignment to remove one or more elements from a list:\n\nr = [1, 'blah', 9, 8, 2, 3, 4]\n>>> r[1:4] = []\n>>> r\n[1, 2, 3, 4]\n\n    ",
        "_Respuesta__votes": 34,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 90,
        "_Respuesta__fecha": "2019-05-08 08:35:55Z",
        "_Respuesta__descripcion": "\nThis is just for some extra info...\nConsider the list below \n\n>>> l=[12,23,345,456,67,7,945,467]\n\n\nFew other tricks for reversing the list:\n\n>>> l[len(l):-len(l)-1:-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n>>> l[:-len(l)-1:-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n>>> l[len(l)::-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n>>> l[::-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n>>> l[-1:-len(l)-1:-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n    ",
        "_Respuesta__votes": 33,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 91,
        "_Respuesta__fecha": "2013-12-07 16:52:45Z",
        "_Respuesta__descripcion": "\nAs a general rule, writing code with a lot of hardcoded index values leads to a readability\nand maintenance mess. For example, if you come back to the code a year later, you\u2019ll\nlook at it and wonder what you were thinking when you wrote it. The solution shown\nis simply a way of more clearly stating what your code is actually doing.\nIn general, the built-in slice() creates a slice object that can be used anywhere a slice\nis allowed. For example:\n\n>>> items = [0, 1, 2, 3, 4, 5, 6]\n>>> a = slice(2, 4)\n>>> items[2:4]\n[2, 3]\n>>> items[a]\n[2, 3]\n>>> items[a] = [10,11]\n>>> items\n[0, 1, 10, 11, 4, 5, 6]\n>>> del items[a]\n>>> items\n[0, 1, 4, 5, 6]\n\n\nIf you have a slice instance s, you can get more information about it by looking at its\ns.start, s.stop, and s.step attributes, respectively. For example:\n\n\n>>> a = slice(10, 50, 2)\n>>> a.start\n10\n>>> a.stop\n50\n>>> a.step\n2\n>>>\n\n\n    ",
        "_Respuesta__votes": 29,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 92,
        "_Respuesta__fecha": "2019-09-26 08:04:23Z",
        "_Respuesta__descripcion": "\n1. Slice Notation\n\nTo make it simple, remember slice has only one form\uff1a\n\ns[start:end:step]\n\n\nand here is how it works:\n\n\ns: an object that can be sliced\nstart: first index to start iteration\nend: last index, NOTE that end index will not be included in the resulted slice\nstep: pick element every step index\n\n\nAnother import thing: all start,end, step can be omitted! And if they are omitted, their default value will be used: 0,len(s),1 accordingly.\n\nSo possible variations are:\n\n# Mostly used variations\ns[start:end]\ns[start:]\ns[:end]\n\n# Step-related variations\ns[:end:step]\ns[start::step]\ns[::step]\n\n# Make a copy\ns[:]\n\n\nNOTE: If start >= end (considering only when step>0), Python will return a empty slice [].\n\n2. Pitfalls\n\nThe above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.\n\nNegative indexes\n\nThe very first thing that confuses Python learners is that an index can be negative!\nDon't panic: a negative index means count backwards.\n\nFor example:\n\ns[-5:]    # Start at the 5th index from the end of array,\n          # thus returning the last 5 elements.\ns[:-5]    # Start at index 0, and end until the 5th index from end of array,\n          # thus returning s[0:len(s)-5].\n\n\nNegative step\n\nMaking things more confusing is that step can be negative too!\n\nA negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.\n\nNOTE: when step is negative, the default value for start is len(s) (while end does not equal to 0, because s[::-1] contains s[0]). For example:\n\ns[::-1]            # Reversed slice\ns[len(s)::-1]      # The same as above, reversed slice\ns[0:len(s):-1]     # Empty list\n\n\nOut of range error?\n\nBe surprised: slice does not raise an IndexError when the index is out of range!\n\nIf the index is out of range, Python will try its best to set the index to 0 or len(s) according to the situation. For example:\n\ns[:len(s)+5]      # The same as s[:len(s)]\ns[-len(s)-5::]    # The same as s[0:]\ns[len(s)+5::-1]   # The same as s[len(s)::-1], and the same as s[::-1]\n\n\n3. Examples\n\nLet's finish this answer with examples, explaining everything we have discussed:\n\n# Create our array for demonstration\nIn [1]: s = [i for i in range(10)]\n\nIn [2]: s\nOut[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nIn [3]: s[2:]   # From index 2 to last index\nOut[3]: [2, 3, 4, 5, 6, 7, 8, 9]\n\nIn [4]: s[:8]   # From index 0 up to index 8\nOut[4]: [0, 1, 2, 3, 4, 5, 6, 7]\n\nIn [5]: s[4:7]  # From index 4 (included) up to index 7(excluded)\nOut[5]: [4, 5, 6]\n\nIn [6]: s[:-2]  # Up to second last index (negative index)\nOut[6]: [0, 1, 2, 3, 4, 5, 6, 7]\n\nIn [7]: s[-2:]  # From second last index (negative index)\nOut[7]: [8, 9]\n\nIn [8]: s[::-1] # From last to first in reverse order (negative step)\nOut[8]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\nIn [9]: s[::-2] # All odd numbers in reversed order\nOut[9]: [9, 7, 5, 3, 1]\n\nIn [11]: s[-2::-2] # All even numbers in reversed order\nOut[11]: [8, 6, 4, 2, 0]\n\nIn [12]: s[3:15]   # End is out of range, and Python will set it to len(s).\nOut[12]: [3, 4, 5, 6, 7, 8, 9]\n\nIn [14]: s[5:1]    # Start > end; return empty list\nOut[14]: []\n\nIn [15]: s[11]     # Access index 11 (greater than len(s)) will raise an IndexError\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n<ipython-input-15-79ffc22473a3> in <module>()\n----> 1 s[11]\n\nIndexError: list index out of range\n\n    ",
        "_Respuesta__votes": 28,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 93,
        "_Respuesta__fecha": "2019-09-26 08:08:54Z",
        "_Respuesta__descripcion": "\nThe previous answers don't discuss multi-dimensional array slicing which is possible using the famous NumPy package:\n\nSlicing can also be applied to multi-dimensional arrays.\n\n# Here, a is a NumPy array\n\n>>> a\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n>>> a[:2, 0:3:2]\narray([[1, 3],\n       [5, 7]])\n\n\nThe \":2\" before the comma operates on the first dimension and the \"0:3:2\" after the comma operates on the second dimension.\n    ",
        "_Respuesta__votes": 27,
        "comentarios": [
            {
                "_id": 111,
                "_Comentario__descripcion": "Just a friendly reminder that you cannot do this on Python list but only on array in Numpy",
                "_Comentario__fecha": "2019-07-26 21:46:53Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mars Lee",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 94,
        "_Respuesta__fecha": "2020-01-15 12:29:43Z",
        "_Respuesta__descripcion": "\nI personally think about it like a for loop:\n\na[start:end:step]\n# for(i = start; i < end; i += step)\n\n\nAlso, note that negative values for start and end are relative to the end of the list and computed in the example above by given_index + a.shape[0].\n    ",
        "_Respuesta__votes": 18,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 95,
        "_Respuesta__fecha": "2020-01-08 16:12:41Z",
        "_Respuesta__descripcion": "\nIn my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).\n\nLet's work with the following string ...\n\nazString = \"abcdefghijklmnopqrstuvwxyz\"\n\n\nFor those who don't know, you can create any substring from azString using the notation azString[x:y]\n\nComing from other programming languages, that's when the common sense gets compromised. What are x and y?\n\nI had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.\n\nMy conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as azString[index1, index2] or even more clearer as azString[index_of_first_character, index_after_the_last_character].\n\nHere is an example visualization of that ...\n\nLetters   a b c d e f g h i j ...\n         \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191\n             \u250a           \u250a\nIndexes  0 1 2 3 4 5 6 7 8 9 ...\n             \u250a           \u250a\ncdefgh    index1       index2\n\n\nSo all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring \"cdefgh\", you can use azString[2:8], because the index on the left side of \"c\" is 2 and the one on the right size of \"h\" is 8.\n\nRemember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...\n\na b [ c d e f g h ] i j\n\nThat trick works all the time and is easy to memorize.\n    ",
        "_Respuesta__votes": 17,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 96,
        "_Respuesta__fecha": "2014-10-18 17:40:45Z",
        "_Respuesta__descripcion": "\n#!/usr/bin/env python\n\ndef slicegraphical(s, lista):\n\n    if len(s) > 9:\n        print \"\"\"Enter a string of maximum 9 characters,\n    so the printig would looki nice\"\"\"\n        return 0;\n    # print \" \",\n    print '  '+'+---' * len(s) +'+'\n    print ' ',\n    for letter in s:\n        print '| {}'.format(letter),\n    print '|'\n    print \" \",; print '+---' * len(s) +'+'\n\n    print \" \",\n    for letter in range(len(s) +1):\n        print '{}  '.format(letter),\n    print \"\"\n    for letter in range(-1*(len(s)), 0):\n        print ' {}'.format(letter),\n    print ''\n    print ''\n\n\n    for triada in lista:\n        if len(triada) == 3:\n            if triada[0]==None and triada[1] == None and triada[2] == None:\n                # 000\n                print s+'[   :   :   ]' +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] == None and triada[1] == None and triada[2] != None:\n                # 001\n                print s+'[   :   :{0:2d} ]'.format(triada[2], '','') +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] == None and triada[1] != None and triada[2] == None:\n                # 010\n                print s+'[   :{0:2d} :   ]'.format(triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] == None and triada[1] != None and triada[2] != None:\n                # 011\n                print s+'[   :{0:2d} :{1:2d} ]'.format(triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] == None and triada[2] == None:\n                # 100\n                print s+'[{0:2d} :   :   ]'.format(triada[0]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] == None and triada[2] != None:\n                # 101\n                print s+'[{0:2d} :   :{1:2d} ]'.format(triada[0], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] != None and triada[2] == None:\n                # 110\n                print s+'[{0:2d} :{1:2d} :   ]'.format(triada[0], triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] != None and triada[2] != None:\n                # 111\n                print s+'[{0:2d} :{1:2d} :{2:2d} ]'.format(triada[0], triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]\n\n        elif len(triada) == 2:\n            if triada[0] == None and triada[1] == None:\n                # 00\n                print s+'[   :   ]    ' + ' = ', s[triada[0]:triada[1]]\n            elif triada[0] == None and triada[1] != None:\n                # 01\n                print s+'[   :{0:2d} ]    '.format(triada[1]) + ' = ', s[triada[0]:triada[1]]\n            elif triada[0] != None and triada[1] == None:\n                # 10\n                print s+'[{0:2d} :   ]    '.format(triada[0]) + ' = ', s[triada[0]:triada[1]]\n            elif triada[0] != None and triada[1] != None:\n                # 11\n                print s+'[{0:2d} :{1:2d} ]    '.format(triada[0],triada[1]) + ' = ', s[triada[0]:triada[1]]\n\n        elif len(triada) == 1:\n            print s+'[{0:2d} ]        '.format(triada[0]) + ' = ', s[triada[0]]\n\n\nif __name__ == '__main__':\n    # Change \"s\" to what ever string you like, make it 9 characters for\n    # better representation.\n    s = 'COMPUTERS'\n\n    # add to this list different lists to experement with indexes\n    # to represent ex. s[::], use s[None, None,None], otherwise you get an error\n    # for s[2:] use s[2:None]\n\n    lista = [[4,7],[2,5,2],[-5,1,-1],[4],[-4,-6,-1], [2,-3,1],[2,-3,-1], [None,None,-1],[-5,None],[-5,0,-1],[-5,None,-1],[-1,1,-2]]\n\n    slicegraphical(s, lista)\n\n\nYou can run this script and experiment with it, below is some samples that I got from the script.\n\n  +---+---+---+---+---+---+---+---+---+\n  | C | O | M | P | U | T | E | R | S |\n  +---+---+---+---+---+---+---+---+---+\n  0   1   2   3   4   5   6   7   8   9   \n -9  -8  -7  -6  -5  -4  -3  -2  -1 \n\nCOMPUTERS[ 4 : 7 ]     =  UTE\nCOMPUTERS[ 2 : 5 : 2 ] =  MU\nCOMPUTERS[-5 : 1 :-1 ] =  UPM\nCOMPUTERS[ 4 ]         =  U\nCOMPUTERS[-4 :-6 :-1 ] =  TU\nCOMPUTERS[ 2 :-3 : 1 ] =  MPUT\nCOMPUTERS[ 2 :-3 :-1 ] =  \nCOMPUTERS[   :   :-1 ] =  SRETUPMOC\nCOMPUTERS[-5 :   ]     =  UTERS\nCOMPUTERS[-5 : 0 :-1 ] =  UPMO\nCOMPUTERS[-5 :   :-1 ] =  UPMOC\nCOMPUTERS[-1 : 1 :-2 ] =  SEUM\n[Finished in 0.9s]\n\n\nWhen using a negative step, notice that the answer is shifted to the right by 1.\n    ",
        "_Respuesta__votes": 15,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 97,
        "_Respuesta__fecha": "2016-05-26 08:16:54Z",
        "_Respuesta__descripcion": "\nMy brain seems happy to accept that lst[start:end] contains the start-th item. I might even say that it is a 'natural assumption'.\n\nBut occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the end-th element.\n\nIn these moments I rely on this simple theorem:\n\nfor any n,    lst = lst[:n] + lst[n:]\n\n\nThis pretty property tells me that lst[start:end] does not contain the end-th item because it is in lst[end:].\n\nNote that this theorem is true for any n at all. For example, you can check that\n\nlst = range(10)\nlst[:-42] + lst[-42:] == lst\n\n\nreturns True.\n    ",
        "_Respuesta__votes": 14,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 98,
        "_Respuesta__fecha": "2019-09-26 08:23:54Z",
        "_Respuesta__descripcion": "\nI want to add one Hello, World! example that explains the basics of slices for the very beginners. It helped me a lot.\n\nLet's have a list with six values ['P', 'Y', 'T', 'H', 'O', 'N']:\n\n+---+---+---+---+---+---+\n| P | Y | T | H | O | N |\n+---+---+---+---+---+---+\n  0   1   2   3   4   5\n\n\nNow the simplest slices of that list are its sublists. The notation is [<index>:<index>] and the key is to read it like this:\n\n[ start cutting before this index : end cutting before this index ]\n\n\nNow if you make a slice [2:5] of the list above, this will happen:\n\n        |           |\n+---+---|---+---+---|---+\n| P | Y | T | H | O | N |\n+---+---|---+---+---|---+\n  0   1 | 2   3   4 | 5\n\n\nYou made a cut before the element with index 2 and another cut before the element with index 5. So the result will be a slice between those two cuts, a list ['T', 'H', 'O'].\n    ",
        "_Respuesta__votes": 12,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 99,
        "_Respuesta__fecha": "2019-09-26 08:16:53Z",
        "_Respuesta__descripcion": "\nIn Python, the most basic form for slicing is the following:\n\nl[start:end]\n\n\nwhere l is some collection, start is an inclusive index, and end is an exclusive index.\n\nIn [1]: l = list(range(10))\n\nIn [2]: l[:5] # First five elements\nOut[2]: [0, 1, 2, 3, 4]\n\nIn [3]: l[-5:] # Last five elements\nOut[3]: [5, 6, 7, 8, 9]\n\n\nWhen slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:\n\nIn [5]: l[:3] == l[0:3]\nOut[5]: True\n\nIn [6]: l[7:] == l[7:len(l)]\nOut[6]: True\n\n\nNegative integers are useful when doing offsets relative to the end of a collection:\n\nIn [7]: l[:-1] # Include all elements but the last one\nOut[7]: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\nIn [8]: l[-3:] # Take the last three elements\nOut[8]: [7, 8, 9]\n\n\nIt is possible to provide indices that are out of bounds when slicing such as:\n\nIn [9]: l[:20] # 20 is out of index bounds, and l[20] will raise an IndexError exception\nOut[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nIn [11]: l[-20:] # -20 is out of index bounds, and l[-20] will raise an IndexError exception\nOut[11]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nKeep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:\n\nIn [16]: l[2:6] = list('abc') # Assigning fewer elements than the ones contained in the sliced collection l[2:6]\n\nIn [17]: l\nOut[17]: [0, 1, 'a', 'b', 'c', 6, 7, 8, 9]\n\nIn [18]: l[2:5] = list('hello') # Assigning more elements than the ones contained in the sliced collection l [2:5]\n\nIn [19]: l\nOut[19]: [0, 1, 'h', 'e', 'l', 'l', 'o', 6, 7, 8, 9]\n\n\nIf you omit the start and end index, you will make a copy of the collection:\n\nIn [14]: l_copy = l[:]\n\nIn [15]: l == l_copy and l is not l_copy\nOut[15]: True\n\n\nIf the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:\n\nIn [20]: l[:] = list('hello...')\n\nIn [21]: l\nOut[21]: ['h', 'e', 'l', 'l', 'o', '.', '.', '.']\n\n\nBesides basic slicing, it is also possible to apply the following notation:\n\nl[start:end:step]\n\n\nwhere l is a collection, start is an inclusive index, end is an exclusive index, and step is a stride that can be used to take every nth item in l.\n\nIn [22]: l = list(range(10))\n\nIn [23]: l[::2] # Take the elements which indexes are even\nOut[23]: [0, 2, 4, 6, 8]\n\nIn [24]: l[1::2] # Take the elements which indexes are odd\nOut[24]: [1, 3, 5, 7, 9]\n\n\nUsing step provides a useful trick to reverse a collection in Python:\n\nIn [25]: l[::-1]\nOut[25]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n\nIt is also possible to use negative integers for step as the following example:\n\nIn[28]:  l[::-2]\nOut[28]: [9, 7, 5, 3, 1]\n\n\nHowever, using a negative value for step could become very confusing. Moreover, in order to be Pythonic, you should avoid using start, end, and step in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).\n\nIn [29]: l = l[::2] # This step is for striding\n\nIn [30]: l\nOut[30]: [0, 2, 4, 6, 8]\n\nIn [31]: l = l[1:-1] # This step is for slicing\n\nIn [32]: l\nOut[32]: [2, 4, 6]\n\n    ",
        "_Respuesta__votes": 11,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 100,
        "_Respuesta__fecha": "2019-09-26 08:19:02Z",
        "_Respuesta__descripcion": "\nMost of the previous answers clears up questions about slice notation.\n\nThe extended indexing syntax used for slicing is aList[start:stop:step], and basic examples are:\n\n:\n\nMore slicing examples: 15 Extended Slices\n    ",
        "_Respuesta__votes": 11,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 101,
        "_Respuesta__fecha": "2019-09-26 08:10:54Z",
        "_Respuesta__descripcion": "\nThe below is the example of an index of a string:\n\n +---+---+---+---+---+\n | H | e | l | p | A |\n +---+---+---+---+---+\n 0   1   2   3   4   5\n-5  -4  -3  -2  -1\n\nstr=\"Name string\"\n\n\nSlicing example: [start:end:step]\n\nstr[start:end] # Items start through end-1\nstr[start:]    # Items start through the rest of the array\nstr[:end]      # Items from the beginning through end-1\nstr[:]         # A copy of the whole array\n\n\nBelow is the example usage:\n\nprint str[0] = N\nprint str[0:2] = Na\nprint str[0:7] = Name st\nprint str[0:7:2] = Nm t\nprint str[0:-1:2] = Nm ti\n\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 102,
        "_Respuesta__fecha": "2019-09-26 08:22:50Z",
        "_Respuesta__descripcion": "\nIf you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with len - index. So for example, replace -3 with len(list) - 3.\n\nThe best way to illustrate what slicing does internally is just show it in code that implements this operation:\n\ndef slice(list, start = None, end = None, step = 1):\n  # Take care of missing start/end parameters\n  start = 0 if start is None else start\n  end = len(list) if end is None else end\n\n  # Take care of negative start/end parameters\n  start = len(list) + start if start < 0 else start\n  end = len(list) + end if end < 0 else end\n\n  # Now just execute a for-loop with start, end and step\n  return [list[i] for i in range(start, end, step)]\n\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 103,
        "_Respuesta__fecha": "2020-07-23 05:22:23Z",
        "_Respuesta__descripcion": "\nThe rules of slicing are as follows:\n[lower bound : upper bound : step size]\n\nI- Convert upper bound  and lower bound into common signs.\nII- Then check if the step size is a positive or a negative value.\n(i) If the step size is a positive value, upper bound should be greater than lower bound, otherwise empty string is printed. For example:\ns=\"Welcome\"\ns1=s[0:3:1]\nprint(s1)\n\nThe output:\nWel\n\nHowever if we run the following code:\ns=\"Welcome\"\ns1=s[3:0:1]\nprint(s1)\n\nIt will return an empty string.\n(ii) If the step size if a negative value, upper bound should be lesser than lower bound, otherwise empty string will be printed. For example:\ns=\"Welcome\"\ns1=s[3:0:-1]\nprint(s1)\n\nThe output:\ncle\n\nBut if we run the following code:\ns=\"Welcome\"\ns1=s[0:5:-1]\nprint(s1)\n\nThe output will be an empty string.\nThus in the code:\nstr = 'abcd'\nl = len(str)\nstr2 = str[l-1:0:-1]    #str[3:0:-1] \nprint(str2)\nstr2 = str[l-1:-1:-1]    #str[3:-1:-1]\nprint(str2)\n\nIn the first str2=str[l-1:0:-1], the upper bound is lesser than the lower bound, thus dcb is printed.\nHowever in str2=str[l-1:-1:-1], the upper bound is not less than the lower bound (upon converting lower bound into negative value which is -1: since index of last element is -1 as well as 3).\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 104,
        "_Respuesta__fecha": "2019-09-26 08:25:46Z",
        "_Respuesta__descripcion": "\nThe basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.\n\nFirst, we will create a list of values to use in our slicing.\n\nCreate two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):\n\nA = list(range(1, 10, 1)) # Start, stop, and step\nB = list(range(9))\n\nprint(\"This is List A:\", A)\nprint(\"This is List B:\", B)\n\n\nIndex the number 3 from A and the number 6 from B.\n\nprint(A[2])\nprint(B[6])\n\n\nBasic Slicing\n\nExtended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation.\n\nAs you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.\n\nIt is important to note, the first element is index 0, not index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc.).\n\nWith extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.\n\nA[:]\n\n\nTo retrieve a subset of elements, the start and stop positions need to be defined.\n\nGiven the pattern aList[start:stop], retrieve the first two elements from List A.\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 106,
        "_Respuesta__fecha": "2021-07-30 23:41:21Z",
        "_Respuesta__descripcion": "\nActually, this is not a design flaw, and it is not because of internals or performance.\nIt comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.\nAs soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object.\nIn any case, Effbot has a very nice explanation of the reasons for this behavior in Default Parameter Values in Python.\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work.\n    ",
        "_Respuesta__votes": 1761,
        "comentarios": [
            {
                "_id": 117,
                "_Comentario__descripcion": "To anyone reading the above answer, I strongly recommend you take the time to read through the linked Effbot article. As well as all the other useful info, the part on how this language feature can be used for result caching/memoisation is very handy to know!",
                "_Comentario__fecha": "2011-10-14 00:05:52Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Cam Jackson",
                "usuario_id": null
            },
            {
                "_id": 118,
                "_Comentario__descripcion": "Even if it's a first-class object, one might still envision a design where the code for each default value is stored along with the object and re-evaluated each time the function is called. I'm not saying that would be better, just that functions being first-class objects does not fully preclude it.",
                "_Comentario__fecha": "2013-01-11 10:55:25Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "gerrit",
                "usuario_id": null
            },
            {
                "_id": 119,
                "_Comentario__descripcion": "Sorry, but anything considered \"The biggest WTF in Python\" is most definitely a design flaw.  This is a source of bugs for everyone at some point, because no one expects that behavior at first - which means it should not have been designed that way to begin with.  I don't care what hoops they had to jump through, they should have designed Python so that default arguments are non-static.",
                "_Comentario__fecha": "2013-06-07 21:28:27Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "BlueRaja - Danny Pflughoeft",
                "usuario_id": null
            },
            {
                "_id": 120,
                "_Comentario__descripcion": "Whether or not it's a design flaw, your answer seems to imply that this behaviour is somehow necessary, natural and obvious given that functions are first-class objects, and that simply isn't the case. Python has closures. If you replace the default argument with an assignment on the first line of the function, it evaluates the expression each call (potentially using names declared in an enclosing scope). There is no reason at all that it wouldn't be possible or reasonable to have default arguments evaluated each time the function is called in exactly the same way.",
                "_Comentario__fecha": "2014-01-08 22:16:13Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Amery",
                "usuario_id": null
            },
            {
                "_id": 121,
                "_Comentario__descripcion": "The design doesn't directly follow from functions are objects. In your paradigm, the proposal would be to implement functions' default values as properties rather than attributes.",
                "_Comentario__fecha": "2014-05-03 20:46:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "bukzor",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 107,
        "_Respuesta__fecha": "2021-07-30 23:44:28Z",
        "_Respuesta__descripcion": "\nSuppose you have the following code\nfruits = (\"apples\", \"bananas\", \"loganberries\")\n\ndef eat(food=fruits):\n    ...\n\nWhen I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple (\"apples\", \"bananas\", \"loganberries\")\nHowever, suppose later on in the code, I do something like\ndef some_random_function():\n    global fruits\n    fruits = (\"blueberries\", \"mangos\")\n\nthen if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your foo function above was mutating the list.\nThe real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:\nStringBuffer s = new StringBuffer(\"Hello World!\");\nMap<StringBuffer,Integer> counts = new HashMap<StringBuffer,Integer>();\ncounts.put(s, 5);\ns.append(\"!!!!\");\nSystem.out.println( counts.get(s) );  // does this work?\n\nNow, does my map use the value of the StringBuffer key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the Map using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).\nYour example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we \"fixed\" this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.\nI personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.\n    ",
        "_Respuesta__votes": 295,
        "comentarios": [
            {
                "_id": 122,
                "_Comentario__descripcion": "I think it's a matter of debate. You are acting on a global variable. Any evaluation performed anywhere in your code involving your global variable will now (correctly) refer to (\"blueberries\", \"mangos\"). the default parameter could just be like any other case.",
                "_Comentario__fecha": "2009-07-15 18:16:08Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Stefano Borini",
                "usuario_id": null
            },
            {
                "_id": 123,
                "_Comentario__descripcion": "Actually, I don't think I agree with your first example.  I'm not sure I like the idea of modifying an initializer like that in the first place, but if I did, I'd expect it to behave exactly as you describe \u2014 changing the default value to (\"blueberries\", \"mangos\").",
                "_Comentario__fecha": "2009-07-15 18:26:45Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Ben Blank",
                "usuario_id": null
            },
            {
                "_id": 124,
                "_Comentario__descripcion": "The default parameter is like any other case. What is unexpected is that the parameter is a global variable, and not a local one. Which in turn is because the code is executed at function definition, not call. Once you get that, and that the same goes for classes, it's perfectly clear.",
                "_Comentario__fecha": "2009-07-15 18:59:01Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Lennart Regebro",
                "usuario_id": null
            },
            {
                "_id": 125,
                "_Comentario__descripcion": "I find the example misleading rather than brilliant. If some_random_function() appends to fruits instead of assigning to it, the behaviour of eat() will change. So much for the current wonderful design. If you use a default argument that's referenced elsewhere and then modify the reference from outside the function, you are asking for trouble. The real WTF is when people define a fresh default argument (a list literal or a call to a constructor), and still get bit.",
                "_Comentario__fecha": "2014-10-09 15:37:29Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "alexis",
                "usuario_id": null
            },
            {
                "_id": 126,
                "_Comentario__descripcion": "You just explicitly declared global and reassigned the tuple - there is absolutely nothing surprising if eat works differently after that.",
                "_Comentario__fecha": "2015-01-26 16:07:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "user3467349",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 108,
        "_Respuesta__fecha": "2020-01-30 18:00:14Z",
        "_Respuesta__descripcion": "\nThe relevant part of the documentation:\n\n\n  Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.:\n\ndef whats_on_the_telly(penguin=None):\n    if penguin is None:\n        penguin = []\n    penguin.append(\"property of the zoo\")\n    return penguin\n\n\n    ",
        "_Respuesta__votes": 262,
        "comentarios": [
            {
                "_id": 127,
                "_Comentario__descripcion": "The phrases \"this is not generally what was intended\" and \"a way around this is\" smell like they're documenting a design flaw.",
                "_Comentario__fecha": "2014-05-03 20:53:15Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "bukzor",
                "usuario_id": null
            },
            {
                "_id": 128,
                "_Comentario__descripcion": "@bukzor: Pitfalls need to be noted and documented, which is why this question is good and has received so many upvotes. At the same time, pitfalls don't necessarily need to be removed. How many Python beginners have passed a list to a function that modified it, and were shocked to see the changes show up in the original variable? Yet mutable object types are wonderful, when you understand how to use them. I guess it just boils down to opinion on this particular pitfall.",
                "_Comentario__fecha": "2014-06-19 17:54:06Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Matthew",
                "usuario_id": null
            },
            {
                "_id": 129,
                "_Comentario__descripcion": "The phrase \"this is not generally what was intended\" means \"not what the programmer actually wanted to happen,\" not \"not what Python is supposed to do.\"",
                "_Comentario__fecha": "2014-12-19 11:48:14Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "holdenweb",
                "usuario_id": null
            },
            {
                "_id": 130,
                "_Comentario__descripcion": "@holdenweb Wow, I'm mega-late to the party. Given the context, bukzor is completely right: they're documenting behavior/consequence that was not \"intended\" when they they decided the language should exec the function's definition. Since it's an unintended consequence of their design choice, it's a design flaw. If it were not a design flaw, there'd be no need to even offer \"a way around this\".",
                "_Comentario__fecha": "2017-10-03 07:35:53Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "code_dredd",
                "usuario_id": null
            },
            {
                "_id": 131,
                "_Comentario__descripcion": "We could take it to chat and discuss how else it could be, but the semantics have been thoroughly debated and nobody could come up with a sensible mechanism for create-default-value-on-call. One serious issue is that the scope on call is often entirely different from that on definition, making name resolution uncertain if defaults were evaluated at call time. A \"way around\" means \"you can achieve your desired end in the following way,\" not \"this is a mistake in Python's design.\"",
                "_Comentario__fecha": "2017-10-03 16:03:13Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "holdenweb",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 109,
        "_Respuesta__fecha": "2019-05-09 09:15:36Z",
        "_Respuesta__descripcion": "\nI know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.\n\nProvided that python objects are mutable I think that this should be taken into account when designing the default arguments stuff.\nWhen you instantiate a list:\n\na = []\n\n\nyou expect to get a new list referenced by a.\n\nWhy should the a=[] in\n\ndef x(a=[]):\n\n\ninstantiate a new list on function definition and not on invocation?\nIt's just like you're asking \"if the user doesn't provide the argument then instantiate a new list and use it as if it was produced by the caller\".\nI think this is ambiguous instead:\n\ndef x(a=datetime.datetime.now()):\n\n\nuser, do you want a to default to the datetime corresponding to when you're defining or executing x?\nIn this case, as in the previous one, I'll keep the same behaviour as if the default argument \"assignment\" was the first instruction of the function (datetime.now() called on function invocation).\nOn the other hand, if the user wanted the definition-time mapping he could write:\n\nb = datetime.datetime.now()\ndef x(a=b):\n\n\nI know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:\n\ndef x(static a=b):\n\n    ",
        "_Respuesta__votes": 125,
        "comentarios": [
            {
                "_id": 132,
                "_Comentario__descripcion": "You could do: def x(a=None): And then, if a is None, set a=datetime.datetime.now()",
                "_Comentario__fecha": "2009-07-16 00:18:29Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Anon",
                "usuario_id": null
            },
            {
                "_id": 133,
                "_Comentario__descripcion": "Thank you for this. I couldn't really put my finger on why this  irks me to no end. You have done it beautifully with a minimum of fuzz and confusion. As someone comming from systems programming in C++ and sometimes naively \"translating\" language features, this false friend kicked me in the in the soft of the head big time, just like class attributes. I understand why things are this way, but I cannot help but dislike it, no matter what positive might come of it. At least it is so contrary to my experience, that I'll probably (hopefully) never forget it...",
                "_Comentario__fecha": "2011-04-22 09:33:25Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "AndreasT",
                "usuario_id": null
            },
            {
                "_id": 134,
                "_Comentario__descripcion": "@Andreas once you use Python for long enough, you begin to see how logical it is for Python to interpret things as class attributes the way it does - it is only because of the particular quirks and limitations of languages like C++ (and Java, and C#...) that it makes any sense for contents of the class {} block to be interpreted as belonging to the instances :) But when classes are first-class objects, obviously the natural thing is for their contents (in memory) to reflect their contents (in code).",
                "_Comentario__fecha": "2011-07-22 19:55:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Karl Knechtel",
                "usuario_id": null
            },
            {
                "_id": 135,
                "_Comentario__descripcion": "Normative structure is no quirk or limitation in my book. I know it can be clumsy and ugly, but you can call it a \"definition\" of something. The dynamic languages seem a bit like anarchists to me: Sure everybody is free, but you need structure to get someone to empty the trash and pave the road. Guess I'm old... :)",
                "_Comentario__fecha": "2011-07-26 08:54:28Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "AndreasT",
                "usuario_id": null
            },
            {
                "_id": 136,
                "_Comentario__descripcion": "The function definition is executed at module load time. The function body is executed at function call time. The default argument is part of the function definition, not of the function body. (It gets more complicated for nested functions.)",
                "_Comentario__fecha": "2015-03-30 11:28:13Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Lutz Prechelt",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 110,
        "_Respuesta__fecha": "2014-12-19 22:53:35Z",
        "_Respuesta__descripcion": "\nWell, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.\n\nCompare this:\n\nclass BananaBunch:\n    bananas = []\n\n    def addBanana(self, banana):\n        self.bananas.append(banana)\n\n\nThis code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.\n\nIt's just \"How It Works\", and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.\n\nYes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.\n\nThat said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.\n    ",
        "_Respuesta__votes": 88,
        "comentarios": [
            {
                "_id": 137,
                "_Comentario__descripcion": "How do you define a class attribute that is different for each instance of a class?",
                "_Comentario__fecha": "2009-07-15 19:04:39Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Kieveli",
                "usuario_id": null
            },
            {
                "_id": 138,
                "_Comentario__descripcion": "If it's different for each instance it's not a class attribute. Class attributes are attributes on the CLASS. Hence the name. Hence they are the same for all instances.",
                "_Comentario__fecha": "2009-07-15 19:17:21Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Lennart Regebro",
                "usuario_id": null
            },
            {
                "_id": 139,
                "_Comentario__descripcion": "How do you define an attribute in a class that is different for each instance of a class? (Re-defined for those who could not determine that a person not familiar with Python's naming convenctions might be asking about normal member variables of a class).",
                "_Comentario__fecha": "2009-07-16 14:03:46Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Kieveli",
                "usuario_id": null
            },
            {
                "_id": 140,
                "_Comentario__descripcion": "@Kievieli: You ARE talking about normal member variables of a class. :-)  You define instance attributes by saying self.attribute = value in any method. For example __init__().",
                "_Comentario__fecha": "2009-07-16 14:14:18Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Lennart Regebro",
                "usuario_id": null
            },
            {
                "_id": 141,
                "_Comentario__descripcion": "@Kieveli: Two answers:  you can't, because any thing you define at a class level will be a class attribute, and any instance that accesses that attribute will access the same class attribute; you can, /sort of/, by using propertys -- which are actually class level functions that act like normal attributes but save the attribute in the instance instead of the class (by using self.attribute = value as Lennart said).",
                "_Comentario__fecha": "2012-01-07 04:45:56Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ethan Furman",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 111,
        "_Respuesta__fecha": "2018-10-11 16:33:49Z",
        "_Respuesta__descripcion": "\nWhy don't you introspect?\n\nI'm really surprised no one has performed the insightful introspection offered by Python (2 and 3 apply) on callables. \n\nGiven a simple little function func defined as:\n\n>>> def func(a = []):\n...    a.append(5)\n\n\nWhen Python encounters it, the first thing it will do is compile it in order to create a code object for this function. While this compilation step is done, Python evaluates* and then stores the default arguments (an empty list [] here) in the function object itself. As the top answer mentioned: the list a can now be considered a member of the function func.\n\nSo, let's do some introspection, a before and after to examine how the list gets expanded inside the function object. I'm using Python 3.x for this, for Python 2 the same applies (use __defaults__ or func_defaults in Python 2; yes, two names for the same thing).\n\nFunction Before Execution:\n\n>>> def func(a = []):\n...     a.append(5)\n...     \n\n\nAfter Python executes this definition it will take any default parameters specified (a = [] here) and cram them in the __defaults__ attribute for the function object (relevant section: Callables):     \n\n>>> func.__defaults__\n([],)\n\n\nO.k, so an empty list as the single entry in __defaults__, just as expected. \n\nFunction After Execution:\n\nLet's now execute this function:\n\n>>> func()\n\n\nNow, let's see those __defaults__ again: \n\n>>> func.__defaults__\n([5],)\n\n\nAstonished? The value inside the object changes! Consecutive calls to the function will now simply append to that embedded list object:\n\n>>> func(); func(); func()\n>>> func.__defaults__\n([5, 5, 5, 5],)\n\n\nSo, there you have it, the reason why this 'flaw' happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.\n\nThe common solution to combat this is to use None as the default and then initialize in the function body:\n\ndef func(a = None):\n    # or: a = [] if a is None else a\n    if a is None:\n        a = []\n\n\nSince the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for a.\n\n\n\nTo further verify that the list in __defaults__ is the same as that used in the function func you can just change your function to return the id of the list a used inside the function body. Then, compare it to the list in __defaults__ (position [0] in __defaults__) and you'll see how these are indeed refering to the same list instance:\n\n>>> def func(a = []): \n...     a.append(5)\n...     return id(a)\n>>>\n>>> id(func.__defaults__[0]) == func()\nTrue\n\n\nAll with the power of introspection! \n\n\n\n* To verify that Python evaluates the default arguments during compilation of the function, try executing the following:\n\ndef bar(a=input('Did you just see me without calling the function?')): \n    pass  # use raw_input in Py2\n\n\nas you'll notice, input() is called before the process of building the function and binding it to the name bar is made.\n    ",
        "_Respuesta__votes": 77,
        "comentarios": [
            {
                "_id": 142,
                "_Comentario__descripcion": "Is id(...) needed for that last verification, or would the is operator answer the same question?",
                "_Comentario__fecha": "2016-03-09 08:09:30Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "das-g",
                "usuario_id": null
            },
            {
                "_id": 143,
                "_Comentario__descripcion": "@das-g is would do just fine, I just used id(val) because I think it might be more intuitive.",
                "_Comentario__fecha": "2016-03-09 08:20:27Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Dimitris Fasarakis Hilliard",
                "usuario_id": null
            },
            {
                "_id": 144,
                "_Comentario__descripcion": "Using None as the default severely limits the usefulness of the __defaults__ introspection, so I don't think that works well as a defense of having __defaults__ work the way it does.  Lazy-evaluation would do more to keep function defaults useful from both sides.",
                "_Comentario__fecha": "2019-10-18 05:32:26Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Brilliand",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 112,
        "_Respuesta__fecha": "2021-01-21 12:41:46Z",
        "_Respuesta__descripcion": "\n5 points in defense of Python\n\nSimplicity: The behavior is simple in the following sense:\nMost people fall into this trap only once, not several times.\n\nConsistency: Python always passes objects, not names.\nThe default parameter is, obviously, part of the function\nheading (not the function body). It therefore ought to be evaluated\nat module load time (and only at module load time, unless nested), not\nat function call time.\n\nUsefulness: As Frederik Lundh points out in his explanation\nof \"Default Parameter Values in Python\", the\ncurrent behavior can be quite useful for advanced programming.\n(Use sparingly.)\n\nSufficient documentation: In the most basic Python documentation,\nthe tutorial, the issue is loudly announced as\nan \"Important warning\" in the first subsection of Section\n\"More on Defining Functions\".\nThe warning even uses boldface,\nwhich is rarely applied outside of headings.\nRTFM: Read the fine manual.\n\nMeta-learning: Falling into the trap is actually a very\nhelpful moment (at least if you are a reflective learner),\nbecause you will subsequently better understand the point\n\"Consistency\" above and that will\nteach you a great deal about Python.\n\n\n    ",
        "_Respuesta__votes": 65,
        "comentarios": [
            {
                "_id": 145,
                "_Comentario__descripcion": "It took me a year to find this behavior is messing up my code on production, ended up removing a complete feature until I bumped into this design flaw by chance.  I'm using Django.  Since the staging environment did not have many requests, this bug never had any impact on QA.  When we went live and received many simultaneous requests - some utility functions started overwriting each other's parameters!  Making security holes, bugs and what not.",
                "_Comentario__fecha": "2015-09-05 13:09:46Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "oriadam",
                "usuario_id": null
            },
            {
                "_id": 146,
                "_Comentario__descripcion": "@oriadam, no offense, but I wonder how you learned Python without running into this before.  I am just learning Python now and this possible pitfall is mentioned in the official Python tutorial right alongside the first mention of default arguments.  (As mentioned in point 4 of this answer.)  I suppose the moral is\u2014rather unsympathetically\u2014to read the official docs of the language you use to create production software.",
                "_Comentario__fecha": "2016-08-30 02:26:54Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Wildcard",
                "usuario_id": null
            },
            {
                "_id": 147,
                "_Comentario__descripcion": "Also, it would be surprising (to me) if a function of unknown complexity was called in addition to the function call I am making.",
                "_Comentario__fecha": "2016-09-02 13:26:15Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Vatine",
                "usuario_id": null
            },
            {
                "_id": 148,
                "_Comentario__descripcion": "@oriadam, your company needs code review and actual expert coders in the language they write in by the time they have development, staging and production environments. Newbie bugs and bad code habits should not make it to production code",
                "_Comentario__fecha": "2021-01-04 22:03:04Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Robin De Schepper",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 113,
        "_Respuesta__fecha": "2009-07-16 19:13:35Z",
        "_Respuesta__descripcion": "\nI used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:\n\n1. Performance\n\ndef foo(arg=something_expensive_to_compute())):\n    ...\n\n\nIf call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.\n\n2. Forcing bound parameters\n\nA useful trick is to bind parameters of a lambda to the current binding of a variable when the lambda is created.  For example:\n\nfuncs = [ lambda i=i: i for i in range(10)]\n\n\nThis returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind i to the call-time value of i, so you would get a list of functions that all returned 9.\n\nThe only way to implement this otherwise would be to create a further closure with the i bound, ie:\n\ndef make_func(i): return lambda: i\nfuncs = [make_func(i) for i in range(10)]\n\n\n3. Introspection\n\nConsider the code:\n\ndef foo(a='test', b=100, c=[]):\n   print a,b,c\n\n\nWe can get information about the arguments and defaults using the inspect module, which \n\n>>> inspect.getargspec(foo)\n(['a', 'b', 'c'], None, None, ('test', 100, []))\n\n\nThis information is very useful for things like document generation, metaprogramming, decorators etc.\n\nNow, suppose the behaviour of defaults could be changed so that this is the equivalent of:\n\n_undefined = object()  # sentinel value\n\ndef foo(a=_undefined, b=_undefined, c=_undefined)\n    if a is _undefined: a='test'\n    if b is _undefined: b=100\n    if c is _undefined: c=[]\n\n\nHowever, we've lost the ability to introspect, and see what the default arguments are.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.\n    ",
        "_Respuesta__votes": 64,
        "comentarios": [
            {
                "_id": 149,
                "_Comentario__descripcion": "you could achieve introspection also if for each there was a function to create the default argument instead of a value. the inspect module will just call that function.",
                "_Comentario__fecha": "2009-07-16 10:24:57Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "yairchu",
                "usuario_id": null
            },
            {
                "_id": 150,
                "_Comentario__descripcion": "@SilentGhost:  I'm talking about if the behaviour was changed to recreate it - creating it once is the current behaviour, and why the mutable default problem exists.",
                "_Comentario__fecha": "2009-07-16 10:59:05Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Brian",
                "usuario_id": null
            },
            {
                "_id": 151,
                "_Comentario__descripcion": "@yairchu: That assumes the construction is safe to so (ie has no side effects).  Introspecting the args shouldn't do anything, but evaluating arbitrary code could well end up having an effect.",
                "_Comentario__fecha": "2009-07-16 11:02:31Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Brian",
                "usuario_id": null
            },
            {
                "_id": 152,
                "_Comentario__descripcion": "A different language design often just means writing things differently.  Your first example could easily be written as: _expensive = expensive(); def foo(arg=_expensive), if you specifically don't want it reevaluated.",
                "_Comentario__fecha": "2009-07-16 18:23:28Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Glenn Maynard",
                "usuario_id": null
            },
            {
                "_id": 153,
                "_Comentario__descripcion": "@Glenn - that's what I was referring to with \"cache the variable externally\" - it is a bit more verbose, and you end up with extra variables in your namespace though.",
                "_Comentario__fecha": "2009-07-16 19:04:51Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Brian",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 114,
        "_Respuesta__fecha": "2017-10-24 06:34:34Z",
        "_Respuesta__descripcion": "\nThis behavior is easy explained by:\n\n\nfunction (class etc.) declaration is executed only once, creating all default value objects\neverything is passed by reference\n\n\nSo:\n\ndef x(a=0, b=[], c=[], d=0):\n    a = a + 1\n    b = b + [1]\n    c.append(1)\n    print a, b, c\n\n\n\na doesn't change - every assignment call creates new int object - new object is printed\nb doesn't change - new array is build from default value and printed\nc changes - operation is performed on same object - and it is printed\n\n    ",
        "_Respuesta__votes": 55,
        "comentarios": [
            {
                "_id": 154,
                "_Comentario__descripcion": "(Actually, add is a bad example, but integers being immutable still is my main point.)",
                "_Comentario__fecha": "2009-07-15 23:54:43Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Anon",
                "usuario_id": null
            },
            {
                "_id": 155,
                "_Comentario__descripcion": "Realized it to my chagrin after checking to see that, with b set to [], b.__add__([1]) returns [1] but also leaves b still [] even though lists are mutable.  My bad.",
                "_Comentario__fecha": "2009-07-16 00:03:30Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Anon",
                "usuario_id": null
            },
            {
                "_id": 156,
                "_Comentario__descripcion": "@ANon: there is __iadd__, but it doesn't work with int. Of course. :-)",
                "_Comentario__fecha": "2014-05-08 13:16:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Veky",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 115,
        "_Respuesta__fecha": "2009-07-15 20:18:14Z",
        "_Respuesta__descripcion": "\nWhat you're asking is why this:\n\ndef func(a=[], b = 2):\n    pass\n\n\nisn't internally equivalent to this:\n\ndef func(a=None, b = None):\n    a_default = lambda: []\n    b_default = lambda: 2\n    def actual_func(a=None, b=None):\n        if a is None: a = a_default()\n        if b is None: b = b_default()\n    return actual_func\nfunc = func()\n\n\nexcept for the case of explicitly calling func(None, None), which we'll ignore.\n\nIn other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?\n\nOne answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.\n    ",
        "_Respuesta__votes": 36,
        "comentarios": [
            {
                "_id": 157,
                "_Comentario__descripcion": "It wouldn't need to be a closure - a better way to think of it would simply to make the bytecode creating defaults the first line of code - after all you're compiling the body at that point anyway - there's no real difference between code in the arguments and code in the body.",
                "_Comentario__fecha": "2009-07-16 09:39:20Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Brian",
                "usuario_id": null
            },
            {
                "_id": 158,
                "_Comentario__descripcion": "True, but it would still slow Python down, and it would actually be quite surprising, unless you do the same for class definitions, which would make it stupidly slow as you would have to re-run the whole class definition each time you instantiate a class.  As mentioned, the fix would be more surprising than the problem.",
                "_Comentario__fecha": "2009-07-16 11:49:40Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Lennart Regebro",
                "usuario_id": null
            },
            {
                "_id": 159,
                "_Comentario__descripcion": "Agreed with Lennart.  As Guido is fond of saying, for every language feature or standard library, there's someone out there using it.",
                "_Comentario__fecha": "2009-07-16 13:21:22Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Jason Baker",
                "usuario_id": null
            },
            {
                "_id": 160,
                "_Comentario__descripcion": "Changing it now would be insanity--we're just exploring why it is the way it is.  If it did late default evaluation to begin with, it wouldn't necessarily be surprising.  It's definitely true that such a core a difference of parsing would have sweeping, and probably many obscure, effects on the language as a whole.",
                "_Comentario__fecha": "2009-07-16 18:10:05Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Glenn Maynard",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 116,
        "_Respuesta__fecha": "2017-05-23 11:47:32Z",
        "_Respuesta__descripcion": "\n1)  The so-called problem of \"Mutable Default Argument\" is in general a special example demonstrating that:\n\"All functions with this problem suffer also from similar side effect problem on the actual parameter,\"\nThat is against the rules of functional programming, usually undesiderable and should be fixed both together.\n\nExample:\n\ndef foo(a=[]):                 # the same problematic function\n    a.append(5)\n    return a\n\n>>> somevar = [1, 2]           # an example without a default parameter\n>>> foo(somevar)\n[1, 2, 5]\n>>> somevar\n[1, 2, 5]                      # usually expected [1, 2]\n\n\nSolution:  a copy\nAn absolutely safe solution is to copy or deepcopy the input object first and then to do whatever with the copy.\n\ndef foo(a=[]):\n    a = a[:]     # a copy\n    a.append(5)\n    return a     # or everything safe by one line: \"return a + [5]\"\n\n\nMany builtin mutable types have a copy method like some_dict.copy() or some_set.copy() or can be copied easy like somelist[:] or list(some_list). Every object can be also copied by copy.copy(any_object) or more thorough by copy.deepcopy() (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like \"file\" object and can not be meaningfully reproduced by copy. copying\n\nExample problem for a similar SO question\n\nclass Test(object):            # the original problematic class\n  def __init__(self, var1=[]):\n    self._var1 = var1\n\nsomevar = [1, 2]               # an example without a default parameter\nt1 = Test(somevar)\nt2 = Test(somevar)\nt1._var1.append([1])\nprint somevar                  # [1, 2, [1]] but usually expected [1, 2]\nprint t2._var1                 # [1, 2, [1]] but usually expected [1, 2]\n\n\nIt shouldn't be neither saved in any public attribute of an instance returned by this function. (Assuming that private attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. _var1 is a private attribute )\n\nConclusion:\nInput parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see Wiki about \"side effect\" (The first two paragraphs are relevent in this context.)\n.)\n\n2)\nOnly if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is def ...(var1=None): if var1 is None: var1 = [] More..\n\n3) In some cases is the mutable behavior of default parameters useful.\n    ",
        "_Respuesta__votes": 36,
        "comentarios": [
            {
                "_id": 161,
                "_Comentario__descripcion": "I hope you're aware that Python is not a functional programming language.",
                "_Comentario__fecha": "2014-05-08 13:18:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Veky",
                "usuario_id": null
            },
            {
                "_id": 162,
                "_Comentario__descripcion": "Yes, Python is a multi-paragigm language with some functional features. (\"Don't make every problem look like a nail just because you have a hammer.\") Many of them are in Python best practicies. Python has an interesting HOWTO Functional Programming Other features are closures and currying, not mentioned here.",
                "_Comentario__fecha": "2014-05-08 15:54:34Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "hynekcer",
                "usuario_id": null
            },
            {
                "_id": 163,
                "_Comentario__descripcion": "I'd also add, at this late stage, that Python's assignment semantics have been designed explicitly to avoid data copying where necessary, so the creation of copies (and especially of deep copies) will affect both run-time and memory usage adversely. They should therefore be used only when necessary, but newcomers often have difficulty understanding when that is.",
                "_Comentario__fecha": "2018-01-16 14:27:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "holdenweb",
                "usuario_id": null
            },
            {
                "_id": 164,
                "_Comentario__descripcion": "@holdenweb I agree. A temporary copy is the most usual way and sometimes the only possible way how to protect the original mutable data from an extraneous function that modifies them potentially. Fortunately a function that unreasonably modifies data is considered a bug and therefore uncommon.",
                "_Comentario__fecha": "2018-01-17 21:41:33Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "hynekcer",
                "usuario_id": null
            },
            {
                "_id": 165,
                "_Comentario__descripcion": "I agree with this answer. And I don't understand why the def f( a = None ) construct is recommended when you really mean something else. Copying is ok, because you shouldn't mutate arguments. And when you do if a is None: a = [1, 2, 3], you do copy the list anyway.",
                "_Comentario__fecha": "2018-02-16 16:15:52Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "koddo",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 117,
        "_Respuesta__fecha": "2011-05-23 04:24:30Z",
        "_Respuesta__descripcion": "\nThis actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.\n\n>>> def foo(a):\n    a.append(5)\n    print a\n\n>>> a  = [5]\n>>> foo(a)\n[5, 5]\n>>> foo(a)\n[5, 5, 5]\n>>> foo(a)\n[5, 5, 5, 5]\n>>> foo(a)\n[5, 5, 5, 5, 5]\n\n\nNo default values in sight in this code, but you get exactly the same problem.\n\nThe problem is that foo is modifying a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like append_5; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).\n\nYour original foo, with a default argument, shouldn't be modifying a whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.\n\nIf you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.\n    ",
        "_Respuesta__votes": 30,
        "comentarios": [
            {
                "_id": 166,
                "_Comentario__descripcion": "Although related, I think this is distinct behaviour (as we expect append to change a \"in-place\"). That a default mutable is not re-instantiated on each call is the \"unexpected\" bit... at least for me. :)",
                "_Comentario__fecha": "2012-08-24 12:27:38Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Andy Hayden",
                "usuario_id": null
            },
            {
                "_id": 167,
                "_Comentario__descripcion": "@AndyHayden if the function is expected to modify the argument, why would it make sense to have a default?",
                "_Comentario__fecha": "2017-10-17 13:31:05Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            },
            {
                "_id": 168,
                "_Comentario__descripcion": "@AndyHayden I left my own answer here with an expansion of that sentiment. Let me know what you think. I might add your example of cache={} into it for completeness.",
                "_Comentario__fecha": "2017-10-17 18:02:52Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            },
            {
                "_id": 169,
                "_Comentario__descripcion": "@AndyHayden The point of my answer is that if you are ever astonished by accidentally mutating the default value of an argument, then you have another bug, which is that your code can accidentally mutate a caller's value when the default wasn't used. And note that using None and assigning the real default if the arg is None does not resolve that problem (I consider it an anti pattern for that reason). If you fix the other bug by avoiding mutating argument values whether or not they have defaults then you'll never notice or care about this \"astonishing\" behavior.",
                "_Comentario__fecha": "2017-10-17 21:44:29Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ben",
                "usuario_id": null
            },
            {
                "_id": 170,
                "_Comentario__descripcion": "@AndyHayden And if you're putting self.foo = foo.copy() in there anyway, what harm is it if the default value for foo is []? It's the copy that protects you from mutable argument woes, not setting the default to None when you really want a default of []. Sure you could write if foo is None: self.foo = []; else: self.foo = foo.copy(), but why when you could replace 4 lines with a single line (which is one of the 4 you need anyway), and have the real value of the default argument be clearer in the function definition?",
                "_Comentario__fecha": "2017-10-18 00:51:58Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ben",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 118,
        "_Respuesta__fecha": "2015-03-26 23:14:01Z",
        "_Respuesta__descripcion": "\nAlready busy topic, but from what I read here, the following helped me realizing how it's working internally:\n\ndef bar(a=[]):\n     print id(a)\n     a = a + [1]\n     print id(a)\n     return a\n\n>>> bar()\n4484370232\n4484524224\n[1]\n>>> bar()\n4484370232\n4484524152\n[1]\n>>> bar()\n4484370232 # Never change, this is 'class property' of the function\n4484523720 # Always a new object \n[1]\n>>> id(bar.func_defaults[0])\n4484370232\n\n    ",
        "_Respuesta__votes": 27,
        "comentarios": [
            {
                "_id": 171,
                "_Comentario__descripcion": "actually this might be a bit confusing for newcomers as a = a + [1] overloads a... consider changing it to b = a + [1] ; print id(b) and add a line a.append(2). That will make it more obvious that + on two lists always creates a new list (assigned to b), while a modified a can still have the same id(a).",
                "_Comentario__fecha": "2017-04-08 13:47:17Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "J\u00f6rn Hees",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 119,
        "_Respuesta__fecha": "2013-04-02 21:52:30Z",
        "_Respuesta__descripcion": "\nIt's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?\n\ndef print_tuple(some_tuple=(1,2,3)):\n    print some_tuple\n\nprint_tuple()        #1\nprint_tuple((1,2,3)) #2\n\n\nI'll give you a hint.  Here's the disassembly (see http://docs.python.org/library/dis.html):\n\n#1\n\n0 LOAD_GLOBAL              0 (print_tuple)\n3 CALL_FUNCTION            0\n6 POP_TOP\n7 LOAD_CONST               0 (None)\n10 RETURN_VALUE\n\n\n#2\n\n 0 LOAD_GLOBAL              0 (print_tuple)\n 3 LOAD_CONST               4 ((1, 2, 3))\n 6 CALL_FUNCTION            1\n 9 POP_TOP\n10 LOAD_CONST               0 (None)\n13 RETURN_VALUE\n\n\n\n  I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)\n\n\nAs you can see, there is a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.\n    ",
        "_Respuesta__votes": 26,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 120,
        "_Respuesta__fecha": "2017-12-23 21:18:35Z",
        "_Respuesta__descripcion": "\nPython: The Mutable Default Argument\n\nDefault arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object. \n\nWhen they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.\n\nThey stay mutated because they are the same object each time.\n\nEquivalent code:\n\nSince the list is bound to the function when the function object is compiled and instantiated, this:\n\ndef foo(mutable_default_argument=[]): # make a list the default argument\n    \"\"\"function that uses a list\"\"\"\n\n\nis almost exactly equivalent to this:\n\n_a_list = [] # create a list in the globals\n\ndef foo(mutable_default_argument=_a_list): # make it the default argument\n    \"\"\"function that uses a list\"\"\"\n\ndel _a_list # remove globals name binding\n\n\nDemonstration\n\nHere's a demonstration - you can verify that they are the same object each time they are referenced by \n\n\nseeing that the list is created before the function has finished compiling to a function object,\nobserving that the id is the same each time the list is referenced,\nobserving that the list stays changed when the function that uses it is called a second time,\nobserving the order in which the output is printed from the source (which I conveniently numbered for you):\n\n\nexample.py\n\nprint('1. Global scope being evaluated')\n\ndef create_list():\n    '''noisily create a list for usage as a kwarg'''\n    l = []\n    print('3. list being created and returned, id: ' + str(id(l)))\n    return l\n\nprint('2. example_function about to be compiled to an object')\n\ndef example_function(default_kwarg1=create_list()):\n    print('appending \"a\" in default default_kwarg1')\n    default_kwarg1.append(\"a\")\n    print('list with id: ' + str(id(default_kwarg1)) + \n          ' - is now: ' + repr(default_kwarg1))\n\nprint('4. example_function compiled: ' + repr(example_function))\n\n\nif __name__ == '__main__':\n    print('5. calling example_function twice!:')\n    example_function()\n    example_function()\n\n\nand running it with python example.py:\n\n1. Global scope being evaluated\n2. example_function about to be compiled to an object\n3. list being created and returned, id: 140502758808032\n4. example_function compiled: <function example_function at 0x7fc9590905f0>\n5. calling example_function twice!:\nappending \"a\" in default default_kwarg1\nlist with id: 140502758808032 - is now: ['a']\nappending \"a\" in default default_kwarg1\nlist with id: 140502758808032 - is now: ['a', 'a']\n\n\nDoes this violate the principle of \"Least Astonishment\"?\n\nThis order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected. \n\nThe usual instruction to new Python users:\n\nBut this is why the usual instruction to new users is to create their default arguments like this instead:\n\ndef example_function_2(default_kwarg=None):\n    if default_kwarg is None:\n        default_kwarg = []\n\n\nThis uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, [], as the default.\n\nAs the tutorial section on control flow says:\n\n\n  If you don\u2019t want the default to be shared between subsequent calls,\n  you can write the function like this instead:\n\ndef f(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n\n\n    ",
        "_Respuesta__votes": 25,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 121,
        "_Respuesta__fecha": "2018-05-20 23:22:19Z",
        "_Respuesta__descripcion": "\nThe shortest answer would probably be \"definition is execution\", therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:\n\ndef a(): return []\n\ndef b(x=a()):\n    print x\n\n\nHopefully it's enough to show that not executing the default argument expressions at the execution time of the def statement isn't easy or doesn't make sense, or both.\n\nI agree it's a gotcha when you try to use default constructors, though.\n    ",
        "_Respuesta__votes": 25,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 122,
        "_Respuesta__fecha": "2020-08-27 20:44:25Z",
        "_Respuesta__descripcion": "\nThis behavior is not surprising if you take the following into consideration:\n\nThe behavior of read-only class attributes upon assignment attempts, and that\nFunctions are objects (explained well in the accepted answer).\n\nThe role of (2) has been covered extensively in this thread. (1) is likely the astonishment causing factor, as this behavior is not \"intuitive\" when coming from other languages.\n(1) is described in the Python tutorial on classes. In an attempt to assign a value to a read-only class attribute:\n\n...all variables found outside of the innermost scope are\nread-only (an attempt to write to such a variable will simply create a\nnew local variable in the innermost scope, leaving the identically\nnamed outer variable unchanged).\n\nLook back to the original example and consider the above points:\ndef foo(a=[]):\n    a.append(5)\n    return a\n\nHere foo is an object and a is an attribute of foo (available at foo.func_defs[0]). Since a is a list, a is mutable and is thus a read-write attribute of foo. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.\nCalling foo without overriding a default uses that default's value from foo.func_defs. In this case, foo.func_defs[0] is used for a within function object's code scope. Changes to a change foo.func_defs[0], which is part of the foo object and persists between execution of the code in foo.\nNow, compare this to the example from the documentation on emulating the default argument behavior of other languages, such that the function signature defaults are used every time the function is executed:\ndef foo(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n\nTaking (1) and (2) into account, one can see why this accomplishes the desired behavior:\n\nWhen the foo function object is instantiated, foo.func_defs[0] is set to None, an immutable object.\nWhen the function is executed with defaults (with no parameter specified for L in the function call), foo.func_defs[0] (None) is available in the local scope as L.\nUpon L = [], the assignment cannot succeed at foo.func_defs[0], because that attribute is read-only.\nPer (1), a new local variable also named L is created in the local scope and used for the remainder of the function call. foo.func_defs[0] thus remains unchanged for future invocations of foo.\n\n    ",
        "_Respuesta__votes": 22,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 123,
        "_Respuesta__fecha": "2013-02-28 11:10:16Z",
        "_Respuesta__descripcion": "\nA simple workaround using None\n\n>>> def bar(b, data=None):\n...     data = data or []\n...     data.append(b)\n...     return data\n... \n>>> bar(3)\n[3]\n>>> bar(3)\n[3]\n>>> bar(3)\n[3]\n>>> bar(3, [34])\n[34, 3]\n>>> bar(3, [34])\n[34, 3]\n\n    ",
        "_Respuesta__votes": 21,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 124,
        "_Respuesta__fecha": "2015-09-12 20:41:53Z",
        "_Respuesta__descripcion": "\nI am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).  \n\nAs others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.\n\nWrong Method (probably...):\n\ndef foo(list_arg=[5]):\n    return list_arg\n\na = foo()\na.append(6)\n>>> a\n[5, 6]\n\nb = foo()\nb.append(7)\n# The value of 6 appended to variable 'a' is now part of the list held by 'b'.\n>>> b\n[5, 6, 7]  \n\n# Although 'a' is expecting to receive 6 (the last element it appended to the list),\n# it actually receives the last element appended to the shared list.\n# It thus receives the value 7 previously appended by 'b'.\n>>> a.pop()             \n7\n\n\nYou can verify that they are one and the same object by using id:\n\n>>> id(a)\n5347866528\n\n>>> id(b)\n5347866528\n\n\nPer Brett Slatkin's \"Effective Python: 59 Specific Ways to Write Better Python\", Item 20: Use None and Docstrings to specify dynamic default arguments (p. 48)\n\n\n  The convention for achieving the desired result in Python is to\n  provide a default value of None and to document the actual behaviour\n  in the docstring.\n\n\nThis implementation ensures that each call to the function either receives the default list or else the list passed to the function.\n\nPreferred Method:\n\ndef foo(list_arg=None):\n   \"\"\"\n   :param list_arg:  A list of input values. \n                     If none provided, used a list with a default value of 5.\n   \"\"\"\n   if not list_arg:\n       list_arg = [5]\n   return list_arg\n\na = foo()\na.append(6)\n>>> a\n[5, 6]\n\nb = foo()\nb.append(7)\n>>> b\n[5, 7]\n\nc = foo([10])\nc.append(11)\n>>> c\n[10, 11]\n\n\nThere may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.\n    ",
        "_Respuesta__votes": 19,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 125,
        "_Respuesta__fecha": "2013-06-30 16:20:35Z",
        "_Respuesta__descripcion": "\nThe solutions here are:\n\n\nUse None as your default value (or a nonce object), and switch on that to create your values at runtime; or\nUse a lambda as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).\n\n\nThe second option is nice because users of the function can pass in a callable, which may be already existing (such as a type)\n    ",
        "_Respuesta__votes": 17,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 126,
        "_Respuesta__fecha": "2013-01-15 11:02:03Z",
        "_Respuesta__descripcion": "\nYou can get round this by replacing the object (and therefore the tie with the scope):\n\ndef foo(a=[]):\n    a = list(a)\n    a.append(5)\n    return a\n\n\nUgly, but it works.\n    ",
        "_Respuesta__votes": 16,
        "comentarios": [
            {
                "_id": 172,
                "_Comentario__descripcion": "This is a nice solution in cases where you're using automatic documentation generation software to document the types of arguments expected by the function.  Putting a=None and then setting a to [] if a is None doesn't help a reader understand at a glance what is expected.",
                "_Comentario__fecha": "2013-01-20 06:55:05Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Michael Scott Cuthbert",
                "usuario_id": null
            },
            {
                "_id": 173,
                "_Comentario__descripcion": "Cool idea: rebinding that name guarantees it can never be modified. I really like that.",
                "_Comentario__fecha": "2018-01-16 14:29:04Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "holdenweb",
                "usuario_id": null
            },
            {
                "_id": 174,
                "_Comentario__descripcion": "This is exactly the way to do it. Python doesn't make a copy of the parameter, so it's up to you to make the copy explicitly. Once you have a copy, it's yours to modify as you please without any unexpected side effects.",
                "_Comentario__fecha": "2018-05-25 16:56:48Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 127,
        "_Respuesta__fecha": "2014-09-11 22:05:43Z",
        "_Respuesta__descripcion": "\nWhen we do this:\n\ndef foo(a=[]):\n    ...\n\n\n... we assign the argument a to an unnamed list, if the caller does not pass the value of a.\n\nTo make things simpler for this discussion, let's temporarily give the unnamed list a name. How about pavlo ?\n\ndef foo(a=pavlo):\n   ...\n\n\nAt any time, if the caller doesn't tell us what a is, we reuse pavlo.\n\nIf pavlo is mutable (modifiable), and foo ends up modifying it, an effect we notice the next time foo is called without specifying a.\n\nSo this is what you see (Remember, pavlo is initialized to []):\n\n >>> foo()\n [5]\n\n\nNow, pavlo is [5].\n\nCalling foo() again modifies pavlo again:\n\n>>> foo()\n[5, 5]\n\n\nSpecifying a when calling foo() ensures pavlo is not touched.\n\n>>> ivan = [1, 2, 3, 4]\n>>> foo(a=ivan)\n[1, 2, 3, 4, 5]\n>>> ivan\n[1, 2, 3, 4, 5]\n\n\nSo, pavlo is still [5, 5].\n\n>>> foo()\n[5, 5, 5]\n\n    ",
        "_Respuesta__votes": 16,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 128,
        "_Respuesta__fecha": "2015-02-06 12:56:53Z",
        "_Respuesta__descripcion": "\nI sometimes exploit this behavior as an alternative to the following pattern:\n\nsingleton = None\n\ndef use_singleton():\n    global singleton\n\n    if singleton is None:\n        singleton = _make_singleton()\n\n    return singleton.use_me()\n\n\nIf singleton is only used by use_singleton, I like the following pattern as a replacement:\n\n# _make_singleton() is called only once when the def is executed\ndef use_singleton(singleton=_make_singleton()):\n    return singleton.use_me()\n\n\nI've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.\n\nSince I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.\n    ",
        "_Respuesta__votes": 16,
        "comentarios": [
            {
                "_id": 175,
                "_Comentario__descripcion": "I prefer to add a decorator for memoization, and put the memoization cache onto the function object itself.",
                "_Comentario__fecha": "2015-02-06 07:34:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Stefano Borini",
                "usuario_id": null
            },
            {
                "_id": 176,
                "_Comentario__descripcion": "This example doesn't replace the more complex pattern you show, because you call _make_singleton at def time in the default argument example, but at call time in the global example. A true substitution would use some sort of mutable box for the default argument value, but the addition of the argument makes an opportunity to pass alternate values.",
                "_Comentario__fecha": "2017-11-19 08:29:15Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Yann Vernier",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 129,
        "_Respuesta__fecha": "2009-07-16 19:17:59Z",
        "_Respuesta__descripcion": "\nIt may be true that:\n\n\nSomeone is using every language/library feature, and\nSwitching the behavior here would be ill-advised, but\n\n\nit is entirely consistent to hold to both of the features above and still make another point:\n\n\nIt is a confusing feature and it is unfortunate in Python.\n\n\nThe other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. But all three are true.\n\nIt may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. However,\n\nThe existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere near this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it Just Works.\n    ",
        "_Respuesta__votes": 15,
        "comentarios": [
            {
                "_id": 177,
                "_Comentario__descripcion": "-1 Although a defensible perspective, this not an answer, and I disagree with it. Too many special exceptions beget their own corner cases.",
                "_Comentario__fecha": "2012-07-07 19:24:33Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Marcin",
                "usuario_id": null
            },
            {
                "_id": 178,
                "_Comentario__descripcion": "So then, it is \"amazingly ignorant\" to say that in Python it would make more sense for a default argument of [] to remain [] every time the function is called?",
                "_Comentario__fecha": "2012-12-27 22:09:35Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Christos Hayward",
                "usuario_id": null
            },
            {
                "_id": 179,
                "_Comentario__descripcion": "And it is ignorant to consider as an unfortunate idiom setting a default argument to None, and then in the body of the body of the function setting if argument == None: argument = []? Is it ignorant to consider this idiom unfortunate as often people want what a naive newcomer would expect, that if you assign f(argument = []), argument will automatically default to a value of []?",
                "_Comentario__fecha": "2012-12-27 22:11:58Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Christos Hayward",
                "usuario_id": null
            },
            {
                "_id": 180,
                "_Comentario__descripcion": "But in Python, part of the spirit of the language is that you don't have to take too many deep dives; array.sort() works, and works  regardless of how little you understand about sorting, big-O, and constants. The beauty of Python in the array sorting mechanism, to give one of innumerable examples, is that you are not required to take a deep dive into internals. And to say it differently, the beauty of Python is that one is not ordinarily required to take a deep dive into implementation to get something that Just Works. And there is a workaround (...if argument == None: argument = []), FAIL.",
                "_Comentario__fecha": "2012-12-27 22:41:56Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Christos Hayward",
                "usuario_id": null
            },
            {
                "_id": 181,
                "_Comentario__descripcion": "As a standalone, the statement x=[] means \"create an empty list object, and bind the name 'x' to it.\"  So, in def f(x=[]), an empty list is also created.  It doesn't always get bound to x, so instead it gets bound to the default surrogate.  Later when f() is called, the default is hauled out and bound to x.  Since it was the empty list itself that was squirreled away, that same list is the only thing available to bind to x, whether anything has been stuck inside it or not.  How could it be otherwise?",
                "_Comentario__fecha": "2013-10-05 06:18:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Jerry B",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 130,
        "_Respuesta__fecha": "2013-07-23 10:07:58Z",
        "_Respuesta__descripcion": "\nThis \"bug\" gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)\n\nI'm gonna give you what I see as a useful example.\n\ndef example(errors=[]):\n    # statements\n    # Something went wrong\n    mistake = True\n    if mistake:\n        tryToFixIt(errors)\n        # Didn't work.. let's try again\n        tryToFixItAnotherway(errors)\n        # This time it worked\n    return errors\n\ndef tryToFixIt(err):\n    err.append('Attempt to fix it')\n\ndef tryToFixItAnotherway(err):\n    err.append('Attempt to fix it by another way')\n\ndef main():\n    for item in range(2):\n        errors = example()\n    print '\\n'.join(errors)\n\nmain()\n\n\nprints the following\n\nAttempt to fix it\nAttempt to fix it by another way\nAttempt to fix it\nAttempt to fix it by another way\n\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [
            {
                "_id": 182,
                "_Comentario__descripcion": "Your example doesn't seem very realistic.  Why would you pass errors as a parameter rather than starting from scratch every time?",
                "_Comentario__fecha": "2021-05-25 23:39:48Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 131,
        "_Respuesta__fecha": "2017-10-17 18:04:59Z",
        "_Respuesta__descripcion": "\nThis is not a design flaw. Anyone who trips over this is doing something wrong.\n\nThere are 3 cases I see where you might run into this problem:\n\n\nYou intend to modify the argument as a side effect of the function. In this case it never makes sense to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. cache={}, and you wouldn't be expected to call the function with an actual argument at all.\nYou intend to leave the argument unmodified, but you accidentally did modify it. That's a bug, fix it.\nYou intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a copy of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.\n\n\nThe example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [
            {
                "_id": 183,
                "_Comentario__descripcion": "\"Doing something wrong\" is the diagnosis. That said, I think there are times were =None pattern is useful, but generally you don't want to modify if passed a mutable in that case (2). The cache={} pattern is really an interview-only solution, in real code you probably want @lru_cache!",
                "_Comentario__fecha": "2017-10-17 18:19:46Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Andy Hayden",
                "usuario_id": null
            },
            {
                "_id": 184,
                "_Comentario__descripcion": "Totally disagree, its absolutely a design flaw in many cases and not the programmer doing something wong",
                "_Comentario__fecha": "2021-05-25 10:44:49Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "aCuria",
                "usuario_id": null
            },
            {
                "_id": 185,
                "_Comentario__descripcion": "@aCuria so you have a case 4 that's different from the 3 I presented?  I'd love to hear about it, please tell me more.  Python's behavior may not make sense in this circumstance, but it's very useful in other places and to change it would be a disaster.",
                "_Comentario__fecha": "2021-05-25 13:04:18Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            },
            {
                "_id": 186,
                "_Comentario__descripcion": "I have never run into the problem of the OP even though it is so highly upvoted, because having a default argument be mutable is weird design to me.",
                "_Comentario__fecha": "2021-05-25 19:56:36Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "qwr",
                "usuario_id": null
            },
            {
                "_id": 187,
                "_Comentario__descripcion": "@MarkRansom If we take it as given that side effects are OK, there's nothing wrong with modifying a default argument as part of a side-effect-ful function. Let's say you have a function that does something to a list and returns the list. We want to ensure that the function always returns a list. Then having an empty (or non-empty) list as a default makes perfect sense. The language is violating a large proportion of new Python programmers' expectations. Why are they wrong and the language right? Would you be making the opposite argument if the language had the opposite behavior?",
                "_Comentario__fecha": "2021-06-03 14:05:01Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Clement Cherlin",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 132,
        "_Respuesta__fecha": "2018-09-06 21:29:08Z",
        "_Respuesta__descripcion": "\nJust change the function to be:\n\ndef notastonishinganymore(a = []): \n    '''The name is just a joke :)'''\n    a = a[:]\n    a.append(5)\n    return a\n\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 133,
        "_Respuesta__fecha": "2019-01-03 07:38:50Z",
        "_Respuesta__descripcion": "\nEvery other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.\n\nWe will \"fix\" this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.\n\n\n\nimport inspect\nfrom copy import copy\n\ndef sanify(function):\n    def wrapper(*a, **kw):\n        # store the default values\n        defaults = inspect.getargspec(function).defaults # for python2\n        # construct a new argument list\n        new_args = []\n        for i, arg in enumerate(defaults):\n            # allow passing positional arguments\n            if i in range(len(a)):\n                new_args.append(a[i])\n            else:\n                # copy the value\n                new_args.append(copy(arg))\n        return function(*new_args, **kw)\n    return wrapper\n\n\nNow let's redefine our function using this decorator:\n\n@sanify\ndef foo(a=[]):\n    a.append(5)\n    return a\n\nfoo() # '[5]'\nfoo() # '[5]' -- as desired\n\n\nThis is particularly neat for functions that take multiple arguments. Compare:\n\n# the 'correct' approach\ndef bar(a=None, b=None, c=None):\n    if a is None:\n        a = []\n    if b is None:\n        b = []\n    if c is None:\n        c = []\n    # finally do the actual work\n\n\nwith\n\n# the nasty decorator hack\n@sanify\ndef bar(a=[], b=[], c=[]):\n    # wow, works right out of the box!\n\n\nIt's important to note that the above solution breaks if you try to use keyword args, like so:\n\nfoo(a=[4])\n\n\nThe decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 134,
        "_Respuesta__fecha": "2019-08-08 07:39:43Z",
        "_Respuesta__descripcion": "\nTLDR: Define-time defaults are consistent and strictly more expressive.\n\n\n\nDefining a function affects two scopes: the defining scope containing the function, and the execution  scope contained by the function. While it is pretty clear how blocks map to scopes, the question is where def <name>(<args=defaults>): belongs to:\n\n...                           # defining scope\ndef name(parameter=default):  # ???\n    ...                       # execution scope\n\n\nThe def name part must evaluate in the defining scope - we want name to be available there, after all. Evaluating the function only inside itself would make it inaccessible.\n\nSince parameter is a constant name, we can \"evaluate\" it at the same time as def name. This also has the advantage it produces the function with a known signature as name(parameter=...):, instead of a bare name(...):.\n\nNow, when to evaluate default?\n\nConsistency already says \"at definition\": everything else of def <name>(<args=defaults>): is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.\n\nThe two choices are not equivalent, either: If default is evaluated at definition time, it can still affect execution time. If default is evaluated at execution time, it cannot affect definition time. Choosing \"at definition\" allows expressing both cases, while choosing \"at execution\" can express only one:\n\ndef name(parameter=defined):  # set default at definition time\n    ...\n\ndef name(parameter=default):     # delay default until execution time\n    parameter = default if parameter is None else parameter\n    ...\n\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [
            {
                "_id": 188,
                "_Comentario__descripcion": "\"Consistency already says \"at definition\": everything else of def <name>(<args=defaults>): is best evaluated at definition as well.\" I don't think the conclusion follows from the premise. Just because two things are on the same line doesn't mean they should be evaluated in the same scope. default is a different thing than the rest of the line: it's an expression. Evaluating an expression is a very different process from defining a function.",
                "_Comentario__fecha": "2019-09-23 14:38:21Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "LarsH",
                "usuario_id": null
            },
            {
                "_id": 189,
                "_Comentario__descripcion": "@LarsH Function definitions are are evaluated in Python. Whether that is from a statement (def) or expression (lambda) does not change that creating a function means evaluation -- especially of its signature. And defaults are part of a function's signature. That does not mean defaults have to be evaluated immediately -- type hints may not, for example. But it certainly suggests they should unless there is a good reason not to.",
                "_Comentario__fecha": "2019-09-23 15:22:41Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "MisterMiyagi",
                "usuario_id": null
            },
            {
                "_id": 190,
                "_Comentario__descripcion": "OK, creating a function means evaluation in some sense, but obviously not in the sense that every expression within it is evaluated at the time of definition. Most aren't. It's not clear to me in what sense the signature is especially \"evaluated\" at definition time any more than the function body is \"evaluated\" (parsed into a suitable representation); whereas expressions in the function body are clearly not evaluated in the full sense. From this point of view, consistency would say that expressions in the signature shouldn't be \"fully\" evaluated either.",
                "_Comentario__fecha": "2019-09-24 15:09:18Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "LarsH",
                "usuario_id": null
            },
            {
                "_id": 191,
                "_Comentario__descripcion": "I don't mean that you're wrong, only that your conclusion doesn't follow from consistency alone.",
                "_Comentario__fecha": "2019-09-24 15:09:22Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "LarsH",
                "usuario_id": null
            },
            {
                "_id": 192,
                "_Comentario__descripcion": "@LarsH Defaults are neither part of the body, nor am I claiming that consistency is the only criteria. Can you make a suggestion how to clarify the answer?",
                "_Comentario__fecha": "2019-09-24 15:15:33Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "MisterMiyagi",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 135,
        "_Respuesta__fecha": "2013-08-22 05:58:41Z",
        "_Respuesta__descripcion": "\nI think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the \"def\" statement.\n\nA brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.\n\nAdmitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that \"def\" statement is executed only once when it is defined.\n\n[] is an object, so python pass the reference of [] to a, i.e., a is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to 1 by append method. But Note that there is only one copy of the list object and this object now becomes 1. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. a is evaluated to be the list object, although now the content of the object is 1. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.\n\nTo further validate my answer, let's take a look at two additional codes.\n\n====== No. 2 ========\n\ndef foo(x, items=None):\n    if items is None:\n        items = []\n    items.append(x)\n    return items\n\nfoo(1)  #return [1]\nfoo(2)  #return [2]\nfoo(3)  #return [3]\n\n\n[] is an object, so is None (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address. \n\n====== No. 3 =======\n\ndef foo(x, items=[]):\n    items.append(x)\n    return items\n\nfoo(1)    # returns [1]\nfoo(2,[]) # returns [2]\nfoo(3)    # returns [1,3]\n\n\nThe invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to 1 in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, items has to take the address of this new [], say 2222222, and return it after making some change. Now foo(3) is executed. since only x is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make items [1,3]. \n\nFrom the above explanations, we can see that the effbot webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:\n\nfor i in range(10):\n    def callback():\n        print \"clicked button\", i\n    UI.Button(\"button %s\" % i, callback)\n\n\nEach button can hold a distinct callback function which will display different value of i. I can provide an example to show this:\n\nx=[]\nfor i in range(10):\n    def callback():\n        print(i)\n    x.append(callback) \n\n\nIf we execute x[7]() we'll get 7 as expected, and x[9]() will gives 9, another value of i.\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [
            {
                "_id": 193,
                "_Comentario__descripcion": "Your last point is wrong. Try it and you'll see that x[7]() is 9.",
                "_Comentario__fecha": "2013-10-02 13:29:23Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Duncan",
                "usuario_id": null
            },
            {
                "_id": 194,
                "_Comentario__descripcion": "\"python pass elementary data type by value, i.e., make a local copy of the value to a local variable\" is completely incorrect. I am astonished that someone can obviously know Python very well, yet have such horrible misunderstanding of fundamentals. :-(",
                "_Comentario__fecha": "2014-11-19 09:07:54Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Veky",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 137,
        "_Respuesta__fecha": "2020-01-18 21:04:41Z",
        "_Respuesta__descripcion": "\nWhen you write [x]*3 you get, essentially, the list [x, x, x]. That is, a list with 3 references to the same x. When you then modify this single x it is visible via all three references to it:\n\nx = [1] * 4\nl = [x] * 3\nprint(f\"id(x): {id(x)}\")\n# id(x): 140560897920048\nprint(\n    f\"id(l[0]): {id(l[0])}\\n\"\n    f\"id(l[1]): {id(l[1])}\\n\"\n    f\"id(l[2]): {id(l[2])}\"\n)\n# id(l[0]): 140560897920048\n# id(l[1]): 140560897920048\n# id(l[2]): 140560897920048\n\nx[0] = 42\nprint(f\"x: {x}\")\n# x: [42, 1, 1, 1]\nprint(f\"l: {l}\")\n# l: [[42, 1, 1, 1], [42, 1, 1, 1], [42, 1, 1, 1]]\n\n\nTo fix it, you need to make sure that you create a new list at each position. One way to do it is\n\n[[1]*4 for _ in range(3)]\n\n\nwhich will reevaluate [1]*4 each time instead of evaluating it once and making 3 references to 1 list.\n\n\n\nYou might wonder why * can't make independent objects the way the list comprehension does. That's because the multiplication operator * operates on objects, without seeing expressions. When you use * to multiply [[1] * 4] by 3, * only sees the 1-element list [[1] * 4] evaluates to, not the [[1] * 4 expression text. * has no idea how to make copies of that element, no idea how to reevaluate [[1] * 4], and no idea you even want copies, and in general, there might not even be a way to copy the element.\n\nThe only option * has is to make new references to the existing sublist instead of trying to make new sublists. Anything else would be inconsistent or require major redesigning of fundamental language design decisions.\n\nIn contrast, a list comprehension reevaluates the element expression on every iteration. [[1] * 4 for n in range(3)] reevaluates [1] * 4 every time for the same reason [x**2 for x in range(3)] reevaluates x**2 every time. Every evaluation of [1] * 4 generates a new list, so the list comprehension does what you wanted.\n\nIncidentally, [1] * 4 also doesn't copy the elements of [1], but that doesn't matter, since integers are immutable. You can't do something like 1.value = 2 and turn a 1 into a 2.\n    ",
        "_Respuesta__votes": 686,
        "comentarios": [
            {
                "_id": 203,
                "_Comentario__descripcion": "I am surprised that no body points out  that, the answer here is misleading. [x]*3 store 3 references like [x, x, x] is only right when x is mutable. This does't work for e.g. a=[4]*3, where after a[0]=5, a=[5,4,4].",
                "_Comentario__fecha": "2015-05-22 00:16:41Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Allanqunzi",
                "usuario_id": null
            },
            {
                "_id": 204,
                "_Comentario__descripcion": "Technically, it's still correct. [4]*3 is essentially equivalent to x = 4; [x, x, x]. It's true, though, that this will never cause any problem since 4 is immutable. Also, your other example isn't really a different case. a = [x]*3; a[0] = 5 won't cause problems even if x is mutable, since you're not modifying x, only modifying a. I wouldn't describe my answer as misleading or incorrect - you just can't shoot yourself in the foot if you're dealing with immutable objects.",
                "_Comentario__fecha": "2015-05-22 08:04:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "CAdaker",
                "usuario_id": null
            },
            {
                "_id": 205,
                "_Comentario__descripcion": "@Allanqunzi you are wrong. Do x = 1000; lst = [x]*2; lst[0] is lst[1] -> True. Python does not distinguish between mutable and immutable objects here whatsoever.",
                "_Comentario__fecha": "2016-04-17 18:08:26Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "timgeb",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 138,
        "_Respuesta__fecha": "2021-06-18 17:12:23Z",
        "_Respuesta__descripcion": "\nsize = 3\nmatrix_surprise = [[0] * size] * size\nmatrix = [[0]*size for _ in range(size)]\n\nLive visualization using Python Tutor:\n\n    ",
        "_Respuesta__votes": 149,
        "comentarios": [
            {
                "_id": 206,
                "_Comentario__descripcion": "So, why if we write matrix= [[x] * 2] doesn't make 2 elemnts for the same object like the example you describe, it seems to be the same concept, what am i missing?",
                "_Comentario__fecha": "2017-07-01 17:55:18Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ahmed Mohamed",
                "usuario_id": null
            },
            {
                "_id": 207,
                "_Comentario__descripcion": "@AhmedMohamed Indeed it does make a list with two elements of the exact same object that x refers to. If you make a globally unique object with  x = object() and then make matrix = [[x] * 2] these does come as true: matrix[0][0] is matrix[0][1]",
                "_Comentario__fecha": "2017-07-02 13:13:23Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "nadrimajstor",
                "usuario_id": null
            },
            {
                "_id": 208,
                "_Comentario__descripcion": "@nadrimajstor so why the change in matrix[0] doesn't affect matrix[1] like the example above with 2d matrix.",
                "_Comentario__fecha": "2017-07-02 13:31:54Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ahmed Mohamed",
                "usuario_id": null
            },
            {
                "_id": 209,
                "_Comentario__descripcion": "@AhmedMohamed Surprise come when you make a \"copy\" of mutable sequence (in our example it is a list) so if a row = [x] * 2 than a matrix = [row] * 2 where both rows are exactly the same object, and now changes to one row matrix[0][0] = y suddenly reflect in the other one (matrix[0][0] is matrix[1][0]) == True",
                "_Comentario__fecha": "2017-07-02 15:44:00Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "nadrimajstor",
                "usuario_id": null
            },
            {
                "_id": 210,
                "_Comentario__descripcion": "@AhmedMohamed Take a look at Ned Batchelder - Facts and Myths about Python names and values as it might offer a better explanation. :)",
                "_Comentario__fecha": "2017-07-02 16:11:30Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "nadrimajstor",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 139,
        "_Respuesta__fecha": "2021-06-18 16:49:18Z",
        "_Respuesta__descripcion": "\nActually, this is exactly what you would expect. Let's decompose what is happening here:\nYou write\nlst = [[1] * 4] * 3\n\nThis is equivalent to:\nlst1 = [1]*4\nlst = [lst1]*3\n\nThis means lst is a list with 3 elements all pointing to lst1. This means the two following lines are equivalent:\nlst[0][0] = 5\nlst1[0] = 5\n\nAs lst[0] is nothing but lst1.\nTo obtain the desired behavior, you can use a list comprehension:\nlst = [ [1]*4 for n in range(3) ]\n\nIn this case, the expression is re-evaluated for each n, leading to a different list.\n    ",
        "_Respuesta__votes": 62,
        "comentarios": [
            {
                "_id": 211,
                "_Comentario__descripcion": "Just a small addition to the nice answer here: it's evident that you're dealing with same object if you do id(lst[0][0]) and id(lst[1][0]) or even id(lst[0]) and id(lst[1])",
                "_Comentario__fecha": "2017-05-17 07:08:16Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Sergiy Kolodyazhnyy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 140,
        "_Respuesta__fecha": "2017-01-14 07:54:00Z",
        "_Respuesta__descripcion": "\n[[1] * 4] * 3\n\n\nor even:\n\n[[1, 1, 1, 1]] * 3\n\n\nCreates a list that references the internal [1,1,1,1] 3 times - not three copies of the inner list, so any time you modify the list (in any position), you'll see the change three times.\n\nIt's the same as this example:\n\n>>> inner = [1,1,1,1]\n>>> outer = [inner]*3\n>>> outer\n[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n>>> inner[0] = 5\n>>> outer\n[[5, 1, 1, 1], [5, 1, 1, 1], [5, 1, 1, 1]]\n\n\nwhere it's probably a little less surprising.\n    ",
        "_Respuesta__votes": 41,
        "comentarios": [
            {
                "_id": 212,
                "_Comentario__descripcion": "You can use the \"is\" operator to discover this. ls[0] is ls[1] returns True.",
                "_Comentario__fecha": "2008-10-27 15:03:52Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "mipadi",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 141,
        "_Respuesta__fecha": "2021-06-18 17:26:13Z",
        "_Respuesta__descripcion": "\nAlongside the accepted answer that explained the problem correctly, instead of creating a list with duplicated elements using following code:\n[[1]*4 for _ in range(3)]\n\nAlso, you can use itertools.repeat() to create an iterator object of repeated elements:\n>>> a = list(repeat(1,4))\n[1, 1, 1, 1]\n>>> a[0] = 5\n>>> a\n[5, 1, 1, 1]\n\nP.S. If you're using NumPy and you only want to create an array of ones or zeroes you can use np.ones and np.zeros and/or for other numbers use np.repeat:\n>>> import numpy as np\n>>> np.ones(4)\narray([1., 1., 1., 1.])\n>>> np.ones((4, 2))\narray([[1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.]])\n>>> np.zeros((4, 2))\narray([[0., 0.],\n       [0., 0.],\n       [0., 0.],\n       [0., 0.]])\n>>> np.repeat([7], 10)\narray([7, 7, 7, 7, 7, 7, 7, 7, 7, 7])\n\n    ",
        "_Respuesta__votes": 10,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 142,
        "_Respuesta__fecha": "2021-06-18 16:32:37Z",
        "_Respuesta__descripcion": "\nmy_list = [[1]*4] * 3 creates one list object [1,1,1,1] in memory and copies its reference 3 times over. This is equivalent to obj = [1,1,1,1]; my_list = [obj]*3. Any modification to obj will be reflected at three places, wherever obj is referenced in the list.\nThe right statement would be:\nmy_list = [[1]*4 for _ in range(3)]\n\nor\nmy_list = [[1 for __ in range(4)] for _ in range(3)]\n\nImportant thing to note here is that the * operator is mostly used to create a list of literals. Although 1 is immutable, obj = [1]*4 will still create a list of 1 repeated 4 times over to form [1,1,1,1]. But if any reference to an immutable object is made, the object is overwritten with a new one.\nThis means if we do obj[1] = 42, then obj will become [1,42,1,1] not [42,42,42,42] as some may assume. This can also be verified:\n>>> my_list = [1]*4\n>>> my_list\n[1, 1, 1, 1]\n\n>>> id(my_list[0])\n4522139440\n>>> id(my_list[1])  # Same as my_list[0]\n4522139440\n\n\n>>> my_list[1] = 42  # Since my_list[1] is immutable, this operation overwrites my_list[1] with a new object changing its id.\n>>> my_list\n[1, 42, 1, 1]\n\n>>> id(my_list[0])\n4522139440\n>>> id(my_list[1])  # id changed\n4522140752\n>>> id(my_list[2])  # id still same as my_list[0], still referring to value `1`.\n4522139440\n\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [
            {
                "_id": 213,
                "_Comentario__descripcion": "It's not about literals. obj[2] = 42 replaces the reference at index 2, as opposed to mutating the object referenced by that index, which is what myList[2][0] = ... does (myList[2] is a list, and the assigment alters the reference at index 0 in tha list). Of course, integers are not mutable, but plenty of object types are. And note that the [....] list display notation is also a form of literal syntax! Don't confuse compound (such as lists) and scalar objects (such as integers), with mutable vs. immutable objects.",
                "_Comentario__fecha": "2018-07-25 15:52:05Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Martijn Pieters\u2666",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 143,
        "_Respuesta__fecha": "2016-04-06 13:40:43Z",
        "_Respuesta__descripcion": "\nPython containers contain references to other objects. See this example:\n\n>>> a = []\n>>> b = [a]\n>>> b\n[[]]\n>>> a.append(1)\n>>> b\n[[1]]\n\n\nIn this b is a list that contains one item that is a reference to list a. The list a is mutable.\n\nThe multiplication of a list by an integer is equivalent to adding the list to itself multiple times (see common sequence operations). So continuing with the example:\n\n>>> c = b + b\n>>> c\n[[1], [1]]\n>>>\n>>> a[0] = 2\n>>> c\n[[2], [2]]\n\n\nWe can see that the list c now contains two references to list a which is equivalent to c = b * 2.\n\nPython FAQ also contains explanation of this behavior: How do I create a multidimensional list?\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 144,
        "_Respuesta__fecha": "2021-06-18 16:36:25Z",
        "_Respuesta__descripcion": "\nLet's rewrite your code in the following way:\nx = 1\ny = [x]\nz = y * 4\n\nmy_list = [z] * 3\n\nThen having this, run the following code to make everything more clear. What the code does is basically print the ids of the obtained objects, which\n\nReturn[s] the \u201cidentity\u201d of an object\n\nand will help us identify them and analyse what happens:\nprint(\"my_list:\")\nfor i, sub_list in enumerate(my_list):\n    print(\"\\t[{}]: {}\".format(i, id(sub_list)))\n    for j, elem in enumerate(sub_list):\n        print(\"\\t\\t[{}]: {}\".format(j, id(elem)))\n\nAnd you will get the following output:\nx: 1\ny: [1]\nz: [1, 1, 1, 1]\nmy_list:\n    [0]: 4300763792\n        [0]: 4298171528\n        [1]: 4298171528\n        [2]: 4298171528\n        [3]: 4298171528\n    [1]: 4300763792\n        [0]: 4298171528\n        [1]: 4298171528\n        [2]: 4298171528\n        [3]: 4298171528\n    [2]: 4300763792\n        [0]: 4298171528\n        [1]: 4298171528\n        [2]: 4298171528\n        [3]: 4298171528\n\n\nSo now let's go step-by-step. You have x which is 1, and a single element list y containing x. Your first step is y * 4 which will get you a new list z, which is basically [x, x, x, x], i.e. it creates a new list which will have 4 elements, which are references to the initial x object. The next step is pretty similar. You basically do z * 3, which is [[x, x, x, x]] * 3 and returns [[x, x, x, x], [x, x, x, x], [x, x, x, x]], for the same reason as for the first step.\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 145,
        "_Respuesta__fecha": "2016-06-14 06:36:52Z",
        "_Respuesta__descripcion": "\nIn simple words this is happening because in python everything works by reference, so when you create a list of list that way you basically end up with such problems.\n\nTo solve your issue you can do either one of them:\n1. Use numpy array documentation for numpy.empty\n2. Append the list as you get to a list.\n3. You can also use dictionary if you want  \n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 146,
        "_Respuesta__fecha": "2021-06-18 16:39:24Z",
        "_Respuesta__descripcion": "\nEveryone is explaining what is happening. I'll suggest one way to solve it:\nmy_list = [[1 for i in range(4)] for j in range(3)]\n\nmy_list[0][0] = 5\nprint(my_list)\n\nAnd then you get:\n[[5, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 147,
        "_Respuesta__fecha": "2016-08-10 07:29:38Z",
        "_Respuesta__descripcion": "\nTrying to explain it more descriptively,\n\nOperation 1:\n\nx = [[0, 0], [0, 0]]\nprint(type(x)) # <class 'list'>\nprint(x) # [[0, 0], [0, 0]]\n\nx[0][0] = 1\nprint(x) # [[1, 0], [0, 0]]\n\n\nOperation 2:\n\ny = [[0] * 2] * 2\nprint(type(y)) # <class 'list'>\nprint(y) # [[0, 0], [0, 0]]\n\ny[0][0] = 1\nprint(y) # [[1, 0], [1, 0]]\n\n\nNoticed why doesn't modifying the first element of the first list didn't modify the second element of each list? That's because [0] * 2 really is a list of two numbers, and a reference to 0 cannot be modified.\n\nIf you want to create clone copies, try Operation 3:\n\nimport copy\ny = [0] * 2   \nprint(y)   # [0, 0]\n\ny = [y, copy.deepcopy(y)]  \nprint(y) # [[0, 0], [0, 0]]\n\ny[0][0] = 1\nprint(y) # [[1, 0], [0, 0]]\n\n\nanother interesting way to create clone copies, Operation 4:\n\nimport copy\ny = [0] * 2\nprint(y) # [0, 0]\n\ny = [copy.deepcopy(y) for num in range(1,5)]\nprint(y) # [[0, 0], [0, 0], [0, 0], [0, 0]]\n\ny[0][0] = 5\nprint(y) # [[5, 0], [0, 0], [0, 0], [0, 0]]\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 148,
        "_Respuesta__fecha": "2020-06-21 11:43:44Z",
        "_Respuesta__descripcion": "\nThese questions have a lot of answers, I am adding my answer to explain the same diagrammatically.\nThe way you created the 2D, creates a shallow list\n    arr = [[0]*cols]*row\n\nInstead, if you want to update the elements of the list, you should use\n   rows, cols = (5, 5) \n   arr = [[0 for i in range(cols)] for j in range(rows)] \n\n\nExplanation:\nOne can create a list using :\n   arr = [0]*N \n\nor\n   arr = [0 for i in range(N)] \n\nIn the first case all the indices of the array point to the same integer object\n\nand when you assign a value to a particular index, a new int object is created, for eg arr[4] = 5 creates\n\nNow let us see what happens when we create a list of list, in this case, all the elements of our top list will point to the same list\n\nAnd if you update the value of any index a new int object will be created. But since all the top-level list indexes are pointing at the same list, all the rows will look the same. And you will get the feeling that updating an element is updating all the elements in that column.\n\nCredits: Thanks to Pranav Devarakonda for the easy explanation here\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 149,
        "_Respuesta__fecha": "2021-06-18 17:02:12Z",
        "_Respuesta__descripcion": "\n@spelchekr from Python list multiplication: [[...]]*3 makes 3 lists which mirror each other when modified and I had the same question about\n\"Why does only the outer *3 create more references while the inner one doesn't? Why isn't it all 1s?\"\nli = [0] * 3\nprint([id(v) for v in li])  # [140724141863728, 140724141863728, 140724141863728]\nli[0] = 1\nprint([id(v) for v in li])  # [140724141863760, 140724141863728, 140724141863728]\nprint(id(0))  # 140724141863728\nprint(id(1))  # 140724141863760\nprint(li)     # [1, 0, 0]\n\nma = [[0]*3] * 3  # mainly discuss inner & outer *3 here\nprint([id(li) for li in ma])  # [1987013355080, 1987013355080, 1987013355080]\nma[0][0] = 1\nprint([id(li) for li in ma])  # [1987013355080, 1987013355080, 1987013355080]\nprint(ma)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]]\n\nHere is my explanation after trying the code above:\n\nThe inner *3 also creates references, but its references are immutable, something like [&0, &0, &0], then when you change li[0], you can't change any underlying reference of const int 0, so you can just change the reference address into the new one &1;\nwhile ma = [&li, &li, &li] and li is mutable, so when you call ma[0][0] = 1, ma[0][0] is equal to &li[0], so all the &li instances will change its 1st address into &1.\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 150,
        "_Respuesta__fecha": "2016-07-25 09:09:59Z",
        "_Respuesta__descripcion": "\nBy using the inbuilt list function you can do like this\n\na\nout:[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n#Displaying the list\n\na.remove(a[0])\nout:[[1, 1, 1, 1], [1, 1, 1, 1]]\n# Removed the first element of the list in which you want altered number\n\na.append([5,1,1,1])\nout:[[1, 1, 1, 1], [1, 1, 1, 1], [5, 1, 1, 1]]\n# append the element in the list but the appended element as you can see is appended in last but you want that in starting\n\na.reverse()\nout:[[5, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n#So at last reverse the whole list to get the desired list\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [
            {
                "_id": 214,
                "_Comentario__descripcion": "Note, fourth step can be dropped if you make second step: a.insert(0,[5,1,1,1])",
                "_Comentario__fecha": "2018-10-19 05:29:03Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "U12-Forward",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 151,
        "_Respuesta__fecha": "2020-10-22 19:57:45Z",
        "_Respuesta__descripcion": "\nI arrived here because I was looking to see how I could nest an arbitrary number of lists. There are a lot of explanations and specific examples above, but you can generalize N dimensional list of lists of lists of ... with the following recursive function:\nimport copy\n\ndef list_ndim(dim, el=None, init=None):\n    if init is None:\n        init = el\n\n    if len(dim)> 1:\n        return list_ndim(dim[0:-1], None, [copy.copy(init) for x in range(dim[-1])])\n\n    return [copy.deepcopy(init) for x in range(dim[0])]\n\nYou make your first call to the function like this:\ndim = (3,5,2)\nel = 1.0\nl = list_ndim(dim, el)\n\nwhere (3,5,2) is a tuple of the dimensions of the structure (similar to numpy shape argument), and 1.0 is the element you want the structure to be initialized with (works with None as well). Note that the init argument is only provided by the recursive call to carry forward the nested child lists\noutput of above:\n[[[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]],\n [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]],\n [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]]\n\nset specific elements:\nl[1][3][1] = 56\nl[2][2][0] = 36.0+0.0j\nl[0][1][0] = 'abc'\n\nresulting output:\n[[[1.0, 1.0], ['abc', 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]],\n [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 56.0], [1.0, 1.0]],\n [[1.0, 1.0], [1.0, 1.0], [(36+0j), 1.0], [1.0, 1.0], [1.0, 1.0]]]\n\nthe non-typed nature of lists is demonstrated above\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 152,
        "_Respuesta__fecha": "2021-01-07 16:39:52Z",
        "_Respuesta__descripcion": "\nWhile the original question constructed the sublists with the multiplication operator, I'll add an example that uses the same list for the sublists. Adding this answer for completeness as this question is often used as a canonical for the issue\nnode_count = 4\ncolors = [0,1,2,3]\nsol_dict = {node:colors for node in range(0,node_count)}\n\nThe list in each dictionary value is the same object, trying to change one of the dictionaries values will be seen in all.\n>>> sol_dict\n{0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3]}\n>>> [v is colors for v in sol_dict.values()]\n[True, True, True, True]\n>>> sol_dict[0].remove(1)\n>>> sol_dict\n{0: [0, 2, 3], 1: [0, 2, 3], 2: [0, 2, 3], 3: [0, 2, 3]}\n\nThe correct way to construct the dictionary would be to use a copy of the list for each value.\n>>> colors = [0,1,2,3]\n>>> sol_dict = {node:colors[:] for node in range(0,node_count)}\n>>> sol_dict\n{0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3]}\n>>> sol_dict[0].remove(1)\n>>> sol_dict\n{0: [0, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3]}\n\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 153,
        "_Respuesta__fecha": "2021-03-20 14:25:08Z",
        "_Respuesta__descripcion": "\nNote that items in the sequence are not copied; they are referenced multiple times. This often haunts new Python programmers; consider:\n>>> lists = [[]] * 3\n>>> lists\n[[], [], []]\n>>> lists[0].append(3)\n>>> lists\n[[3], [3], [3]]\n\nWhat has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list.\nAnother example to explain this is using multi-dimensional arrays.\nYou probably tried to make a multidimensional array like this:\n>>> A = [[None] * 2] * 3\n\nThis looks correct if you print it:\n>>> A\n[[None, None], [None, None], [None, None]]\n\nBut when you assign a value, it shows up in multiple places:\n>>> A[0][0] = 5\n>>> A\n[[5, None], [5, None], [5, None]]\n\nThe reason is that replicating a list with\u00a0*\u00a0doesn\u2019t create copies, it only creates references to the existing objects. The\u00a03\u00a0creates a list containing 3 references to the same list of length two. Changes to one row will show in all rows, which is almost certainly not what you want.\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 155,
        "_Respuesta__fecha": "2020-03-09 01:52:34Z",
        "_Respuesta__descripcion": "\nWith new_list = my_list, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both new_list and my_list refer to the same list after the assignment.\n\nTo actually copy the list, you have various possibilities:\n\n\nYou can use the builtin list.copy() method (available since Python 3.3):\n\nnew_list = old_list.copy()\n\nYou can slice it: \n\nnew_list = old_list[:]\n\n\nAlex Martelli's opinion (at least back in 2007) about this is, that it is a weird syntax and it does not make sense to use it ever. ;) (In his opinion, the next one is more readable).\nYou can use the built in list() function:\n\nnew_list = list(old_list)\n\nYou can use generic copy.copy():\n\nimport copy\nnew_list = copy.copy(old_list)\n\n\nThis is a little slower than list() because it has to find out the datatype of old_list first.\nIf the list contains objects and you want to copy them as well, use generic copy.deepcopy():\n\nimport copy\nnew_list = copy.deepcopy(old_list)\n\n\nObviously the slowest and most memory-needing method, but sometimes unavoidable.\n\n\nExample:\n\nimport copy\n\nclass Foo(object):\n    def __init__(self, val):\n         self.val = val\n\n    def __repr__(self):\n        return 'Foo({!r})'.format(self.val)\n\nfoo = Foo(1)\n\na = ['foo', foo]\nb = a.copy()\nc = a[:]\nd = list(a)\ne = copy.copy(a)\nf = copy.deepcopy(a)\n\n# edit orignal list and instance \na.append('baz')\nfoo.val = 5\n\nprint('original: %r\\nlist.copy(): %r\\nslice: %r\\nlist(): %r\\ncopy: %r\\ndeepcopy: %r'\n      % (a, b, c, d, e, f))\n\n\nResult:\n\noriginal: ['foo', Foo(5), 'baz']\nlist.copy(): ['foo', Foo(5)]\nslice: ['foo', Foo(5)]\nlist(): ['foo', Foo(5)]\ncopy: ['foo', Foo(5)]\ndeepcopy: ['foo', Foo(1)]\n\n    ",
        "_Respuesta__votes": 3690,
        "comentarios": [
            {
                "_id": 220,
                "_Comentario__descripcion": "As @Georgy points out correctly in the answer below, any changes to the new_list values will also change the values in my_list. So actually the copy.deepcopy() method is the only real copy without reference to the original list and it's values.",
                "_Comentario__fecha": "2020-12-21 17:27:56Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "moojen",
                "usuario_id": null
            },
            {
                "_id": 221,
                "_Comentario__descripcion": "@Erri I think you made a mistake. I didn't post any answers or comments here :)",
                "_Comentario__fecha": "2020-12-21 17:33:34Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Georgy",
                "usuario_id": null
            },
            {
                "_id": 222,
                "_Comentario__descripcion": "You're right, it was edited by you, but posted by @cryo Sorry for the mixup!",
                "_Comentario__fecha": "2020-12-21 17:52:36Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "moojen",
                "usuario_id": null
            },
            {
                "_id": 223,
                "_Comentario__descripcion": "Which one is fastest?",
                "_Comentario__fecha": "2021-05-04 18:10:13Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "zzz777",
                "usuario_id": null
            },
            {
                "_id": 224,
                "_Comentario__descripcion": "I was having the same issue with a list of json (each element of a list was a json) and the only one that worked was new_list = copy.deepcopy(old_list) ; I'm writing this since anyone can encounter the same issue. Thanks!",
                "_Comentario__fecha": "2021-05-11 15:23:44Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Tom",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 156,
        "_Respuesta__fecha": "2021-05-11 21:36:34Z",
        "_Respuesta__descripcion": "\nFelix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:\n\n10.59 sec (105.9 \u00b5s/itn) -  copy.deepcopy(old_list)\n10.16 sec (101.6 \u00b5s/itn) - pure Python Copy() method copying classes with deepcopy\n1.488 sec (14.88 \u00b5s/itn) - pure Python Copy() method not copying classes (only dicts/lists/tuples)\n0.325 sec (3.25 \u00b5s/itn) - for item in old_list: new_list.append(item)\n0.217 sec (2.17 \u00b5s/itn) - [i for i in old_list] (a list comprehension)\n0.186 sec (1.86 \u00b5s/itn) - copy.copy(old_list)\n0.075 sec (0.75 \u00b5s/itn) - list(old_list)\n0.053 sec (0.53 \u00b5s/itn) - new_list = []; new_list.extend(old_list)\n0.039 sec (0.39 \u00b5s/itn) - old_list[:] (list slicing)\n\nSo the fastest is list slicing. But be aware that copy.copy(), list[:] and list(list), unlike copy.deepcopy() and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.\n(Here's the script if anyone's interested or wants to raise any issues:)\nfrom copy import deepcopy\n\nclass old_class:\n    def __init__(self):\n        self.blah = 'blah'\n\nclass new_class(object):\n    def __init__(self):\n        self.blah = 'blah'\n\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\n\n    if t in (list, tuple):\n        if t == tuple:\n            # Convert to a list if a tuple to\n            # allow assigning to when copying\n            is_tuple = True\n            obj = list(obj)\n        else:\n            # Otherwise just do a quick slice copy\n            obj = obj[:]\n            is_tuple = False\n\n        # Copy each item recursively\n        for x in xrange(len(obj)):\n            if type(obj[x]) in dignore:\n                continue\n            obj[x] = Copy(obj[x], use_deepcopy)\n\n        if is_tuple:\n            # Convert back into a tuple again\n            obj = tuple(obj)\n\n    elif t == dict:\n        # Use the fast shallow dict copy() method and copy any\n        # values which aren't immutable (like lists, dicts etc)\n        obj = obj.copy()\n        for k in obj:\n            if type(obj[k]) in dignore:\n                continue\n            obj[k] = Copy(obj[k], use_deepcopy)\n\n    elif t in dignore:\n        # Numeric or string/unicode?\n        # It's immutable, so ignore it!\n        pass\n\n    elif use_deepcopy:\n        obj = deepcopy(obj)\n    return obj\n\nif __name__ == '__main__':\n    import copy\n    from time import time\n\n    num_times = 100000\n    L = [None, 'blah', 1, 543.4532,\n         ['foo'], ('bar',), {'blah': 'blah'},\n         old_class(), new_class()]\n\n    t = time()\n    for i in xrange(num_times):\n        Copy(L)\n    print 'Custom Copy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        Copy(L, use_deepcopy=False)\n    print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        copy.copy(L)\n    print 'copy.copy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        copy.deepcopy(L)\n    print 'copy.deepcopy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        L[:]\n    print 'list slicing [:]:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        list(L)\n    print 'list(L):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        [i for i in L]\n    print 'list expression(L):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        a.extend(L)\n    print 'list extend:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        for y in L:\n            a.append(y)\n    print 'list append:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        a.extend(i for i in L)\n    print 'generator expression extend:', time()-t\n\n    ",
        "_Respuesta__votes": 689,
        "comentarios": [
            {
                "_id": 225,
                "_Comentario__descripcion": "Does it mean that append and list comprehension are the best options?",
                "_Comentario__fecha": "2021-05-04 18:24:27Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "zzz777",
                "usuario_id": null
            },
            {
                "_id": 226,
                "_Comentario__descripcion": "I have a cache containing a list of classes, I want to take lock, copy out the list, release lock. I hope that it is enough to use built-in copy to protect copied out list from changing when cached copy is changed.",
                "_Comentario__fecha": "2021-05-04 18:32:44Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "zzz777",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 157,
        "_Respuesta__fecha": "2021-05-11 21:37:30Z",
        "_Respuesta__descripcion": "\nI've been told that Python 3.3+ adds the list.copy() method, which should be as fast as slicing:\nnewlist = old_list.copy()\n\n    ",
        "_Respuesta__votes": 173,
        "comentarios": [
            {
                "_id": 227,
                "_Comentario__descripcion": "Yes, and as per docs docs.python.org/3/library/stdtypes.html#mutable-sequence-types, s.copy() creates a shallow copy of s (same as s[:]).",
                "_Comentario__fecha": "2018-09-25 18:07:46Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "CyberMew",
                "usuario_id": null
            },
            {
                "_id": 228,
                "_Comentario__descripcion": "Actually it seems that currently, python3.8, .copy() is slightly faster than slicing. See below @AaronsHall answer.",
                "_Comentario__fecha": "2020-04-24 08:11:09Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "loved.by.Jesus",
                "usuario_id": null
            },
            {
                "_id": 229,
                "_Comentario__descripcion": "@loved.by.Jesus: Yeah, they added optimizations for Python level method calls in 3.7 that were extended to C extension method calls in 3.8 by PEP 590 that remove the overhead of creating a bound method each time you call a method, so the cost to call alist.copy() is now a dict lookup on the list type, then a relatively cheap no-arg function call that ultimately invokes the same thing as slicing. Slicing still has to build a slice object, then go through type checks and unpacking to do the same thing.",
                "_Comentario__fecha": "2020-11-30 18:33:23Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ShadowRanger",
                "usuario_id": null
            },
            {
                "_id": 230,
                "_Comentario__descripcion": "Of course, they're working on optimizing out the repeated builds of constant slices, so in 3.10 slicing might win again. It's all pretty meaningless though; the asymptotic performance is identical, and the fixed overhead relatively small, so it doesn't really matter which approach you use.",
                "_Comentario__fecha": "2020-11-30 18:36:02Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ShadowRanger",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 158,
        "_Respuesta__fecha": "2018-01-09 15:33:11Z",
        "_Respuesta__descripcion": "\n\n  What are the options to clone or copy a list in Python?\n\n\nIn Python 3, a shallow copy can be made with:\n\na_copy = a_list.copy()\n\n\nIn Python 2 and 3, you can get a shallow copy with a full slice of the original:\n\na_copy = a_list[:]\n\n\nExplanation\n\nThere are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.\n\nShallow list copy\n\nA shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists. \n\nThere are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.\n\nPython 2\n\nIn Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:\n\na_copy = a_list[:]\n\n\nYou can also accomplish the same thing by passing the list through the list constructor, \n\na_copy = list(a_list)\n\n\nbut using the constructor is less efficient:\n\n>>> timeit\n>>> l = range(20)\n>>> min(timeit.repeat(lambda: l[:]))\n0.30504298210144043\n>>> min(timeit.repeat(lambda: list(l)))\n0.40698814392089844\n\n\nPython 3\n\nIn Python 3, lists get the list.copy method:\n\na_copy = a_list.copy()\n\n\nIn Python 3.5:\n\n>>> import timeit\n>>> l = list(range(20))\n>>> min(timeit.repeat(lambda: l[:]))\n0.38448613602668047\n>>> min(timeit.repeat(lambda: list(l)))\n0.6309100328944623\n>>> min(timeit.repeat(lambda: l.copy()))\n0.38122922903858125\n\n\nMaking another pointer does not make a copy\n\n\n  Using new_list = my_list then modifies new_list every time my_list changes. Why is this?\n\n\nmy_list is just a name that points to the actual list in memory. When you say new_list = my_list you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists. \n\n>>> l = [[], [], []]\n>>> l_copy = l[:]\n>>> l_copy\n[[], [], []]\n>>> l_copy[0].append('foo')\n>>> l_copy\n[['foo'], [], []]\n>>> l\n[['foo'], [], []]\n\n\nThe list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.\n\nDeep copies\n\nTo make a deep copy of a list, in Python 2 or 3, use deepcopy in the copy module:\n\nimport copy\na_deep_copy = copy.deepcopy(a_list)\n\n\nTo demonstrate how this allows us to make new sub-lists:\n\n>>> import copy\n>>> l\n[['foo'], [], []]\n>>> l_deep_copy = copy.deepcopy(l)\n>>> l_deep_copy[0].pop()\n'foo'\n>>> l_deep_copy\n[[], [], []]\n>>> l\n[['foo'], [], []]\n\n\nAnd so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.\n\nDon't use eval\n\nYou may see this used as a way to deepcopy, but don't do it:\n\nproblematic_deep_copy = eval(repr(a_list))\n\n\n\nIt's dangerous, particularly if you're evaluating something from a source you don't trust.\nIt's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.\nIt's also less performant. \n\n\nIn 64 bit Python 2.7:\n\n>>> import timeit\n>>> import copy\n>>> l = range(10)\n>>> min(timeit.repeat(lambda: copy.deepcopy(l)))\n27.55826997756958\n>>> min(timeit.repeat(lambda: eval(repr(l))))\n29.04534101486206\n\n\non 64 bit Python 3.5:\n\n>>> import timeit\n>>> import copy\n>>> l = list(range(10))\n>>> min(timeit.repeat(lambda: copy.deepcopy(l)))\n16.84255409205798\n>>> min(timeit.repeat(lambda: eval(repr(l))))\n34.813894678023644\n\n    ",
        "_Respuesta__votes": 138,
        "comentarios": [
            {
                "_id": 231,
                "_Comentario__descripcion": "You don't need a deepcopy if the list is 2D. If it is a list of lists, and those lists don't have lists inside of them, you can use a for loop. Presently, I am using   list_copy=[] for item in list:     list_copy.append(copy(item)) and it is much faster.",
                "_Comentario__fecha": "2019-01-10 12:44:59Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "John Locke",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 159,
        "_Respuesta__fecha": "2020-06-05 16:01:12Z",
        "_Respuesta__descripcion": "\nThere are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed. \n\nPython doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by my_list and bound it to new_list as well. No matter which name you use there is still only one list, so changes made when referring to it as my_list will persist when referring to it as new_list. Each of the other answers to this question give you different ways of creating a new object to bind to new_list. \n\nEach element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.\n\nnew_list = list(my_list)  # or my_list[:], but I prefer this syntax\n# is simply a shorter way of:\nnew_list = [element for element in my_list]\n\n\nTo take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list. \n\nimport copy  \n# each element must have __copy__ defined for this...\nnew_list = [copy.copy(element) for element in my_list]\n\n\nThis is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy. \n\nimport copy\n# each element must have __deepcopy__ defined for this...\nnew_list = copy.deepcopy(my_list)\n\n\nSee the documentation for more information about corner cases in copying.\n    ",
        "_Respuesta__votes": 62,
        "comentarios": [
            {
                "_id": 232,
                "_Comentario__descripcion": "I should have scrolled down to your answer when dealing with this topic. I've had hard times trying to figure out why my copy of \"list of lists\" is actually not a copy... :-) Thanks for this one!",
                "_Comentario__fecha": "2020-09-10 15:37:28Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "MrZH6",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 160,
        "_Respuesta__fecha": "2021-05-11 21:53:58Z",
        "_Respuesta__descripcion": "\nLet's start from the beginning and explore this question.\nSo let's suppose you have two lists:\nlist_1 = ['01', '98']\nlist_2 = [['01', '98']]\n\nAnd we have to copy both lists, now starting from the first list:\nSo first let's try by setting the variable copy to our original list, list_1:\ncopy = list_1\n\nNow if you are thinking copy copied the list_1, then you are wrong. The id function can show us if two variables can point to the same object. Let's try this:\nprint(id(copy))\nprint(id(list_1))\n\nThe output is:\n4329485320\n4329485320\n\nBoth variables are the exact same argument. Are you surprised?\nSo as we know, Python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a list but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.\nWhen you do copy = list_1, it is actually doing:\n\nHere in the image list_1 and copy are two variable names, but the object is same for both variable which is list.\nSo if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:\ncopy[0] = \"modify\"\n\nprint(copy)\nprint(list_1)\n\nOutput:\n['modify', '98']\n['modify', '98']\n\nSo it modified the original list:\nNow let's move onto a Pythonic method for copying lists.\ncopy_1 = list_1[:]\n\nThis method fixes the first issue we had:\nprint(id(copy_1))\nprint(id(list_1))\n\n4338792136\n4338791432\n\nSo as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:\n\nNow let's try to modify the list and let's see if we still face the previous problem:\ncopy_1[0] = \"modify\"\n\nprint(list_1)\nprint(copy_1)\n\nThe output is:\n['01', '98']\n['modify', '98']\n\nAs you can see, it only modified the copied list. That means it worked.\nDo you think we're done? No. Let's try to copy our nested list.\ncopy_2 = list_2[:]\n\nlist_2 should reference to another object which is copy of list_2. Let's check:\nprint(id((list_2)), id(copy_2))\n\nWe get the output:\n4330403592 4330403528\n\nNow we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:\ncopy_2[0][1] = \"modify\"\n\nprint(list_2, copy_2)\n\nThis gives us the output:\n[['01', 'modify']] [['01', 'modify']]\n\nThis may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.\nWhen you do:\ncopy_2 = list_2[:]\n\nYou're only copying the outer list, not the inside list. We can use the id function once again to check this.\nprint(id(copy_2[0]))\nprint(id(list_2[0]))\n\nThe output is:\n4329485832\n4329485832\n\nWhen we do copy_2 = list_2[:], this happens:\n\nIt creates the copy of list, but only outer list copy, not the nested list copy. The nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.\nWhat is the solution? The solution is the deepcopy function.\nfrom copy import deepcopy\ndeep = deepcopy(list_2)\n\nLet's check this:\nprint(id((list_2)), id(deep))\n\n4322146056 4322148040\n\nBoth outer lists have different IDs. Let's try this on the inner nested lists.\nprint(id(deep[0]))\nprint(id(list_2[0]))\n\nThe output is:\n4322145992\n4322145800\n\nAs you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.\nThis means when you do deep = deepcopy(list_2) what actually happens:\n\nBoth nested lists are pointing different object and they have separate copy of nested list now.\nNow let's try to modify the nested list and see if it solved the previous issue or not:\ndeep[0][1] = \"modify\"\nprint(list_2, deep)\n\nIt outputs:\n[['01', '98']] [['01', 'modify']]\n\nAs you can see, it didn't modify the original nested list, it only modified the copied list.\n    ",
        "_Respuesta__votes": 55,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 161,
        "_Respuesta__fecha": "2010-04-10 08:53:06Z",
        "_Respuesta__descripcion": "\nUse thing[:]\n\n>>> a = [1,2]\n>>> b = a[:]\n>>> a += [3]\n>>> a\n[1, 2, 3]\n>>> b\n[1, 2]\n>>> \n\n    ",
        "_Respuesta__votes": 40,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 162,
        "_Respuesta__fecha": "2021-05-11 21:40:12Z",
        "_Respuesta__descripcion": "\nPython 3.6 Timings\nHere are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.\nI stuck to only doing shallow copies, and also added some new methods that weren't possible in Python\u00a02, such as list.copy() (the Python\u00a03 slice equivalent) and two forms of list unpacking (*new_list, = list and new_list = [*list]):\nMETHOD                TIME TAKEN\nb = [*a]               2.75180600000021\nb = a * 1              3.50215399999990\nb = a[:]               3.78278899999986  # Python 2 winner (see above)\nb = a.copy()           4.20556500000020  # Python 3 \"slice equivalent\" (see above)\nb = []; b.extend(a)    4.68069800000012\nb = a[0:len(a)]        6.84498999999959\n*b, = a                7.54031799999984\nb = list(a)            7.75815899999997\nb = [i for i in a]    18.4886440000000\nb = copy.copy(a)      18.8254879999999\nb = []\nfor item in a:\n  b.append(item)      35.4729199999997\n\nWe can see the Python 2 winner still does well, but doesn't edge out Python 3 list.copy() by much, especially considering the superior readability of the latter.\nThe dark horse is the unpacking and repacking method (b = [*a]), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (*b, = a).\nb = a * 1 also does surprisingly well.\nNote that these methods do not output equivalent results for any input other than lists. They all work for sliceable objects, a few work for any iterable, but only copy.copy() works for more general Python objects.\n\nHere is the testing code for interested parties (Template from here):\nimport timeit\n\nCOUNT = 50000000\nprint(\"Array duplicating. Tests run\", COUNT, \"times\")\nsetup = 'a = [0,1,2,3,4,5,6,7,8,9]; import copy'\n\nprint(\"b = list(a)\\t\\t\", timeit.timeit(stmt='b = list(a)', setup=setup, number=COUNT))\nprint(\"b = copy.copy(a)\\t\", timeit.timeit(stmt='b = copy.copy(a)', setup=setup, number=COUNT))\nprint(\"b = a.copy()\\t\\t\", timeit.timeit(stmt='b = a.copy()', setup=setup, number=COUNT))\nprint(\"b = a[:]\\t\\t\", timeit.timeit(stmt='b = a[:]', setup=setup, number=COUNT))\nprint(\"b = a[0:len(a)]\\t\\t\", timeit.timeit(stmt='b = a[0:len(a)]', setup=setup, number=COUNT))\nprint(\"*b, = a\\t\\t\\t\", timeit.timeit(stmt='*b, = a', setup=setup, number=COUNT))\nprint(\"b = []; b.extend(a)\\t\", timeit.timeit(stmt='b = []; b.extend(a)', setup=setup, number=COUNT))\nprint(\"b = []; for item in a: b.append(item)\\t\", timeit.timeit(stmt='b = []\\nfor item in a:  b.append(item)', setup=setup, number=COUNT))\nprint(\"b = [i for i in a]\\t\", timeit.timeit(stmt='b = [i for i in a]', setup=setup, number=COUNT))\nprint(\"b = [*a]\\t\\t\", timeit.timeit(stmt='b = [*a]', setup=setup, number=COUNT))\nprint(\"b = a * 1\\t\\t\", timeit.timeit(stmt='b = a * 1', setup=setup, number=COUNT))\n\n    ",
        "_Respuesta__votes": 37,
        "comentarios": [
            {
                "_id": 233,
                "_Comentario__descripcion": "Can confirm still a similar story on 3.8 b=[*a] - the one obvious way to do it;).",
                "_Comentario__fecha": "2020-03-02 00:02:40Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "SuperShoot",
                "usuario_id": null
            },
            {
                "_id": 234,
                "_Comentario__descripcion": "Some of these timing comparisons aren't particularly meaningful when copying such tiny lists. It would be more informative to test with a range of list lengths (including some very large ones).",
                "_Comentario__fecha": "2020-11-21 20:15:28Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ekhumoro",
                "usuario_id": null
            },
            {
                "_id": 235,
                "_Comentario__descripcion": "The timing numbers ought to rounded to the appropriate number of significant digits. 15 significant digits do not make any sense.",
                "_Comentario__fecha": "2021-05-11 21:43:46Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Peter Mortensen",
                "usuario_id": null
            },
            {
                "_id": 236,
                "_Comentario__descripcion": "I've essentially just pasted the raw output of the timing code here. Seems like your gripe is more about how timeit displays timings, which I have little control over.",
                "_Comentario__fecha": "2021-05-18 00:38:32Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "River",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 163,
        "_Respuesta__fecha": "2010-04-10 08:53:19Z",
        "_Respuesta__descripcion": "\nPython's idiom for doing this is newList = oldList[:]\n    ",
        "_Respuesta__votes": 35,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 164,
        "_Respuesta__fecha": "2020-06-20 09:12:55Z",
        "_Respuesta__descripcion": "\nAll of the other contributors gave great answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only copy.deepcopy() works to clone/copy a list and not have it point to the nested list objects when you are working with multidimensional, nested lists (list of lists). While Felix Kling refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to deepcopy.\nWhile new_list = old_list[:], copy.copy(old_list)' and for Py3k old_list.copy() work for single-leveled lists, they revert to pointing at the list objects nested within the old_list and the new_list, and changes to one of the list objects are perpetuated in the other.\nEdit: New information brought to light\n\nAs was pointed out by both Aaron Hall and PM 2Ring using eval() is not only a bad idea, it is also much slower than copy.deepcopy().\nThis means that for multidimensional lists, the only option is copy.deepcopy(). With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to timeit using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.\nIt would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.\n\nAs others have stated, there  are significant performance issues using the copy module and copy.deepcopy for multidimensional lists.\n    ",
        "_Respuesta__votes": 22,
        "comentarios": [
            {
                "_id": 237,
                "_Comentario__descripcion": "This won't always work, since there's no guarantee that the string returned by repr() is sufficient to re-create the object. Also, eval() is a tool of last resort; see Eval really is dangerous by SO veteran Ned Batchelder for details. So when you advocate the use eval() you really should mention that it can be dangerous.",
                "_Comentario__fecha": "2015-07-10 14:51:30Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "PM 2Ring",
                "usuario_id": null
            },
            {
                "_id": 238,
                "_Comentario__descripcion": "Fair point. Though I think that Batchelder's point is that the having the eval() function in Python in general is a risk. It isn't so much whether or not you make use of the function in code but that it is a security hole in Python in and of itself.  My example isn't using it with a function that receives input from input(), sys.agrv, or even a text file. It is more along the lines of initializing a blank multidimensional list once, and then just having a way of copying it in a loop instead of reinitializing at each iteration of the loop.",
                "_Comentario__fecha": "2015-07-10 16:41:36Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "AMR",
                "usuario_id": null
            },
            {
                "_id": 239,
                "_Comentario__descripcion": "As @AaronHall has pointed out, there is likely a significant performance issue to using new_list = eval(repr(old_list)), so besides it being a bad idea, it probably is also way too slow to work.",
                "_Comentario__fecha": "2015-07-10 17:19:53Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "AMR",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 165,
        "_Respuesta__fecha": "2018-02-26 02:33:47Z",
        "_Respuesta__descripcion": "\nIt surprises me that this hasn't been mentioned yet, so for the sake of completeness...\n\nYou can perform list unpacking with the \"splat operator\": *, which will also copy elements of your list.\n\nold_list = [1, 2, 3]\n\nnew_list = [*old_list]\n\nnew_list.append(4)\nold_list == [1, 2, 3]\nnew_list == [1, 2, 3, 4]\n\n\nThe obvious downside to this method is that it is only available in Python 3.5+.\n\nTiming wise though, this appears to perform better than other common methods.\n\nx = [random.random() for _ in range(1000)]\n\n%timeit a = list(x)\n%timeit a = x.copy()\n%timeit a = x[:]\n\n%timeit a = [*x]\n\n#: 2.47 \u00b5s \u00b1 38.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n#: 2.47 \u00b5s \u00b1 54.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n#: 2.39 \u00b5s \u00b1 58.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n#: 2.22 \u00b5s \u00b1 43.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n    ",
        "_Respuesta__votes": 16,
        "comentarios": [
            {
                "_id": 240,
                "_Comentario__descripcion": "How does this method behave when modifying copies?",
                "_Comentario__fecha": "2018-09-24 13:35:16Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "not2qubit",
                "usuario_id": null
            },
            {
                "_id": 241,
                "_Comentario__descripcion": "@not2qubit do you mean appending to or editing elements of the new list. In the example old_list and new_list are two different lists, editing one will not change the other (unless you\u2019re directly mutating the elements themselves (such as list of list), none-of these methods are deep copies).",
                "_Comentario__fecha": "2018-09-25 14:07:07Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "SCB",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 166,
        "_Respuesta__fecha": "2021-05-11 21:48:59Z",
        "_Respuesta__descripcion": "\nA very simple approach independent of python version was missing in already-given answers which you can use most of the time (at least I do):\nnew_list = my_list * 1       # Solution 1 when you are not using nested lists\n\nHowever, if my_list contains other containers (for example, nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:\nimport copy\nnew_list = copy.deepcopy(my_list)   # Solution 2 when you are using nested lists\n\n.Bonus: If you don't want to copy elements use (AKA shallow copy):\nnew_list = my_list[:]\n\n\nLet's understand difference between solution #1 and solution #2\n>>> a = range(5)\n>>> b = a*1\n>>> a,b\n([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])\n>>> a[2] = 55\n>>> a,b\n([0, 1, 55, 3, 4], [0, 1, 2, 3, 4])\n\nAs you can see, solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.\n>>> from copy import deepcopy\n>>> a = [range(i,i+4) for i in range(3)]\n>>> a\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n>>> b = a*1\n>>> c = deepcopy(a)\n>>> for i in (a, b, c): print i\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n>>> a[2].append('99')\n>>> for i in (a, b, c): print i\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]   # Solution #1 didn't work in nested list\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]       # Solution #2 - DeepCopy worked in nested list\n\n    ",
        "_Respuesta__votes": 11,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 167,
        "_Respuesta__fecha": "2018-05-16 14:31:22Z",
        "_Respuesta__descripcion": "\nNote that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use copy.copy() or copy.deepcopy() rather than the alternatives, for example in Python 3:\n\nimport copy\n\nclass MyList(list):\n    pass\n\nlst = MyList([1,2,3])\n\nlst.name = 'custom list'\n\nd = {\n'original': lst,\n'slicecopy' : lst[:],\n'lstcopy' : lst.copy(),\n'copycopy': copy.copy(lst),\n'deepcopy': copy.deepcopy(lst)\n}\n\n\nfor k,v in d.items():\n    print('lst: {}'.format(k), end=', ')\n    try:\n        name = v.name\n    except AttributeError:\n        name = 'NA'\n    print('name: {}'.format(name))\n\n\nOutputs:\n\nlst: original, name: custom list\nlst: slicecopy, name: NA\nlst: lstcopy, name: NA\nlst: copycopy, name: custom list\nlst: deepcopy, name: custom list\n\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 168,
        "_Respuesta__fecha": "2021-05-11 21:45:51Z",
        "_Respuesta__descripcion": "\nnew_list = my_list[:]\n\nnew_list = my_list\nTry to understand this. Let's say that my_list is in the heap memory at location X, i.e., my_list is pointing to the X. Now by assigning new_list = my_list you're letting new_list point to the X. This is known as a shallow copy.\nNow if you assign new_list = my_list[:], you're simply copying each object of my_list to new_list. This is known as a deep copy.\nThe other way you can do this are:\n\nnew_list = list(old_list)\nimport copy new_list = copy.deepcopy(old_list)\n\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 169,
        "_Respuesta__fecha": "2020-02-22 12:44:40Z",
        "_Respuesta__descripcion": "\nRemember that in Python when you do:\n\n    list1 = ['apples','bananas','pineapples']\n    list2 = list1\n\n\nList2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(copy.copy() for simple lists, copy.deepcopy() for nested ones). This makes a copy that doesn't change with the first list.\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 170,
        "_Respuesta__fecha": "2021-08-26 16:10:55Z",
        "_Respuesta__descripcion": "\nI wanted to post something a bit different than some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.\nAt the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?\nIt's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.\nOnce you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)\ndef deepcopy(x):\n  immutables = (str, int, bool, float)\n  mutables = (list, dict, tuple)\n  if isinstance(x, immutables):\n    return x\n  elif isinstance(x, mutables):\n    if isinstance(x, tuple):\n      return tuple(deepcopy(list(x)))\n    elif isinstance(x, list):\n      return [deepcopy(y) for y in x]\n    elif isinstance(x, dict):\n      values = [deepcopy(y) for y in list(x.values())]\n      keys = list(x.keys())\n      return dict(zip(keys, values))\n\nPython's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.\nEXAMPLES\nSay you have this list: [1, 2, 3]. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: [x for x in [1, 2, 3]]\nNow, imagine you have this list: [[1, 2], [3, 4], [5, 6]]. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:\n[x for x in _list]\n\nIt uses a new one for lists:\n[deepcopy_list(x) for x in _list]\n\nAnd deepcopy_list looks like this:\ndef deepcopy_list(x):\n  if isinstance(x, (str, bool, float, int)):\n    return x\n  else:\n    return [deepcopy_list(y) for y in x]\n\nThen now you have a function which can deepcopy any list of strs, bools, floast, ints and even lists to infinitely many layers using recursion. And there you have it, deepcopying.\nTLDR: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 171,
        "_Respuesta__fecha": "2019-11-23 19:01:46Z",
        "_Respuesta__descripcion": "\nA slight practical perspective to look into memory through id and gc. \n\n>>> b = a = ['hell', 'word']\n>>> c = ['hell', 'word']\n\n>>> id(a), id(b), id(c)\n(4424020872, 4424020872, 4423979272) \n     |           |\n      -----------\n\n>>> id(a[0]), id(b[0]), id(c[0])\n(4424018328, 4424018328, 4424018328) # all referring to same 'hell'\n     |           |           |\n      -----------------------\n\n>>> id(a[0][0]), id(b[0][0]), id(c[0][0])\n(4422785208, 4422785208, 4422785208) # all referring to same 'h'\n     |           |           |\n      -----------------------\n\n>>> a[0] += 'o'\n>>> a,b,c\n(['hello', 'word'], ['hello', 'word'], ['hell', 'word'])  # b changed too\n>>> id(a[0]), id(b[0]), id(c[0])\n(4424018384, 4424018384, 4424018328) # augmented assignment changed a[0],b[0]\n     |           |\n      -----------\n\n>>> b = a = ['hell', 'word']\n>>> id(a[0]), id(b[0]), id(c[0])\n(4424018328, 4424018328, 4424018328) # the same hell\n     |           |           |\n      -----------------------\n\n>>> import gc\n>>> gc.get_referrers(a[0]) \n[['hell', 'word'], ['hell', 'word']]  # one copy belong to a,b, the another for c\n>>> gc.get_referrers(('hell'))\n[['hell', 'word'], ['hell', 'word'], ('hell', None)] # ('hello', None) \n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 172,
        "_Respuesta__fecha": "2020-04-11 11:19:40Z",
        "_Respuesta__descripcion": "\nThe deepcopy option is the only method that works for me:\n\nfrom copy import deepcopy\n\na = [   [ list(range(1, 3)) for i in range(3) ]   ]\nb = deepcopy(a)\nb[0][1]=[3]\nprint('Deep:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]   ]\nb = a*1\nb[0][1]=[3]\nprint('*1:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ] ]\nb = a[:]\nb[0][1]=[3]\nprint('Vector copy:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]  ]\nb = list(a)\nb[0][1]=[3]\nprint('List copy:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]  ]\nb = a.copy()\nb[0][1]=[3]\nprint('.copy():')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]  ]\nb = a\nb[0][1]=[3]\nprint('Shallow:')\nprint(a)\nprint(b)\nprint('-----------------------------')\n\n\nleads to output of:\n\nDeep:\n[[[1, 2], [1, 2], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\n*1:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\nVector copy:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\nList copy:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\n.copy():\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\nShallow:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [
            {
                "_id": 242,
                "_Comentario__descripcion": "deepcopy must be used only when needed and one should be aware of what it really does.",
                "_Comentario__fecha": "2020-11-19 13:43:05Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Jean-Fran\u00e7ois Fabre\u2666",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 173,
        "_Respuesta__fecha": "2020-06-04 10:40:28Z",
        "_Respuesta__descripcion": "\nThis is because, the line new_list = my_list assigns a new reference to the variable my_list which is new_list\nThis is similar to the C code given below,\n\nint my_list[] = [1,2,3,4];\nint *new_list;\nnew_list = my_list;\n\n\nYou should use the copy module to create a new list by\n\nimport copy\nnew_list = copy.deepcopy(my_list)\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 174,
        "_Respuesta__fecha": "2021-01-30 20:17:42Z",
        "_Respuesta__descripcion": "\nThe method to use depends on the contents of the list being copied. If the list contains nested dicts than deepcopy is the only method that works, otherwise most of the methods listed in the answers (slice, loop [for], copy, extend, combine, or unpack) will work and execute in similar time (except for loop and deepcopy, which preformed the worst).\nScript\nfrom random import randint\nfrom time import time\nimport copy\n\nitem_count = 100000\n\ndef copy_type(l1: list, l2: list):\n  if l1 == l2:\n    return 'shallow'\n  return 'deep'\n\ndef run_time(start, end):\n  run = end - start\n  return int(run * 1000000)\n\ndef list_combine(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = [] + l1\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'combine', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_extend(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = []\n  l2.extend(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'extend', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_unpack(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = [*l1]\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'unpack', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_deepcopy(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = copy.deepcopy(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'deepcopy', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_copy(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = list.copy(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'copy', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_slice(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = l1[:]\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'slice', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_loop(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = []\n  for i in range(len(l1)):\n    l2.append(l1[i])\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'loop', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_list(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = list(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'list()', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\nif __name__ == '__main__':\n  list_type = [{'list[dict]': {'test': [1, 1]}}, \n          {'list[list]': [1, 1]}]\n  store = []\n  for data in list_type:\n    key = list(data.keys())[0]\n    store.append({key: [list_unpack(data[key]), list_extend(data[key]), \n                list_combine(data[key]), list_deepcopy(data[key]), \n                list_copy(data[key]), list_slice(data[key]),           \n                list_loop(data[key])]})\n  print(store)\n\nResults\n[{\"list[dict]\": [\n  {\"method\": \"unpack\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 56149},\n  {\"method\": \"extend\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 52991},\n  {\"method\": \"combine\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 53726},\n  {\"method\": \"deepcopy\", \"copy_type\": \"deep\", \"time_\u00b5s\": 2702616},\n  {\"method\": \"copy\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 52204},\n  {\"method\": \"slice\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 52223},\n  {\"method\": \"loop\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 836928}]},\n{\"list[list]\": [\n  {\"method\": \"unpack\", \"copy_type\": \"deep\", \"time_\u00b5s\": 52313},\n  {\"method\": \"extend\", \"copy_type\": \"deep\", \"time_\u00b5s\": 52550},\n  {\"method\": \"combine\", \"copy_type\": \"deep\", \"time_\u00b5s\": 53203},\n  {\"method\": \"deepcopy\", \"copy_type\": \"deep\", \"time_\u00b5s\": 2608560},\n  {\"method\": \"copy\", \"copy_type\": \"deep\", \"time_\u00b5s\": 53210},\n  {\"method\": \"slice\", \"copy_type\": \"deep\", \"time_\u00b5s\": 52937},\n  {\"method\": \"loop\", \"copy_type\": \"deep\", \"time_\u00b5s\": 834774}\n]}]\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 175,
        "_Respuesta__fecha": "2020-07-03 03:38:24Z",
        "_Respuesta__descripcion": "\nThere is a simple technique to handle this.\nCode:\nnumber=[1,2,3,4,5,6] #Original list\nanother=[] #another empty list\nfor a in number: #here I am declaring variable (a) as an item in the list (number)\n    another.append(a) #here we are adding the items of list (number) to list (another)\nprint(another)\n\nOutput:\n>>> [1,2,3,4,5,6]\n\nI hope this was useful for your query.\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 176,
        "_Respuesta__fecha": "2021-05-11 22:02:57Z",
        "_Respuesta__descripcion": "\nThere is another way of copying a list that was not listed until now: adding an empty list: l2 = l + [].\nI tested it with Python 3.8:\nl = [1,2,3]\nl2 = l + []\nprint(l,l2)\nl[0] = 'a'\nprint(l,l2)\n\nIt is not the best answer, but it works.\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 178,
        "_Respuesta__fecha": "2021-08-07 11:42:55Z",
        "_Respuesta__descripcion": "\nWe start by answering the first question:\nQuestion 1\n\nWhy do I get ValueError: Index contains duplicate entries, cannot reshape\n\nThis occurs because pandas is attempting to reindex either a columns or index object with duplicate entries.  There are varying methods to use that can perform a pivot.  Some of them are not well suited to when there are duplicates of the keys in which it is being asked to pivot on.  For example.  Consider pd.DataFrame.pivot.  I know there are duplicate entries that share the row and col values:\ndf.duplicated(['row', 'col']).any()\n\nTrue\n\nSo when I pivot using\ndf.pivot(index='row', columns='col', values='val0')\n\nI get the error mentioned above.  In fact, I get the same error when I try to perform the same task with:\ndf.set_index(['row', 'col'])['val0'].unstack()\n\nHere is a list of idioms we can use to pivot\n\npd.DataFrame.groupby + pd.DataFrame.unstack\n\nGood general approach for doing just about any type of pivot\nYou specify all columns that will constitute the pivoted row levels and column levels in one group by.  You follow that by selecting the remaining columns you want to aggregate and the function(s) you want to perform the aggregation.  Finally, you unstack the levels that you want to be in the column index.\n\n\npd.DataFrame.pivot_table\n\nA glorified version of groupby with more intuitive API.  For many people, this is the preferred approach.  And is the intended approach by the developers.\nSpecify row level, column levels, values to be aggregated, and function(s) to perform aggregations.\n\n\npd.DataFrame.set_index + pd.DataFrame.unstack\n\nConvenient and intuitive for some (myself included).  Cannot handle duplicate grouped keys.\nSimilar to the groupby paradigm, we specify all columns that will eventually be either row or column levels and set those to be the index.  We then unstack the levels we want in the columns.  If either the remaining index levels or column levels are not unique, this method will fail.\n\n\npd.DataFrame.pivot\n\nVery similar to set_index in that it shares the duplicate key limitation.  The API is very limited as well.  It only takes scalar values for index, columns, values.\nSimilar to the pivot_table method in that we select rows, columns, and values on which to pivot.  However, we cannot aggregate and if either rows or columns are not unique, this method will fail.\n\n\npd.crosstab\n\nThis a specialized version of pivot_table and in its purest form is the most intuitive way to perform several tasks.\n\n\npd.factorize + np.bincount\n\nThis is a highly advanced technique that is very obscure but is very fast.  It cannot be used in all circumstances, but when it can be used and you are comfortable using it, you will reap the performance rewards.\n\n\npd.get_dummies + pd.DataFrame.dot\n\nI use this for cleverly performing cross tabulation.\n\n\n\n\nExamples\nWhat I'm going to do for each subsequent answer and question is to answer it using pd.DataFrame.pivot_table.  Then I'll provide alternatives to perform the same task.\nQuestion 3\n\nHow do I pivot df such that the col values are columns, row values are the index, mean of val0 are the values, and missing values are 0?\n\n\npd.DataFrame.pivot_table\n\nfill_value is not set by default.  I tend to set it appropriately.  In this case I set it to 0.  Notice I skipped question 2 as it's the same as this answer without the fill_value\n\naggfunc='mean' is the default and I didn't have to set it.  I included it to be explicit.\n    df.pivot_table(\n        values='val0', index='row', columns='col',\n        fill_value=0, aggfunc='mean')\n\n    col   col0   col1   col2   col3  col4\n    row\n    row0  0.77  0.605  0.000  0.860  0.65\n    row2  0.13  0.000  0.395  0.500  0.25\n    row3  0.00  0.310  0.000  0.545  0.00\n    row4  0.00  0.100  0.395  0.760  0.24\n\n\n\n\npd.DataFrame.groupby\n  df.groupby(['row', 'col'])['val0'].mean().unstack(fill_value=0)\n\n\npd.crosstab\n  pd.crosstab(\n      index=df['row'], columns=df['col'],\n      values=df['val0'], aggfunc='mean').fillna(0)\n\n\n\n\nQuestion 4\n\nCan I get something other than mean, like maybe sum?\n\n\npd.DataFrame.pivot_table\n  df.pivot_table(\n      values='val0', index='row', columns='col',\n      fill_value=0, aggfunc='sum')\n\n  col   col0  col1  col2  col3  col4\n  row\n  row0  0.77  1.21  0.00  0.86  0.65\n  row2  0.13  0.00  0.79  0.50  0.50\n  row3  0.00  0.31  0.00  1.09  0.00\n  row4  0.00  0.10  0.79  1.52  0.24\n\n\npd.DataFrame.groupby\n  df.groupby(['row', 'col'])['val0'].sum().unstack(fill_value=0)\n\n\npd.crosstab\n  pd.crosstab(\n      index=df['row'], columns=df['col'],\n      values=df['val0'], aggfunc='sum').fillna(0)\n\n\n\n\nQuestion 5\n\nCan I do more that one aggregation at a time?\n\nNotice that for pivot_table and crosstab I needed to pass list of callables.  On the other hand, groupby.agg is able to take strings for a limited number of special functions.  groupby.agg would also have taken the same callables we passed to the others, but it is often more efficient to leverage the string function names as there are efficiencies to be gained.\n\npd.DataFrame.pivot_table\n  df.pivot_table(\n      values='val0', index='row', columns='col',\n      fill_value=0, aggfunc=[np.size, np.mean])\n\n       size                      mean\n  col  col0 col1 col2 col3 col4  col0   col1   col2   col3  col4\n  row\n  row0    1    2    0    1    1  0.77  0.605  0.000  0.860  0.65\n  row2    1    0    2    1    2  0.13  0.000  0.395  0.500  0.25\n  row3    0    1    0    2    0  0.00  0.310  0.000  0.545  0.00\n  row4    0    1    2    2    1  0.00  0.100  0.395  0.760  0.24\n\n\npd.DataFrame.groupby\n  df.groupby(['row', 'col'])['val0'].agg(['size', 'mean']).unstack(fill_value=0)\n\n\npd.crosstab\n  pd.crosstab(\n      index=df['row'], columns=df['col'],\n      values=df['val0'], aggfunc=[np.size, np.mean]).fillna(0, downcast='infer')\n\n\n\n\nQuestion 6\n\nCan I aggregate over multiple value columns?\n\n\npd.DataFrame.pivot_table we pass values=['val0', 'val1'] but we could've left that off completely\n  df.pivot_table(\n      values=['val0', 'val1'], index='row', columns='col',\n      fill_value=0, aggfunc='mean')\n\n        val0                             val1\n  col   col0   col1   col2   col3  col4  col0   col1  col2   col3  col4\n  row\n  row0  0.77  0.605  0.000  0.860  0.65  0.01  0.745  0.00  0.010  0.02\n  row2  0.13  0.000  0.395  0.500  0.25  0.45  0.000  0.34  0.440  0.79\n  row3  0.00  0.310  0.000  0.545  0.00  0.00  0.230  0.00  0.075  0.00\n  row4  0.00  0.100  0.395  0.760  0.24  0.00  0.070  0.42  0.300  0.46\n\n\npd.DataFrame.groupby\n  df.groupby(['row', 'col'])['val0', 'val1'].mean().unstack(fill_value=0)\n\n\n\n\nQuestion 7\n\nCan Subdivide by multiple columns?\n\n\npd.DataFrame.pivot_table\n  df.pivot_table(\n      values='val0', index='row', columns=['item', 'col'],\n      fill_value=0, aggfunc='mean')\n\n  item item0             item1                         item2\n  col   col2  col3  col4  col0  col1  col2  col3  col4  col0   col1  col3  col4\n  row\n  row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.605  0.86  0.65\n  row2  0.35  0.00  0.37  0.00  0.00  0.44  0.00  0.00  0.13  0.000  0.50  0.13\n  row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.000  0.28  0.00\n  row4  0.15  0.64  0.00  0.00  0.10  0.64  0.88  0.24  0.00  0.000  0.00  0.00\n\n\npd.DataFrame.groupby\n  df.groupby(\n      ['row', 'item', 'col']\n  )['val0'].mean().unstack(['item', 'col']).fillna(0).sort_index(1)\n\n\n\n\nQuestion 8\n\nCan Subdivide by multiple columns?\n\n\npd.DataFrame.pivot_table\n  df.pivot_table(\n      values='val0', index=['key', 'row'], columns=['item', 'col'],\n      fill_value=0, aggfunc='mean')\n\n  item      item0             item1                         item2\n  col        col2  col3  col4  col0  col1  col2  col3  col4  col0  col1  col3  col4\n  key  row\n  key0 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.86  0.00\n       row2  0.00  0.00  0.37  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.50  0.00\n       row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.00  0.00  0.00\n       row4  0.15  0.64  0.00  0.00  0.00  0.00  0.00  0.24  0.00  0.00  0.00  0.00\n  key1 row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.81  0.00  0.65\n       row2  0.35  0.00  0.00  0.00  0.00  0.44  0.00  0.00  0.00  0.00  0.00  0.13\n       row3  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.28  0.00\n       row4  0.00  0.00  0.00  0.00  0.10  0.00  0.00  0.00  0.00  0.00  0.00  0.00\n  key2 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.40  0.00  0.00\n       row2  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.13  0.00  0.00  0.00\n       row4  0.00  0.00  0.00  0.00  0.00  0.64  0.88  0.00  0.00  0.00  0.00  0.00\n\n\npd.DataFrame.groupby\n  df.groupby(\n      ['key', 'row', 'item', 'col']\n  )['val0'].mean().unstack(['item', 'col']).fillna(0).sort_index(1)\n\n\npd.DataFrame.set_index because the set of keys are unique for both rows and columns\n  df.set_index(\n      ['key', 'row', 'item', 'col']\n  )['val0'].unstack(['item', 'col']).fillna(0).sort_index(1)\n\n\n\n\nQuestion 9\n\nCan I aggregate the frequency in which the column and rows occur together, aka \"cross tabulation\"?\n\n\npd.DataFrame.pivot_table\n  df.pivot_table(index='row', columns='col', fill_value=0, aggfunc='size')\n\n      col   col0  col1  col2  col3  col4\n  row\n  row0     1     2     0     1     1\n  row2     1     0     2     1     2\n  row3     0     1     0     2     0\n  row4     0     1     2     2     1\n\n\npd.DataFrame.groupby\n  df.groupby(['row', 'col'])['val0'].size().unstack(fill_value=0)\n\n\npd.crosstab\n  pd.crosstab(df['row'], df['col'])\n\n\npd.factorize + np.bincount\n  # get integer factorization `i` and unique values `r`\n  # for column `'row'`\n  i, r = pd.factorize(df['row'].values)\n  # get integer factorization `j` and unique values `c`\n  # for column `'col'`\n  j, c = pd.factorize(df['col'].values)\n  # `n` will be the number of rows\n  # `m` will be the number of columns\n  n, m = r.size, c.size\n  # `i * m + j` is a clever way of counting the\n  # factorization bins assuming a flat array of length\n  # `n * m`.  Which is why we subsequently reshape as `(n, m)`\n  b = np.bincount(i * m + j, minlength=n * m).reshape(n, m)\n  # BTW, whenever I read this, I think 'Bean, Rice, and Cheese'\n  pd.DataFrame(b, r, c)\n\n        col3  col2  col0  col1  col4\n  row3     2     0     0     1     0\n  row2     1     2     1     0     2\n  row0     1     0     1     2     1\n  row4     2     2     0     1     1\n\n\npd.get_dummies\n  pd.get_dummies(df['row']).T.dot(pd.get_dummies(df['col']))\n\n        col0  col1  col2  col3  col4\n  row0     1     2     0     1     1\n  row2     1     0     2     1     2\n  row3     0     1     0     2     0\n  row4     0     1     2     2     1\n\n\n\n\nQuestion 10\n\nHow do I convert a DataFrame from long to wide by pivoting on ONLY two\ncolumns?\n\n\nDataFrame.pivot\nThe first step is to assign a number to each row - this number will be the row index of that value in the pivoted result. This is done using GroupBy.cumcount:\n  df2.insert(0, 'count', df2.groupby('A').cumcount())\n  df2\n\n     count  A   B\n  0      0  a   0\n  1      1  a  11\n  2      2  a   2\n  3      3  a  11\n  4      0  b  10\n  5      1  b  10\n  6      2  b  14\n  7      0  c   7\n\nThe second step is to use the newly created column as the index to call DataFrame.pivot.\n  df2.pivot(*df2)\n  # df2.pivot(index='count', columns='A', values='B')\n\n  A         a     b    c\n  count\n  0       0.0  10.0  7.0\n  1      11.0  10.0  NaN\n  2       2.0  14.0  NaN\n  3      11.0   NaN  NaN\n\n\nDataFrame.pivot_table\nWhereas DataFrame.pivot only accepts columns, DataFrame.pivot_table also accepts arrays, so the GroupBy.cumcount can be passed directly as the index without creating an explicit column.\n  df2.pivot_table(index=df2.groupby('A').cumcount(), columns='A', values='B')\n\n  A         a     b    c\n  0       0.0  10.0  7.0\n  1      11.0  10.0  NaN\n  2       2.0  14.0  NaN\n  3      11.0   NaN  NaN\n\n\n\n\nQuestion 11\n\nHow do I flatten the multiple index to single index after pivot\n\nIf columns type object with string join\ndf.columns = df.columns.map('|'.join)\n\nelse format\ndf.columns = df.columns.map('{0[0]}|{0[1]}'.format)\n\n    ",
        "_Respuesta__votes": 373,
        "comentarios": [
            {
                "_id": 248,
                "_Comentario__descripcion": "Could you please consider extending official docs?",
                "_Comentario__fecha": "2017-12-15 10:31:13Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "MaxU",
                "usuario_id": null
            },
            {
                "_id": 249,
                "_Comentario__descripcion": "what happened with the answer to Question #10? I get KeyError: 'A'. Is there more to the answer?",
                "_Comentario__fecha": "2019-09-27 18:06:51Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Monica Heddneck",
                "usuario_id": null
            },
            {
                "_id": 250,
                "_Comentario__descripcion": "@MonicaHeddneck I'll review it again and update if necessary.  However, 'A' is assuming there is a column 'A' in your dataframe to group by.",
                "_Comentario__fecha": "2019-09-27 20:19:45Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "piRSquared",
                "usuario_id": null
            },
            {
                "_id": 251,
                "_Comentario__descripcion": "it is not necessary to insert the column in question 10, it can be passed directly as an argument in the pivot table",
                "_Comentario__fecha": "2020-04-01 18:03:56Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ansev",
                "usuario_id": null
            },
            {
                "_id": 252,
                "_Comentario__descripcion": "@MonicaHeddneck I believe the references to df should be changed to df2. If you were following along like I was df is the earlier dataframe created.",
                "_Comentario__fecha": "2020-04-14 06:16:50Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "CopOnTheRun",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 179,
        "_Respuesta__fecha": "2020-06-05 20:59:49Z",
        "_Respuesta__descripcion": "\nTo extend @piRSquared's answer another version of Question 10\n\nQuestion 10.1\n\nDataFrame:\n\nd = data = {'A': {0: 1, 1: 1, 2: 1, 3: 2, 4: 2, 5: 3, 6: 5},\n 'B': {0: 'a', 1: 'b', 2: 'c', 3: 'a', 4: 'b', 5: 'a', 6: 'c'}}\ndf = pd.DataFrame(d)\n\n   A  B\n0  1  a\n1  1  b\n2  1  c\n3  2  a\n4  2  b\n5  3  a\n6  5  c\n\n\nOutput:\n\n   0     1     2\nA\n1  a     b     c\n2  a     b  None\n3  a  None  None\n5  c  None  None\n\n\n\n\nUsing df.groupby and pd.Series.tolist\n\nt = df.groupby('A')['B'].apply(list)\nout = pd.DataFrame(t.tolist(),index=t.index)\nout\n   0     1     2\nA\n1  a     b     c\n2  a     b  None\n3  a  None  None\n5  c  None  None\n\n\nOr \nA much better alternative using pd.pivot_table with df.squeeze.\n\nt = df.pivot_table(index='A',values='B',aggfunc=list).squeeze()\nout = pd.DataFrame(t.tolist(),index=t.index)\n\n    ",
        "_Respuesta__votes": 13,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 180,
        "_Respuesta__fecha": "2021-02-17 07:42:14Z",
        "_Respuesta__descripcion": "\nTo better understand how pivot works you can look at the example from Pandas documentation:\n\ndf = pd.DataFrame({\n    'foo': ['one', 'one', 'one', 'two', 'two', 'two'],\n    'bar': ['A', 'B', 'C', 'A', 'B', 'C'],\n    'baz': [1, 2, 3, 4, 5, 6],\n    'zoo': ['x', 'y', 'z', 'q', 'w', 't']\n})\n\nInput Table:\n   foo bar  baz zoo\n0  one   A    1   x\n1  one   B    2   y\n2  one   C    3   z\n3  two   A    4   q\n4  two   B    5   w\n5  two   C    6   t\n\nPivot:\npd.pivot(\n    data=df,        \n    index='foo',    # Column to use to make new frame\u2019s index. If None, uses existing index.\n    columns='bar',  # Column to use to make new frame\u2019s columns.\n    values='baz'    # Column(s) to use for populating new frame\u2019s values.\n)\n\nOutput table:\nbar  A  B  C\nfoo         \none  1  2  3\ntwo  4  5  6\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [
            {
                "_id": 253,
                "_Comentario__descripcion": "See this question.",
                "_Comentario__fecha": "2021-04-05 20:54:08Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mykola Zotko",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 182,
        "_Respuesta__fecha": "2021-07-31 17:38:01Z",
        "_Respuesta__descripcion": "\nThis post aims to give readers a primer on SQL-flavored merging with Pandas, how to use it, and when not to use it.\nIn particular, here's what this post will go through:\n\nThe basics - types of joins (LEFT, RIGHT, OUTER, INNER)\n\nmerging with different column names\nmerging with multiple columns\navoiding duplicate merge key column in output\n\n\n\nWhat this post (and other posts by me on this thread) will not go through:\n\nPerformance-related discussions and timings (for now). Mostly notable mentions of better alternatives, wherever appropriate.\nHandling suffixes, removing extra columns, renaming outputs, and other specific use cases. There are other (read: better) posts that deal with that, so figure it out!\n\n\nNote\nMost examples default to INNER JOIN operations while demonstrating various features, unless otherwise specified.\nFurthermore, all the DataFrames here can be copied and replicated so\nyou can play with them. Also, see this\npost\non how to read DataFrames from your clipboard.\nLastly, all visual representation of JOIN operations have been hand-drawn using Google Drawings. Inspiration from here.\n\n\n\nEnough talk - just show me how to use merge!\nSetup & Basics\nnp.random.seed(0)\nleft = pd.DataFrame({'key': ['A', 'B', 'C', 'D'], 'value': np.random.randn(4)})\nright = pd.DataFrame({'key': ['B', 'D', 'E', 'F'], 'value': np.random.randn(4)})\n\nleft\n\n  key     value\n0   A  1.764052\n1   B  0.400157\n2   C  0.978738\n3   D  2.240893\n\nright\n\n  key     value\n0   B  1.867558\n1   D -0.977278\n2   E  0.950088\n3   F -0.151357\n\nFor the sake of simplicity, the key column has the same name (for now).\nAn INNER JOIN is represented by\n\n\nNote\nThis, along with the forthcoming figures all follow this convention:\n\nblue indicates rows that are present in the merge result\nred indicates rows that are excluded from the result (i.e., removed)\ngreen indicates missing values that are replaced with NaNs in the result\n\n\nTo perform an INNER JOIN, call merge on the left DataFrame, specifying the right DataFrame and the join key (at the very least) as arguments.\nleft.merge(right, on='key')\n# Or, if you want to be explicit\n# left.merge(right, on='key', how='inner')\n\n  key   value_x   value_y\n0   B  0.400157  1.867558\n1   D  2.240893 -0.977278\n\nThis returns only rows from left and right which share a common key (in this example, \"B\" and \"D).\nA LEFT OUTER JOIN, or LEFT JOIN  is represented by\n\nThis can be performed by specifying how='left'.\nleft.merge(right, on='key', how='left')\n\n  key   value_x   value_y\n0   A  1.764052       NaN\n1   B  0.400157  1.867558\n2   C  0.978738       NaN\n3   D  2.240893 -0.977278\n\nCarefully note the placement of NaNs here. If you specify how='left', then only keys from left are used, and missing data from right is replaced by NaN.\nAnd similarly, for a RIGHT OUTER JOIN, or RIGHT JOIN which is...\n\n...specify how='right':\nleft.merge(right, on='key', how='right')\n\n  key   value_x   value_y\n0   B  0.400157  1.867558\n1   D  2.240893 -0.977278\n2   E       NaN  0.950088\n3   F       NaN -0.151357\n\nHere, keys from right are used, and missing data from left is replaced by NaN.\nFinally, for the FULL OUTER JOIN, given by\n\nspecify how='outer'.\nleft.merge(right, on='key', how='outer')\n\n  key   value_x   value_y\n0   A  1.764052       NaN\n1   B  0.400157  1.867558\n2   C  0.978738       NaN\n3   D  2.240893 -0.977278\n4   E       NaN  0.950088\n5   F       NaN -0.151357\n\nThis uses the keys from both frames, and NaNs are inserted for missing rows in both.\nThe documentation summarizes these various merges nicely:\n\n\nOther JOINs - LEFT-Excluding, RIGHT-Excluding, and FULL-Excluding/ANTI JOINs\nIf you need LEFT-Excluding JOINs and RIGHT-Excluding JOINs in two steps.\nFor LEFT-Excluding JOIN, represented as\n\nStart by performing a LEFT OUTER JOIN and then filtering (excluding!) rows coming from left only,\n(left.merge(right, on='key', how='left', indicator=True)\n     .query('_merge == \"left_only\"')\n     .drop('_merge', 1))\n\n  key   value_x  value_y\n0   A  1.764052      NaN\n2   C  0.978738      NaN\n\nWhere,\nleft.merge(right, on='key', how='left', indicator=True)\n\n  key   value_x   value_y     _merge\n0   A  1.764052       NaN  left_only\n1   B  0.400157  1.867558       both\n2   C  0.978738       NaN  left_only\n3   D  2.240893 -0.977278       both\nAnd similarly, for a RIGHT-Excluding JOIN,\n\n(left.merge(right, on='key', how='right', indicator=True)\n     .query('_merge == \"right_only\"')\n     .drop('_merge', 1))\n\n  key  value_x   value_y\n2   E      NaN  0.950088\n3   F      NaN -0.151357\nLastly, if you are required to do a merge that only retains keys from the left or right, but not both (IOW, performing an ANTI-JOIN),\n\nYou can do this in similar fashion\u2014\n(left.merge(right, on='key', how='outer', indicator=True)\n     .query('_merge != \"both\"')\n     .drop('_merge', 1))\n\n  key   value_x   value_y\n0   A  1.764052       NaN\n2   C  0.978738       NaN\n4   E       NaN  0.950088\n5   F       NaN -0.151357\n\n\nDifferent names for key columns\nIf the key columns are named differently\u2014for example, left has keyLeft, and right has keyRight instead of key\u2014then you will have to specify left_on and right_on as arguments instead of on:\nleft2 = left.rename({'key':'keyLeft'}, axis=1)\nright2 = right.rename({'key':'keyRight'}, axis=1)\n\nleft2\n\n  keyLeft     value\n0       A  1.764052\n1       B  0.400157\n2       C  0.978738\n3       D  2.240893\n\nright2\n\n  keyRight     value\n0        B  1.867558\n1        D -0.977278\n2        E  0.950088\n3        F -0.151357\n\n\nleft2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')\n\n  keyLeft   value_x keyRight   value_y\n0       B  0.400157        B  1.867558\n1       D  2.240893        D -0.977278\n\n\nAvoiding duplicate key column in output\nWhen merging on keyLeft from left and keyRight from right, if you only want either of the keyLeft or keyRight (but not both) in the output, you can start by setting the index as a preliminary step.\nleft3 = left2.set_index('keyLeft')\nleft3.merge(right2, left_index=True, right_on='keyRight')\n\n    value_x keyRight   value_y\n0  0.400157        B  1.867558\n1  2.240893        D -0.977278\n\nContrast this with the output of the command just before (that is, the output of left2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')), you'll notice keyLeft is missing. You can figure out what column to keep based on which frame's index is set as the key. This may matter when, say, performing some OUTER JOIN operation.\n\nMerging only a single column from one of the DataFrames\nFor example, consider\nright3 = right.assign(newcol=np.arange(len(right)))\nright3\n  key     value  newcol\n0   B  1.867558       0\n1   D -0.977278       1\n2   E  0.950088       2\n3   F -0.151357       3\n\nIf you are required to merge only \"new_val\" (without any of the other columns), you can usually just subset columns before merging:\nleft.merge(right3[['key', 'newcol']], on='key')\n\n  key     value  newcol\n0   B  0.400157       0\n1   D  2.240893       1\n\nIf you're doing a LEFT OUTER JOIN, a more performant solution would involve map:\n# left['newcol'] = left['key'].map(right3.set_index('key')['newcol']))\nleft.assign(newcol=left['key'].map(right3.set_index('key')['newcol']))\n\n  key     value  newcol\n0   A  1.764052     NaN\n1   B  0.400157     0.0\n2   C  0.978738     NaN\n3   D  2.240893     1.0\n\nAs mentioned, this is similar to, but faster than\nleft.merge(right3[['key', 'newcol']], on='key', how='left')\n\n  key     value  newcol\n0   A  1.764052     NaN\n1   B  0.400157     0.0\n2   C  0.978738     NaN\n3   D  2.240893     1.0\n\n\nMerging on multiple columns\nTo join on more than one column, specify a list for on (or left_on and right_on, as appropriate).\nleft.merge(right, on=['key1', 'key2'] ...)\n\nOr, in the event the names are different,\nleft.merge(right, left_on=['lkey1', 'lkey2'], right_on=['rkey1', 'rkey2'])\n\n\nOther useful merge* operations and functions\n\nMerging a DataFrame with Series on index: See this answer.\n\nBesides merge, DataFrame.update and DataFrame.combine_first are also used in certain cases to update one DataFrame with another.\n\npd.merge_ordered is a useful function for ordered JOINs.\n\npd.merge_asof (read: merge_asOf) is useful for approximate joins.\n\n\nThis section only covers the very basics, and is designed to only whet your appetite. For more examples and cases, see the documentation on merge, join, and concat as well as the links to the function specifications.\n\n\nContinue Reading\nJump to other topics in Pandas Merging 101 to continue learning:\n\nMerging basics - basic types of joins *\n\nIndex-based joins\n\nGeneralizing to multiple DataFrames\n\nCross join\n\n\n*You are here.\n    ",
        "_Respuesta__votes": 880,
        "comentarios": [
            {
                "_id": 256,
                "_Comentario__descripcion": "If anyone is confused by the table of contents at the end of each post, I split up this massive answer into 4 separate ones, 3 on this question and 1 on another. The way it was setup previously made it harder to reference folks to specific topics. This allows you to bookmark separate topics easily now!",
                "_Comentario__fecha": "2020-12-17 10:17:28Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "cs95",
                "usuario_id": null
            },
            {
                "_id": 257,
                "_Comentario__descripcion": "This is an awesome resource! The only question I still have is why call it merge instead of join, and join instead of merge?",
                "_Comentario__fecha": "2021-04-08 22:31:14Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ThatNewGuy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 183,
        "_Respuesta__fecha": "2019-10-11 17:36:29Z",
        "_Respuesta__descripcion": "\nA supplemental visual view of pd.concat([df0, df1], kwargs). \nNotice that, kwarg axis=0 or axis=1 's meaning is not as intuitive as df.mean() or df.apply(func)\n\n\n\n\n    ",
        "_Respuesta__votes": 75,
        "comentarios": [
            {
                "_id": 258,
                "_Comentario__descripcion": "This is a nice diagram. May I ask how you produced it?",
                "_Comentario__fecha": "2019-05-20 17:27:56Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "cs95",
                "usuario_id": null
            },
            {
                "_id": 259,
                "_Comentario__descripcion": "google doc's built-in \"insert ==> drawing... ==> new\" (as of 2019-May). But, to be clear: the only reason I used google doc for this picture  is because my notes is stored in google doc, and I would like a picture that can be modified quickly within google doc itself. Actually now you mentioned it, the google doc's drawing tool is pretty neat.",
                "_Comentario__fecha": "2019-05-21 18:19:31Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "eliu",
                "usuario_id": null
            },
            {
                "_id": 260,
                "_Comentario__descripcion": "Wow, this is great. Coming from the SQL world, \"vertical\" join is not a join in my head, as the table's structure is always fixed. Now even think pandas should consolidate concat and merge with a direction parameter being horizontal or vertical.",
                "_Comentario__fecha": "2019-08-01 11:16:40Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Ufos",
                "usuario_id": null
            },
            {
                "_id": 261,
                "_Comentario__descripcion": "@Ufos Isn't that exactly what axis=1 and axis=0 is?",
                "_Comentario__fecha": "2019-08-06 17:31:44Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "cs95",
                "usuario_id": null
            },
            {
                "_id": 262,
                "_Comentario__descripcion": "yes, there're now merge and concat and axis and whatever. However, as @eliu shows, it's all just the same concept of merge with \"left\" and \"right\" and \"horizontal\" or \"vertical\".  I, personally, have to look into the documentation every time I have to remember which \"axis\" is 0 and which is 1.",
                "_Comentario__fecha": "2019-08-19 09:32:30Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Ufos",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 184,
        "_Respuesta__fecha": "2021-01-24 00:26:49Z",
        "_Respuesta__descripcion": "\nIn this answer, I will consider practical examples.\nThe first one, is of pandas.concat.\nThe second one, of merging dataframes from the index of one and the column of another one.\n\n1. pandas.concat\nConsidering the following DataFrames with the same column names:\nPreco2018 with size (8784, 5)\n\nPreco 2019 with size (8760, 5)\n\nThat have the same column names.\nYou can combine them using pandas.concat, by simply\nimport pandas as pd\n\nframes = [Preco2018, Preco2019]\n\ndf_merged = pd.concat(frames)\n\nWhich results in a DataFrame with the following size (17544, 5)\n\nIf you want to visualize, it ends up working like this\n\n(Source)\n\n2. Merge by Column and Index\nIn this part, I will consider a specific case: If one wants to merge the index of one dataframe and the column of another dataframe.\nLet's say one has the dataframe Geo with 54 columns, being one of the columns the Date Data, which is of type datetime64[ns].\n\nAnd the dataframe Price that has one column with the price and the index corresponds to the dates\n\nIn this specific case, to merge them, one uses pd.merge\nmerged = pd.merge(Price, Geo, left_index=True, right_on='Data')\n\nWhich results in the following dataframe\n\n    ",
        "_Respuesta__votes": 18,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 185,
        "_Respuesta__fecha": "2020-12-06 12:56:51Z",
        "_Respuesta__descripcion": "\nThis post will go through the following topics:\n\nMerging with index under different conditions\n\noptions for index-based joins: merge, join, concat\nmerging on indexes\nmerging on index of one, column of other\n\n\neffectively using named indexes to simplify merging syntax\n\nBACK TO TOP\n\n\nIndex-based joins\nTL;DR\n\nThere are a few options, some simpler than others depending on the use\ncase.\n\nDataFrame.merge with left_index and right_index (or left_on and right_on using names indexes)\n\nsupports inner/left/right/full\ncan only join two at a time\nsupports column-column, index-column, index-index joins\n\n\nDataFrame.join (join on index)\n\nsupports inner/left (default)/right/full\ncan join multiple DataFrames at a time\nsupports index-index joins\n\n\npd.concat (joins on index)\n\nsupports inner/full (default)\ncan join multiple DataFrames at a time\nsupports index-index joins\n\n\n\n\n\nIndex to index joins\nSetup & Basics\nimport pandas as pd\nimport numpy as np\n\nnp.random.seed([3, 14])\nleft = pd.DataFrame(data={'value': np.random.randn(4)}, \n                    index=['A', 'B', 'C', 'D'])    \nright = pd.DataFrame(data={'value': np.random.randn(4)},  \n                     index=['B', 'D', 'E', 'F'])\nleft.index.name = right.index.name = 'idxkey'\n\nleft\n           value\nidxkey          \nA      -0.602923\nB      -0.402655\nC       0.302329\nD      -0.524349\n\nright\n \n           value\nidxkey          \nB       0.543843\nD       0.013135\nE      -0.326498\nF       1.385076\n\nTypically, an inner join on index would look like this:\nleft.merge(right, left_index=True, right_index=True)\n\n         value_x   value_y\nidxkey                    \nB      -0.402655  0.543843\nD      -0.524349  0.013135\n\nOther joins follow similar syntax.\nNotable Alternatives\n\nDataFrame.join defaults to joins on the index. DataFrame.join does a LEFT OUTER JOIN by default, so how='inner' is necessary here.\n left.join(right, how='inner', lsuffix='_x', rsuffix='_y')\n\n          value_x   value_y\n idxkey                    \n B      -0.402655  0.543843\n D      -0.524349  0.013135\n\nNote that I needed to specify the lsuffix and rsuffix arguments since join would otherwise error out:\n left.join(right)\n ValueError: columns overlap but no suffix specified: Index(['value'], dtype='object')\n\nSince the column names are the same. This would not be a problem if they were differently named.\n left.rename(columns={'value':'leftvalue'}).join(right, how='inner')\n\n         leftvalue     value\n idxkey                     \n B       -0.402655  0.543843\n D       -0.524349  0.013135\n\n\npd.concat joins on the index and can join two or more DataFrames at once. It does a full outer join by default, so how='inner' is required here..\n pd.concat([left, right], axis=1, sort=False, join='inner')\n\n            value     value\n idxkey                    \n B      -0.402655  0.543843\n D      -0.524349  0.013135\n\nFor more information on concat, see this post.\n\n\n\nIndex to Column joins\nTo perform an inner join using index of left, column of right, you will use DataFrame.merge a combination of left_index=True and right_on=....\nright2 = right.reset_index().rename({'idxkey' : 'colkey'}, axis=1)\nright2\n \n  colkey     value\n0      B  0.543843\n1      D  0.013135\n2      E -0.326498\n3      F  1.385076\n\nleft.merge(right2, left_index=True, right_on='colkey')\n\n    value_x colkey   value_y\n0 -0.402655      B  0.543843\n1 -0.524349      D  0.013135\n\nOther joins follow a similar structure. Note that only merge can perform index to column joins. You can join on multiple columns, provided the number of index levels on the left equals the number of columns on the right.\njoin and concat are not capable of mixed merges. You will need to set the index as a pre-step using DataFrame.set_index.\n\nEffectively using Named Index [pandas >= 0.23]\nIf your index is named, then from pandas >= 0.23, DataFrame.merge allows you to specify the index name to on (or left_on and right_on as necessary).\nleft.merge(right, on='idxkey')\n\n         value_x   value_y\nidxkey                    \nB      -0.402655  0.543843\nD      -0.524349  0.013135\n\nFor the previous example of merging with the index of left, column of right, you can use left_on with the index name of left:\nleft.merge(right2, left_on='idxkey', right_on='colkey')\n\n    value_x colkey   value_y\n0 -0.402655      B  0.543843\n1 -0.524349      D  0.013135\n\n\n\nContinue Reading\nJump to other topics in Pandas Merging 101 to continue learning:\n\nMerging basics - basic types of joins\n\nIndex-based joins*\n\nGeneralizing to multiple DataFrames\n\nCross join\n\n\n* you are here \n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 186,
        "_Respuesta__fecha": "2020-12-06 12:56:31Z",
        "_Respuesta__descripcion": "\nThis post will go through the following topics:\n\nhow to correctly generalize to multiple DataFrames (and why merge has shortcomings here)\nmerging on unique keys\nmerging on non-unqiue keys\n\nBACK TO TOP\n\n\nGeneralizing to multiple DataFrames\nOftentimes, the situation arises when multiple DataFrames are to be merged together. Naively, this can be done by chaining merge calls:\ndf1.merge(df2, ...).merge(df3, ...)\n\nHowever, this quickly gets out of hand for many DataFrames. Furthermore, it may be necessary to generalise for an unknown number of DataFrames.\nHere I introduce pd.concat for multi-way joins on unique keys, and DataFrame.join for multi-way joins on non-unique keys. First, the setup.\n# Setup.\nnp.random.seed(0)\nA = pd.DataFrame({'key': ['A', 'B', 'C', 'D'], 'valueA': np.random.randn(4)})    \nB = pd.DataFrame({'key': ['B', 'D', 'E', 'F'], 'valueB': np.random.randn(4)})\nC = pd.DataFrame({'key': ['D', 'E', 'J', 'C'], 'valueC': np.ones(4)})\ndfs = [A, B, C] \n\n# Note, the \"key\" column values are unique, so the index is unique.\nA2 = A.set_index('key')\nB2 = B.set_index('key')\nC2 = C.set_index('key')\n\ndfs2 = [A2, B2, C2]\n\n\nMultiway merge on unique keys\nIf your keys (here, the key could either be a column or an index) are unique, then you can use pd.concat. Note that pd.concat joins DataFrames on the index.\n# merge on `key` column, you'll need to set the index before concatenating\npd.concat([\n    df.set_index('key') for df in dfs], axis=1, join='inner'\n).reset_index()\n\n  key    valueA    valueB  valueC\n0   D  2.240893 -0.977278     1.0\n\n# merge on `key` index\npd.concat(dfs2, axis=1, sort=False, join='inner')\n\n       valueA    valueB  valueC\nkey                            \nD    2.240893 -0.977278     1.0\n\nOmit join='inner' for a FULL OUTER JOIN. Note that you cannot specify LEFT or RIGHT OUTER joins (if you need these, use join, described below).\n\nMultiway merge on keys with duplicates\nconcat is fast, but has its shortcomings. It cannot handle duplicates.\nA3 = pd.DataFrame({'key': ['A', 'B', 'C', 'D', 'D'], 'valueA': np.random.randn(5)})\n\n\npd.concat([df.set_index('key') for df in [A3, B, C]], axis=1, join='inner')\nValueError: Shape of passed values is (3, 4), indices imply (3, 2)\n\nIn this situation, we can use join since it can handle non-unique keys (note that join joins DataFrames on their index; it calls merge under the hood and does a LEFT OUTER JOIN unless otherwise specified).\n# join on `key` column, set as the index first\n# For inner join. For left join, omit the \"how\" argument.\nA.set_index('key').join(\n    [df.set_index('key') for df in (B, C)], how='inner').reset_index()\n\n  key    valueA    valueB  valueC\n0   D  2.240893 -0.977278     1.0\n\n# join on `key` index\nA3.set_index('key').join([B2, C2], how='inner')\n\n       valueA    valueB  valueC\nkey                            \nD    1.454274 -0.977278     1.0\nD    0.761038 -0.977278     1.0\n\n\n\nContinue Reading\nJump to other topics in Pandas Merging 101 to continue learning:\n\nMerging basics - basic types of joins\n\nIndex-based joins\n\nGeneralizing to multiple DataFrames *\n\nCross join\n\n\n* you are here \n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 187,
        "_Respuesta__fecha": "2021-09-09 09:49:31Z",
        "_Respuesta__descripcion": "\nJoins 101\nThese animations might be better to explain you visually.\nCredits: [Garrick Aden-Buie tidyexplain repo (https://github.com/gadenbuie/tidyexplain)\nInner Join\n\nOuter Join or Full Join\n\nRight Join\n\nLeft Join\n\n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 189,
        "_Respuesta__fecha": "2021-03-19 21:52:42Z",
        "_Respuesta__descripcion": "\nYou can use a list comprehension to create a new list containing only the elements you don't want to remove:\nsomelist = [x for x in somelist if not determine(x)]\n\nOr, by assigning to the slice somelist[:], you can mutate the existing list to contain only the items you want:\nsomelist[:] = [x for x in somelist if not determine(x)]\n\nThis approach could be useful if there are other references to somelist that need to reflect the changes.\nInstead of a comprehension, you could also use itertools. In Python 2:\nfrom itertools import ifilterfalse\nsomelist[:] = ifilterfalse(determine, somelist)\n\nOr in Python 3:\nfrom itertools import filterfalse\nsomelist[:] = filterfalse(determine, somelist)\n\n    ",
        "_Respuesta__votes": 954,
        "comentarios": [
            {
                "_id": 268,
                "_Comentario__descripcion": "Can you make it faster if you know only a few will be deleted, i.e., only delete those and leave the others in-place rather than re-writing them?",
                "_Comentario__fecha": "2011-04-20 19:25:57Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "highBandWidth",
                "usuario_id": null
            },
            {
                "_id": 269,
                "_Comentario__descripcion": "What if my list is huge and can't afford making a copy?",
                "_Comentario__fecha": "2014-11-15 23:43:18Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "jpcgt",
                "usuario_id": null
            },
            {
                "_id": 270,
                "_Comentario__descripcion": "@jpcgt You should use somelist[:] = (x for x in somelist if determine(x)) this will create generator that may not create any unnecessary copies.",
                "_Comentario__fecha": "2015-04-29 14:54:28Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Rostislav Kondratenko",
                "usuario_id": null
            },
            {
                "_id": 271,
                "_Comentario__descripcion": "@RostislavKondratenko: list_ass_slice() function that implements somelist[:]= calls PySequence_Fast() internally. This function always returns a list i.e., @Alex Martelli's solution that already uses a list instead of a generator is most probably more efficient",
                "_Comentario__fecha": "2015-05-07 20:48:28Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "jfs",
                "usuario_id": null
            },
            {
                "_id": 272,
                "_Comentario__descripcion": "Would you care to explain what the differences are between assigning the list comprehension to the list and list clone please? Wouldn't the original list somelist be mutated in both methods?",
                "_Comentario__fecha": "2018-09-24 19:06:14Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Bowen Liu",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 190,
        "_Respuesta__fecha": "2019-05-17 06:05:40Z",
        "_Respuesta__descripcion": "\nThe answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That's different from what you'd be doing by selective removal, as in @Lennart's suggestion -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.\n\nFortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:\n\nsomelist[:] = [tup for tup in somelist if determine(tup)]\n\n\nNote the subtle difference with other answers: this one is NOT assigning to a barename - it's assigning to a list slice that just happens to be the entire list, thereby replacing the list contents within the same Python list object, rather than just reseating one reference (from previous list object to new list object) like the other answers.\n    ",
        "_Respuesta__votes": 641,
        "comentarios": [
            {
                "_id": 273,
                "_Comentario__descripcion": "How do I do the same sliced assignment with a dict? In Python 2.6?",
                "_Comentario__fecha": "2011-03-25 19:29:37Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "PaulMcG",
                "usuario_id": null
            },
            {
                "_id": 274,
                "_Comentario__descripcion": "@Paul: Since dicts are unordered, slices are meaningless for dicts.  If your want to replace the contents of dict a by the contents of dict b, use a.clear(); a.update(b).",
                "_Comentario__fecha": "2011-04-01 23:51:47Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Sven Marnach",
                "usuario_id": null
            },
            {
                "_id": 275,
                "_Comentario__descripcion": "Why can 'reseating' one of the references by replacing what the variable refers to cause bugs?  It seems like that would only be a potential problem in multi-threaded applications, not single-threaded.",
                "_Comentario__fecha": "2011-08-07 22:59:53Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Derek Dahmer",
                "usuario_id": null
            },
            {
                "_id": 276,
                "_Comentario__descripcion": "@Derek x = ['foo','bar','baz']; y = x; x = [item for item in x if determine(item)]; This reassigns x to the result of the list comprehension, but y still refers to the original list ['foo','bar','baz']. If you expected x and y to refer to the same list, you may have introduced bugs. You prevent this by assigning to a slice of the entire list, as Alex shows, and I show here: x = [\"foo\",\"bar\",\"baz\"]; y = x; x[:] = [item for item in x if determine(item)];. The list is modified in place. ensuring that all references to the list (both x and y here) refer to the new list.",
                "_Comentario__fecha": "2011-11-15 19:38:42Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Steven T. Snyder",
                "usuario_id": null
            },
            {
                "_id": 277,
                "_Comentario__descripcion": "in fact, using filter function too creates a new list, does not modify elements in place... only olist[:] = [i for i in olist if not dislike(i)]",
                "_Comentario__fecha": "2016-07-13 08:48:01Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "John Strood",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 191,
        "_Respuesta__fecha": "2019-12-02 14:50:05Z",
        "_Respuesta__descripcion": "\nYou need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.\n\nFor example (depends on what type of list):\n\nfor tup in somelist[:]:\n    etc....\n\n\nAn example:\n\n>>> somelist = range(10)\n>>> for x in somelist:\n...     somelist.remove(x)\n>>> somelist\n[1, 3, 5, 7, 9]\n\n>>> somelist = range(10)\n>>> for x in somelist[:]:\n...     somelist.remove(x)\n>>> somelist\n[]\n\n    ",
        "_Respuesta__votes": 348,
        "comentarios": [
            {
                "_id": 278,
                "_Comentario__descripcion": "@Zen Because the second one iterates over a copy of the list. So when you modify the original list, you do not modify the copy that you iterate over.",
                "_Comentario__fecha": "2014-06-18 13:47:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Lennart Regebro",
                "usuario_id": null
            },
            {
                "_id": 279,
                "_Comentario__descripcion": "What's better in doing somelist[:] compared to list(somelist) ?",
                "_Comentario__fecha": "2015-02-04 10:01:22Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mariusz Jamro",
                "usuario_id": null
            },
            {
                "_id": 280,
                "_Comentario__descripcion": "list(somelist) will convert an iterable into a list. somelist[:] makes a copy of an object that supports slicing. So they don't necessarily do the same thing. In this case I want to make a copy of the somelistobject, so I use [:]",
                "_Comentario__fecha": "2015-02-05 12:21:22Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Lennart Regebro",
                "usuario_id": null
            },
            {
                "_id": 281,
                "_Comentario__descripcion": "Note to anyone reading this, this is VERY slow for lists. remove() has to go over the WHOLE list for every iteration, so it will take forever.",
                "_Comentario__fecha": "2015-02-11 23:22:14Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "vitiral",
                "usuario_id": null
            },
            {
                "_id": 282,
                "_Comentario__descripcion": "Big O time doesn't matter when dealing with lists of only a dozen items.  Often clear and simple for future programmers to understand is far more valuable than performance.",
                "_Comentario__fecha": "2016-08-06 17:21:20Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Steve",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 192,
        "_Respuesta__fecha": "2018-10-26 15:10:03Z",
        "_Respuesta__descripcion": "\nfor i in range(len(somelist) - 1, -1, -1):\n    if some_condition(somelist, i):\n        del somelist[i]\n\n\nYou need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)\n\nPython 2 users: replace range by xrange to avoid creating a hardcoded list\n    ",
        "_Respuesta__votes": 153,
        "comentarios": [
            {
                "_id": 283,
                "_Comentario__descripcion": "In recent versions of Python, you can do this even more cleanly by using the reversed() builtin",
                "_Comentario__fecha": "2011-03-23 07:08:43Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "ncoghlan",
                "usuario_id": null
            },
            {
                "_id": 284,
                "_Comentario__descripcion": "reversed() does not create a new list, it creates a reverse iterator over the supplied sequence. Like enumerate(), you have to wrap it in list() to actually get a list out of it.  You may be thinking of sorted(), which does create a new list every time (it has to, so it can sort it).",
                "_Comentario__fecha": "2015-02-12 06:44:12Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ncoghlan",
                "usuario_id": null
            },
            {
                "_id": 285,
                "_Comentario__descripcion": "@Mauris because enumerate returns an iterator and reversed expects a sequence. I guess you could do reversed(list(enumerate(somelist))) if you don't mind creating an extra list in memory.",
                "_Comentario__fecha": "2015-08-02 23:27:15Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "drevicko",
                "usuario_id": null
            },
            {
                "_id": 286,
                "_Comentario__descripcion": "This is O(N*M) for arrays, it is very slow if you remove many items from a large list.  So not recommended.",
                "_Comentario__fecha": "2015-09-15 15:04:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Sam Watkins",
                "usuario_id": null
            },
            {
                "_id": 287,
                "_Comentario__descripcion": "@SamWatkins Yeah, this answer is for when you're removing a couple of elements from a very large array. Less memory usage, but it can be m times slower.",
                "_Comentario__fecha": "2016-02-07 21:36:43Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Navin",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 193,
        "_Respuesta__fecha": "2020-09-25 05:15:39Z",
        "_Respuesta__descripcion": "\nOverview of workarounds\nEither:\n\nuse a linked list implementation/roll your own.\nA linked list is the proper data structure to support efficient item removal, and does not force you to make space/time tradeoffs.\nA CPython list is implemented with dynamic arrays as mentioned here, which is not a good data type to support removals.\nThere doesn't seem to be a linked list in the standard library however:\n\nIs there a linked list predefined library in Python?\nhttps://github.com/ajakubek/python-llist\n\n\nstart a new list() from scratch, and .append() back at the end as mentioned at: https://stackoverflow.com/a/1207460/895245\nThis time efficient, but less space efficient because it keeps an extra copy of the array around during iteration.\n\nuse del with an index as mentioned at: https://stackoverflow.com/a/1207485/895245\nThis is more space efficient since it dispenses the array copy, but it is less time efficient, because removal from dynamic arrays requires shifting all following items back by one, which is O(N).\n\n\nGenerally, if you are doing it quick and dirty and don't want to add a custom LinkedList class, you just want to go for the faster .append() option by default unless memory is a big concern.\nOfficial Python 2 tutorial 4.2. \"for Statements\"\nhttps://docs.python.org/2/tutorial/controlflow.html#for-statements\nThis part of the docs makes it clear that:\n\nyou need to make a copy of the iterated list to modify it\none way to do it is with the slice notation [:]\n\n\nIf you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words[:]:  # Loop over a slice copy of the entire list.\n...     if len(w) > 6:\n...         words.insert(0, w)\n...\n>>> words\n['defenestrate', 'cat', 'window', 'defenestrate']\n\n\nPython 2 documentation 7.3. \"The for statement\"\nhttps://docs.python.org/2/reference/compound_stmts.html#for\nThis part of the docs says once again that you have to make a copy, and gives an actual removal example:\n\nNote: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,\nfor x in a[:]:\n\n\n    if x < 0: a.remove(x)\n\nHowever, I disagree with this implementation, since .remove() has to iterate the entire list to find the value.\nCould Python do this better?\nIt seems like this particular Python API could be improved. Compare it, for instance, with:\n\nJava ListIterator::remove which documents \"This call can only be made once per call to next or previous\"\nC++ std::vector::erase which returns a valid interator to the element after the one removed\n\nboth of which make it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list.\nPerhaps the underlying rationale is that Python lists are assumed to be dynamic array backed, and therefore any type of removal will be time inefficient anyways, while Java has a nicer interface hierarchy with both ArrayList and LinkedList implementations of ListIterator.\nThere doesn't seem to be an explicit linked list type in the Python stdlib either: Python Linked List\n    ",
        "_Respuesta__votes": 63,
        "comentarios": [
            {
                "_id": 288,
                "_Comentario__descripcion": "Finally someone pointed out the actual documentation. I couldn't understand any answers before this one.",
                "_Comentario__fecha": "2021-07-09 13:18:20Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Lukali",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 194,
        "_Respuesta__fecha": "2009-07-30 17:30:54Z",
        "_Respuesta__descripcion": "\nYour best approach for such an example would be a list comprehension\n\nsomelist = [tup for tup in somelist if determine(tup)]\n\n\nIn cases where you're doing something more complex than calling a determine function, I prefer constructing a new list and simply appending to it as I go.  For example\n\nnewlist = []\nfor tup in somelist:\n    # lots of code here, possibly setting things up for calling determine\n    if determine(tup):\n        newlist.append(tup)\nsomelist = newlist\n\n\nCopying the list using remove might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an O(n) remove operation for each element being removed, making this an O(n^2) algorithm.\n\nfor tup in somelist[:]:\n    # lots of code here, possibly setting things up for calling determine\n    if determine(tup):\n        newlist.append(tup)\n\n    ",
        "_Respuesta__votes": 49,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 195,
        "_Respuesta__fecha": "2016-05-24 12:50:20Z",
        "_Respuesta__descripcion": "\nFor those that like functional programming:\n\nsomelist[:] = filter(lambda tup: not determine(tup), somelist)\n\n\nor\n\nfrom itertools import ifilterfalse\nsomelist[:] = list(ifilterfalse(determine, somelist))\n\n    ",
        "_Respuesta__votes": 38,
        "comentarios": [
            {
                "_id": 289,
                "_Comentario__descripcion": "1. List comprehension and generator expressions are borrowed from Haskell, a pure functional language; they're exactly as functional as filter, and more Pythonic. 2. If you need a lambda to use map or filter, the list comp or genexpr is always the better option; map and filter can be slightly faster when the transform/predicate function is a Python built-in implemented in C and the iterable is not trivially small, but they're always slower when you need a lambda that the listcomp/genexpr could avoid.",
                "_Comentario__fecha": "2016-10-22 00:22:22Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ShadowRanger",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 196,
        "_Respuesta__fecha": "2017-03-13 20:54:41Z",
        "_Respuesta__descripcion": "\nI needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.\n\narray = [lots of stuff]\narraySize = len(array)\ni = 0\nwhile i < arraySize:\n    if someTest(array[i]):\n        del array[i]\n        arraySize -= 1\n    else:\n        i += 1\n\n\nWhat I don't know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.\n    ",
        "_Respuesta__votes": 19,
        "comentarios": [
            {
                "_id": 290,
                "_Comentario__descripcion": "In my case I need to move those 'unwanted' elements into another list. Do you have any new comment about this solution? I also think that it is better to use some deletions instead of duplicate the list.",
                "_Comentario__fecha": "2017-05-05 02:13:11Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "gustavovelascoh",
                "usuario_id": null
            },
            {
                "_id": 291,
                "_Comentario__descripcion": "This is the right answer if performance is an issue (although same as @Alexey). That said, the choice of list as a data structure in the first place should be carefully considered since removal from the middle of a list takes linear time in the length of the list. If you don't really need random access to k-th sequential item, maybe consider OrderedDict?",
                "_Comentario__fecha": "2017-05-05 11:29:23Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "max",
                "usuario_id": null
            },
            {
                "_id": 292,
                "_Comentario__descripcion": "@GVelascoh why not create newlist = [], and then newlist.append(array[i]) just before del array[i]?",
                "_Comentario__fecha": "2017-05-05 11:31:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "max",
                "usuario_id": null
            },
            {
                "_id": 293,
                "_Comentario__descripcion": "Note that this is likely time inefficient: if list() is a linked list, the random access is expensive, if list() is an array, the deletes are expensive because they require to move all following elements forward. A decent iterator could make things good for the linked list implementation. This could however be space efficient.",
                "_Comentario__fecha": "2017-06-05 16:08:37Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ciro Santilli \u65b0\u7586\u518d\u6559\u80b2\u8425\u516d\u56db\u4e8b\u4ef6\u6cd5\u8f6e\u529f\u90dd\u6d77\u4e1c",
                "usuario_id": null
            },
            {
                "_id": 294,
                "_Comentario__descripcion": "@CiroSantilli\u90dd\u6d77\u4e1c\u51a0\u72b6\u75c5\u516d\u56db\u4e8b\u4ef6\u6cd5\u8f6e\u529f : The pop(i) operation is still O(n). I'll take storage efficiency over incremental improvements in O(n), but I can see why someone might do this differently.",
                "_Comentario__fecha": "2021-01-06 01:08:38Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "ingyhere",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 197,
        "_Respuesta__fecha": "2016-10-23 02:33:13Z",
        "_Respuesta__descripcion": "\nIt might be smart to also just create a new list if the current list item meets the desired criteria. \n\nso:\n\nfor item in originalList:\n   if (item != badValue):\n        newList.append(item)\n\n\nand to avoid having to re-code the entire project with the new lists name:\n\noriginalList[:] = newList\n\n\nnote, from Python documentation: \n\n\n  copy.copy(x) \n  Return a shallow copy of x.\n  \n  copy.deepcopy(x) \n  Return a deep copy of x.\n\n    ",
        "_Respuesta__votes": 11,
        "comentarios": [
            {
                "_id": 295,
                "_Comentario__descripcion": "This adds no new information that wasn't in the accepted answer years earlier.",
                "_Comentario__fecha": "2016-06-21 22:36:22Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Amery",
                "usuario_id": null
            },
            {
                "_id": 296,
                "_Comentario__descripcion": "It's simple and just another way to look at a problem @MarkAmery. It's less condensed for those people that don't like compressed coding syntax.",
                "_Comentario__fecha": "2016-06-23 03:08:11Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ntk4",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 198,
        "_Respuesta__fecha": "2017-05-23 12:18:24Z",
        "_Respuesta__descripcion": "\nThis answer was originally written in response to a question which has since been marked as duplicate:\nRemoving coordinates from list on python\n\nThere are two problems in your code:\n\n1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.\n\n2) The for loop will skip items in your list.\n\nLet's run through what happens when we execute your code:\n\n>>> L1 = [(1,2), (5,6), (-1,-2), (1,-2)]\n>>> for (a,b) in L1:\n...   if a < 0 or b < 0:\n...     L1.remove(a,b)\n... \nTraceback (most recent call last):\n  File \"<stdin>\", line 3, in <module>\nTypeError: remove() takes exactly one argument (2 given)\n\n\nThe first problem is that you are passing both 'a' and 'b' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let's access one element of the list (indexing starts at 0):\n\n>>> L1[1]\n(5, 6)\n>>> type(L1[1])\n<type 'tuple'>\n\n\nAha! Each element of L1 is actually a tuple. So that's what we need to be passing to remove(). Tuples in python are very easy, they're simply made by enclosing values in parentheses. \"a, b\" is not a tuple, but \"(a, b)\" is a tuple. So we modify your code and run it again:\n\n# The remove line now includes an extra \"()\" to make a tuple out of \"a,b\"\nL1.remove((a,b))\n\n\nThis code runs without any error, but let's look at the list it outputs: \n\nL1 is now: [(1, 2), (5, 6), (1, -2)]\n\n\nWhy is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let's look at what happens if we feed the above code a longer list:\n\nL1 = [(1,2),(5,6),(-1,-2),(1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)]\n### Outputs:\nL1 is now: [(1, 2), (5, 6), (1, -2), (3, 4), (5, 7), (2, 1), (5, -1), (0, 6)]\n\n\nAs you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.\n\nThe most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:\n\nL2 = L1\nfor (a,b) in L1:\n    if a < 0 or b < 0 :\n        L2.remove((a,b))\n# Now, remove the original copy of L1 and replace with L2\nprint L2 is L1\ndel L1\nL1 = L2; del L2\nprint (\"L1 is now: \", L1)\n\n\nHowever, the output will be identical to before:\n\n'L1 is now: ', [(1, 2), (5, 6), (1, -2), (3, 4), (5, 7), (2, 1), (5, -1), (0, 6)]\n\n\nThis is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with 'is' which is different from merely \"equals\" (==).\n\n>>> L2=L1\n>>> L1 is L2\nTrue\n\n\nWe can make a true copy using copy.copy(). Then everything works as expected:\n\nimport copy\nL1 = [(1,2), (5,6),(-1,-2), (1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)]\nL2 = copy.copy(L1)\nfor (a,b) in L1:\n    if a < 0 or b < 0 :\n        L2.remove((a,b))\n# Now, remove the original copy of L1 and replace with L2\ndel L1\nL1 = L2; del L2\n>>> L1 is now: [(1, 2), (5, 6), (3, 4), (5, 7), (2, 1), (0, 6)]\n\n\nFinally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:\n\nL1 = [(1,2), (5,6),(-1,-2), (1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)]\nfor (a,b) in reversed(L1):\n    if a < 0 or b < 0 :\n        L1.remove((a,b))\nprint (\"L1 is now: \", L1)\n>>> L1 is now: [(1, 2), (5, 6), (3, 4), (5, 7), (2, 1), (0, 6)]\n\n\nUnfortunately, I cannot adequately describe how reversed() works. It returns a 'listreverseiterator' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 199,
        "_Respuesta__fecha": "2018-10-23 11:13:00Z",
        "_Respuesta__descripcion": "\nMost of the answers here want you to create a copy of the list. I had a use case where the list was quite long (110K items) and it was smarter to keep reducing the list instead.\n\nFirst of all you'll need to replace foreach loop with while loop,\n\ni = 0\nwhile i < len(somelist):\n    if determine(somelist[i]):\n         del somelist[i]\n    else:\n        i += 1\n\n\nThe value of i is not changed in the if block because you'll want to get value of the new item FROM THE SAME INDEX, once the old item is deleted.\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 200,
        "_Respuesta__fecha": "2019-10-10 02:24:59Z",
        "_Respuesta__descripcion": "\nIf you want to delete elements from a list while iterating, use a while-loop so you can alter the current index and end index after each deletion.\n\nExample:\n\ni = 0\nlength = len(list1)\n\nwhile i < length:\n    if condition:\n        list1.remove(list1[i])\n        i -= 1\n        length -= 1\n\n    i += 1\n\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 201,
        "_Respuesta__fecha": "2014-08-18 12:30:16Z",
        "_Respuesta__descripcion": "\nIf you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.\n\ninlist = [{'field1':10, 'field2':20}, {'field1':30, 'field2':15}]    \nfor idx, i in enumerate(inlist):\n    do some stuff with i['field1']\n    if somecondition:\n        xlist.append(idx)\nfor i in reversed(xlist): del inlist[i]\n\n\nenumerate gives you access to the item and the index at once. reversed is so that the indices that you're going to later delete don't change on you. \n    ",
        "_Respuesta__votes": 4,
        "comentarios": [
            {
                "_id": 297,
                "_Comentario__descripcion": "Why is getting the index any more relevant in the case where you have a list of dicts than in the case of any other kind of list? This doesn't make sense as far as I can tell.",
                "_Comentario__fecha": "2016-06-21 22:33:52Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Amery",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 202,
        "_Respuesta__fecha": "2015-07-10 20:58:49Z",
        "_Respuesta__descripcion": "\nYou can try for-looping in reverse so for some_list you'll do something like:\n\nlist_len = len(some_list)\nfor i in range(list_len):\n    reverse_i = list_len - 1 - i\n    cur = some_list[reverse_i]\n\n    # some logic with cur element\n\n    if some_condition:\n        some_list.pop(reverse_i)\n\n\nThis way the index is aligned and doesn't suffer from the list updates (regardless whether you pop cur element or not).\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [
            {
                "_id": 298,
                "_Comentario__descripcion": "Looping over reversed(list(enumerate(some_list))) would be simpler than computing indexes yourself.",
                "_Comentario__fecha": "2016-06-21 22:49:43Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Amery",
                "usuario_id": null
            },
            {
                "_id": 299,
                "_Comentario__descripcion": "@MarkAmery don't think you can alter the list this way.",
                "_Comentario__fecha": "2016-06-28 18:29:06Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Queequeg",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 203,
        "_Respuesta__fecha": "2017-07-27 07:40:53Z",
        "_Respuesta__descripcion": "\nYou might want to use filter() available as the built-in.\n\nFor more details check here\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 204,
        "_Respuesta__fecha": "2018-06-13 19:38:52Z",
        "_Respuesta__descripcion": "\nOne possible solution, useful if you want not only remove some things, but also do something with all elements in a single loop:\n\nalist = ['good', 'bad', 'good', 'bad', 'good']\ni = 0\nfor x in alist[:]:\n    if x == 'bad':\n        alist.pop(i)\n        i -= 1\n    # do something cool with x or just print x\n    print(x)\n    i += 1\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [
            {
                "_id": 300,
                "_Comentario__descripcion": "You should really just use comprehensions. They're much easier to understand.",
                "_Comentario__fecha": "2018-03-15 23:46:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Beefster",
                "usuario_id": null
            },
            {
                "_id": 301,
                "_Comentario__descripcion": "What if I want to remove bad things, do something with it and also do something with good things in one loop?",
                "_Comentario__fecha": "2018-03-16 07:38:18Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Alexey",
                "usuario_id": null
            },
            {
                "_id": 302,
                "_Comentario__descripcion": "Actually, I realized there's some cleverness here in that you make a copy of the list with an open slice (alist[:]) And since you might be doing something fancy, it actually has a use case. Good revision is good. Take my upvote.",
                "_Comentario__fecha": "2018-03-29 19:14:08Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Beefster",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 205,
        "_Respuesta__fecha": "2018-11-10 07:05:16Z",
        "_Respuesta__descripcion": "\nThe most effective method is list comprehension, many people show their case, of course, it is also a good way to get an iterator through filter.\n\n\n  Filter receives a function and a sequence. Filter applies the passed function to each element in turn, and then decides whether to retain or discard the element depending on whether the function return value is True or False.\n\n\nThere is an example  (get the odds in the tuple):\n\nlist(filter(lambda x:x%2==1, (1, 2, 4, 5, 6, 9, 10, 15)))  \n# result: [1, 5, 9, 15]\n\n\nCaution: You can also not handle iterators. Iterators are sometimes better than sequences.\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [
            {
                "_id": 303,
                "_Comentario__descripcion": "I probably think this is the most idiomatic way of removing the items from list. This behaviour will also be thread safe since your application is not mutating the variable.",
                "_Comentario__fecha": "2021-08-10 05:24:24Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Supreet Sethi",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 206,
        "_Respuesta__fecha": "2019-04-30 06:25:49Z",
        "_Respuesta__descripcion": "\nfor loop will be iterate through index..\n\nconsider you have a list,\n\n[5, 7, 13, 29, 65, 91]\n\n\nyou have using list variable called lis. and you using same to remove..\n\nyour variable \n\nlis = [5, 7, 13, 29, 35, 65, 91]\n       0  1   2   3   4   5   6\n\n\nduring 5th iteration,\n\nyour number 35 was not a prime so you removed it from a list.\n\nlis.remove(y)\n\n\nand then next value (65) move on to previous index.\n\nlis = [5, 7, 13, 29, 65, 91]\n       0  1   2   3   4   5\n\n\nso 4th iteration done pointer moved onto 5th.. \n\nthats why your loop doesnt cover 65 since its moved into previous index.\n\nso you shouldn't reference list into another variable which still reference original instead of copy.\n\nite = lis #dont do it will reference instead copy\n\n\nso do copy of list using list[::]\n\nnow you it will give,\n\n[5, 7, 13, 29]\n\n\nProblem is you removed a value from a list during iteration then your list index will collapse.\n\nso you can try comprehension instead.\n\nwhich supports all the iterable like, list, tuple, dict, string etc \n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 207,
        "_Respuesta__fecha": "2015-12-16 11:05:41Z",
        "_Respuesta__descripcion": "\nI needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:\n\n```\n\nk = range(5)\nv = ['a','b','c','d','e']\nd = {key:val for key,val in zip(k, v)}\n\nprint d\nfor i in range(5):\n    print d[i]\n    d.pop(i)\nprint d\n\n\n```\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 208,
        "_Respuesta__fecha": "2017-05-23 12:18:24Z",
        "_Respuesta__descripcion": "\nTLDR:\n\nI wrote a library that allows you to do this:\n\nfrom fluidIter import FluidIterable\nfSomeList = FluidIterable(someList)  \nfor tup in fSomeList:\n    if determine(tup):\n        # remove 'tup' without \"breaking\" the iteration\n        fSomeList.remove(tup)\n        # tup has also been removed from 'someList'\n        # as well as 'fSomeList'\n\n\nIt's best to use another method if possible that doesn't require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.\n\nShould work on all mutable sequences not just lists.\n\n\n\nFull answer:\n\nEdit: The last code example in this answer gives a use case for why you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of how an array can be modified in place.\n\nThe solution follows on from this answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.\n\nDownload fluidIter.py from here https://github.com/alanbacon/FluidIterator, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.\n\nfrom fluidIter import FluidIterable\nl = [0,1,2,3,4,5,6,7,8]  \nfluidL = FluidIterable(l)                       \nfor i in fluidL:\n    print('initial state of list on this iteration: ' + str(fluidL)) \n    print('current iteration value: ' + str(i))\n    print('popped value: ' + str(fluidL.pop(2)))\n    print(' ')\n\nprint('Final List Value: ' + str(l))\n\n\nThis will produce the following output:\n\ninitial state of list on this iteration: [0, 1, 2, 3, 4, 5, 6, 7, 8]\ncurrent iteration value: 0\npopped value: 2\n\ninitial state of list on this iteration: [0, 1, 3, 4, 5, 6, 7, 8]\ncurrent iteration value: 1\npopped value: 3\n\ninitial state of list on this iteration: [0, 1, 4, 5, 6, 7, 8]\ncurrent iteration value: 4\npopped value: 4\n\ninitial state of list on this iteration: [0, 1, 5, 6, 7, 8]\ncurrent iteration value: 5\npopped value: 5\n\ninitial state of list on this iteration: [0, 1, 6, 7, 8]\ncurrent iteration value: 6\npopped value: 6\n\ninitial state of list on this iteration: [0, 1, 7, 8]\ncurrent iteration value: 7\npopped value: 7\n\ninitial state of list on this iteration: [0, 1, 8]\ncurrent iteration value: 8\npopped value: 8\n\nFinal List Value: [0, 1]\n\n\nAbove we have used the pop method on the fluid list object. Other common iterable methods are also implemented such as del fluidL[i], .remove, .insert, .append, .extend. The list can also be modified using slices (sort and reverse methods are not implemented).\n\nThe only condition is that you must only modify the list in place, if at any point fluidL or l were reassigned to a different list object the code would not work. The original fluidL object would still be used by the for loop but would become out of scope for us to modify.\n\ni.e.\n\nfluidL[2] = 'a'   # is OK\nfluidL = [0, 1, 'a', 3, 4, 5, 6, 7, 8]  # is not OK\n\n\nIf we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.\n\nfluidArr = FluidIterable([0,1,2,3])\n# get iterator first so can query the current index\nfluidArrIter = fluidArr.__iter__()\nfor i, v in enumerate(fluidArrIter):\n    print('enum: ', i)\n    print('current val: ', v)\n    print('current ind: ', fluidArrIter.currentIndex)\n    print(fluidArr)\n    fluidArr.insert(0,'a')\n    print(' ')\n\nprint('Final List Value: ' + str(fluidArr))\n\n\nThis will output the following:\n\nenum:  0\ncurrent val:  0\ncurrent ind:  0\n[0, 1, 2, 3]\n\nenum:  1\ncurrent val:  1\ncurrent ind:  2\n['a', 0, 1, 2, 3]\n\nenum:  2\ncurrent val:  2\ncurrent ind:  4\n['a', 'a', 0, 1, 2, 3]\n\nenum:  3\ncurrent val:  3\ncurrent ind:  6\n['a', 'a', 'a', 0, 1, 2, 3]\n\nFinal List Value: ['a', 'a', 'a', 'a', 0, 1, 2, 3]\n\n\nThe FluidIterable class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:\n\noriginalList = fluidArr.fixedIterable\n\n\nMore examples / tests can be found in the if __name__ is \"__main__\": section at the bottom of fluidIter.py. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.\n\nAs I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick's answer should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.\n\n\n\nEdit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:\n\nList comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.\n\ni.e.\n\nnewList = [i for i in oldList if testFunc(i)]\n\n\nBut what if the result of the testFunc depends on the elements that have been added to newList already? Or the elements still in oldList that might be added next? There might still be a way to use a list comprehension but it will begin to lose it's elegance, and for me it feels easier to modify a list in place.\n\nThe code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.\n\nrandInts = [70, 20, 61, 80, 54, 18, 7, 18, 55, 9]\nfRandInts = FluidIterable(randInts)\nfRandIntsIter = fRandInts.__iter__()\n# for each value in the list (outer loop)\n# test against every other value in the list (inner loop)\nfor i in fRandIntsIter:\n    print(' ')\n    print('outer val: ', i)\n    innerIntsIter = fRandInts.__iter__()\n    for j in innerIntsIter:\n        innerIndex = innerIntsIter.currentIndex\n        # skip the element that the outloop is currently on\n        # because we don't want to test a value against itself\n        if not innerIndex == fRandIntsIter.currentIndex:\n            # if the test element, j, is a multiple \n            # of the reference element, i, then remove 'j'\n            if j%i == 0:\n                print('remove val: ', j)\n                # remove element in place, without breaking the\n                # iteration of either loop\n                del fRandInts[innerIndex]\n            # end if multiple, then remove\n        # end if not the same value as outer loop\n    # end inner loop\n# end outerloop\n\nprint('')\nprint('final list: ', randInts)\n\n\nThe output and the final reduced list are shown below\n\nouter val:  70\n\nouter val:  20\nremove val:  80\n\nouter val:  61\n\nouter val:  54\n\nouter val:  18\nremove val:  54\nremove val:  18\n\nouter val:  7\nremove val:  70\n\nouter val:  55\n\nouter val:  9\nremove val:  18\n\nfinal list:  [20, 61, 7, 55, 9]\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [
            {
                "_id": 304,
                "_Comentario__descripcion": "It's hard to tell whether this is over-engineered because it's unclear what problem it's trying to solve; what does removing elements using this approach achieve that some_list[:] = [x for x in some_list if not some_condition(x)] doesn't achieve? Without an answer to that, why should anyone believe that downloading and using your 600-line library complete with typos and commented-out code is a better solution to their problem than the one-liner? -1.",
                "_Comentario__fecha": "2016-06-21 22:47:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Amery",
                "usuario_id": null
            },
            {
                "_id": 305,
                "_Comentario__descripcion": "@MarkAmery. The main use case for when this is when trying to determine if an item should be removed (or added or moved) based not on just the item itself, but on the state of another item in the list or the state of the list as a whole. For example, it is not possible with list comprehensions to write something like some_list[:] = [x for x in some_list if not some_condition(y)] where y is a different list element from x. Nor would it be possible to write some_list[:] = [x for x in some_list if not some_condition(intermediateStateOf_some_list)].",
                "_Comentario__fecha": "2016-06-28 13:27:10Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Resonance",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 209,
        "_Respuesta__fecha": "2018-03-15 23:42:50Z",
        "_Respuesta__descripcion": "\nThe other answers are correct that it is usually a bad idea to delete from a list that you're iterating. Reverse iterating avoids the pitfalls, but it is much more difficult to follow code that does that, so usually you're better off using a list comprehension or filter.\n\nThere is, however, one case where it is safe to remove elements from a sequence that you are iterating: if you're only removing one item while you're iterating. This can be ensured using a return or a break. For example:\n\nfor i, item in enumerate(lst):\n    if item % 4 == 0:\n        foo(item)\n        del lst[i]\n        break\n\n\nThis is often easier to understand than a list comprehension when you're doing some operations with side effects on the first item in a list that meets some condition and then removing that item from the list immediately after.\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 210,
        "_Respuesta__fecha": "2018-09-21 16:14:52Z",
        "_Respuesta__descripcion": "\nIn some situations, where you're doing more than simply filtering a list one item at time, you want your iteration to change while iterating.\n\nHere is an example where copying the list beforehand is incorrect, reverse iteration is impossible and a list comprehension is also not an option.\n\n\"\"\" Sieve of Eratosthenes \"\"\"\n\ndef generate_primes(n):\n    \"\"\" Generates all primes less than n. \"\"\"\n    primes = list(range(2,n))\n    idx = 0\n    while idx < len(primes):\n        p = primes[idx]\n        for multiple in range(p+p, n, p):\n            try:\n                primes.remove(multiple)\n            except ValueError:\n                pass #EAFP\n        idx += 1\n        yield p\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 211,
        "_Respuesta__fecha": "2018-12-03 21:04:05Z",
        "_Respuesta__descripcion": "\nI can think of three approaches to solve your problem. As an example, I will create a random list of tuples somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]. The condition that I choose is sum of elements of a tuple = 15. In the final list we will only have those tuples whose sum is not equal to 15. \n\nWhat I have chosen is a randomly chosen example. Feel free to change the list of tuples and the condition that I have chosen. \n\nMethod 1.> Use the framework that you had suggested (where one fills in a code inside a for loop). I use a small code with del to delete a tuple that meets the said condition. However, this method will miss a tuple (which satisfies the said condition) if two consecutively placed tuples meet the given condition. \n\nfor tup in somelist:\n    if ( sum(tup)==15 ): \n        del somelist[somelist.index(tup)]\n\nprint somelist\n>>> [(1, 2, 3), (3, 6, 6), (7, 8, 9), (10, 11, 12)]\n\n\nMethod 2.> Construct a new list which contains elements (tuples) where the given condition is not met (this is the same thing as removing elements of list where the given condition is met). Following is the code for that:\n\nnewlist1 = [somelist[tup] for tup in range(len(somelist)) if(sum(somelist[tup])!=15)]\n\nprint newlist1\n>>>[(1, 2, 3), (7, 8, 9), (10, 11, 12)]\n\n\nMethod 3.> Find indices where the given condition is met, and then use remove elements (tuples) corresponding to those indices. Following is the code for that.\n\nindices = [i for i in range(len(somelist)) if(sum(somelist[i])==15)]\nnewlist2 = [tup for j, tup in enumerate(somelist) if j not in indices]\n\nprint newlist2\n>>>[(1, 2, 3), (7, 8, 9), (10, 11, 12)]\n\n\nMethod 1 and method 2 are faster than method 3. Method2 and method3 are more efficient than method1. I prefer method2. For the aforementioned example, time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 212,
        "_Respuesta__fecha": "2018-08-22 23:36:31Z",
        "_Respuesta__descripcion": "\nFor anything that has the potential to be really big, I use the following. \n\nimport numpy as np\n\norig_list = np.array([1, 2, 3, 4, 5, 100, 8, 13])\n\nremove_me = [100, 1]\n\ncleaned = np.delete(orig_list, remove_me)\nprint(cleaned)\n\n\nThat should be significantly faster than anything else. \n    ",
        "_Respuesta__votes": 0,
        "comentarios": [
            {
                "_id": 306,
                "_Comentario__descripcion": "From what I measured, NumPy starts to be faster for lists of more than 20 elements, and reaches >12x faster filtering for big lists of 1000 elements and more.",
                "_Comentario__fecha": "2019-05-14 13:06:00Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Georgy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 213,
        "_Respuesta__fecha": "2019-04-16 09:08:13Z",
        "_Respuesta__descripcion": "\nIf you will use the new list later, you can simply set the elem to None, and then judge it in the later loop, like this\n\nfor i in li:\n    i = None\n\nfor elem in li:\n    if elem is None:\n        continue\n\n\nIn this way, you dont't need copy the list and it's easier to understand. \n    ",
        "_Respuesta__votes": 0,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 215,
        "_Respuesta__fecha": "2021-07-04 18:40:40Z",
        "_Respuesta__descripcion": "\nGiven a list of lists t,\nflat_list = [item for sublist in t for item in sublist]\n\nwhich means:\nflat_list = []\nfor sublist in t:\n    for item in sublist:\n        flat_list.append(item)\n\nis faster than the shortcuts posted so far. (t is the list to flatten.)\nHere is the corresponding function:\ndef flatten(t):\n    return [item for sublist in t for item in sublist]\n\nAs evidence, you can use the timeit module in the standard library:\n$ python -mtimeit -s't=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in t for item in sublist]'\n10000 loops, best of 3: 143 usec per loop\n$ python -mtimeit -s't=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(t, [])'\n1000 loops, best of 3: 969 usec per loop\n$ python -mtimeit -s't=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'reduce(lambda x,y: x+y,t)'\n1000 loops, best of 3: 1.1 msec per loop\n\nExplanation: the shortcuts based on + (including the implied use in sum) are, of necessity, O(T**2) when there are T sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have T sublists of k items each: the first k items are copied back and forth T-1 times, the second k items T-2 times, and so on; total number of copies is k times the sum of x for x from 1 to T excluded, i.e., k * (T**2)/2.\nThe list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.\n    ",
        "_Respuesta__votes": 6026,
        "comentarios": [
            {
                "_id": 313,
                "_Comentario__descripcion": "I tried a test with the same data, using itertools.chain.from_iterable :         $ python -mtimeit -s'from itertools import chain; l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'list(chain.from_iterable(l))'.   It runs a bit more than twice as fast as the nested list comprehension that's the fastest of the alternatives shown here.",
                "_Comentario__fecha": "2010-10-15 01:21:33Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "intuited",
                "usuario_id": null
            },
            {
                "_id": 314,
                "_Comentario__descripcion": "I found the syntax hard to understand until I realized you can think of it exactly like nested for loops.  for sublist in l: for item in sublist: yield item",
                "_Comentario__fecha": "2011-07-27 16:43:18Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Rob Crowell",
                "usuario_id": null
            },
            {
                "_id": 315,
                "_Comentario__descripcion": "[leaf for tree in forest for leaf in tree] might be easier to comprehend and apply.",
                "_Comentario__fecha": "2013-08-29 01:38:20Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "John Mee",
                "usuario_id": null
            },
            {
                "_id": 316,
                "_Comentario__descripcion": "@RobCrowell Same here. To me the list comprehension one doesn't read right, something feels off about it - I always seem to get it wrong and end up googling. To me this reads right [leaf for leaf in tree for tree in forest]. I wish this is how it was. I am sure I am missing something about the grammar here, and I would appreciate if anyone could point that out.",
                "_Comentario__fecha": "2021-07-12 17:19:14Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "S\u043d\u0430\u0111\u043e\u0448\u0192\u0430\u04fd",
                "usuario_id": null
            },
            {
                "_id": 317,
                "_Comentario__descripcion": "I kept looking here every time I wanted to flatten a list, but this gif is what drove it home: i.stack.imgur.com/0GoV5.gif",
                "_Comentario__fecha": "2021-08-11 12:04:22Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Gilthans",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 216,
        "_Respuesta__fecha": "2021-03-11 11:25:08Z",
        "_Respuesta__descripcion": "\nYou can use itertools.chain():\nimport itertools\n\nlist2d = [[1,2,3], [4,5,6], [7], [8,9]]\nmerged = list(itertools.chain(*list2d))\n\nOr you can use itertools.chain.from_iterable() which doesn't require unpacking the list with the * operator:\nmerged = list(itertools.chain.from_iterable(list2d))\n\n    ",
        "_Respuesta__votes": 1900,
        "comentarios": [
            {
                "_id": 318,
                "_Comentario__descripcion": "The * is the tricky thing that makes chain less straightforward than the list comprehension. You have to know that chain only joins together the iterables passed as parameters, and the * causes the top-level list to be expanded into parameters, so chain joins together all those iterables, but doesn't descend further. I think this makes the comprehension more readable than the use of chain in this case.",
                "_Comentario__fecha": "2014-09-03 14:13:45Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Tim Dierks",
                "usuario_id": null
            },
            {
                "_id": 319,
                "_Comentario__descripcion": "@TimDierks: I'm not sure \"this requires you to understand Python syntax\" is an argument against using a given technique in Python. Sure, complex usage could confuse, but the \"splat\" operator is generally useful in many circumstances, and this isn't using it in a particularly obscure way; rejecting all language features that aren't necessarily obvious to beginning users means you're tying one hand behind your back. May as well throw out list comprehensions too while you're at it; users from other backgrounds would find a for loop that repeatedly appends more obvious.",
                "_Comentario__fecha": "2015-11-12 20:26:36Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ShadowRanger",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 217,
        "_Respuesta__fecha": "2021-05-19 10:17:49Z",
        "_Respuesta__descripcion": "\nNote from the author: This is inefficient. But fun, because monoids are awesome. It's not appropriate for production Python code.\n>>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n>>> sum(l, [])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nThis just sums the elements of iterable passed in the first argument, treating second argument as the initial value of the sum (if not given, 0 is used instead and this case will give you an error).\nBecause you are summing nested lists, you actually get [1,3]+[2,4] as a result of sum([[1,3],[2,4]],[]), which is equal to [1,3,2,4].\nNote that only works on lists of lists. For lists of lists of lists, you'll need another solution.\n    ",
        "_Respuesta__votes": 1094,
        "comentarios": [
            {
                "_id": 320,
                "_Comentario__descripcion": "that's pretty neat and clever but I wouldn't use it because it's confusing to read.",
                "_Comentario__fecha": "2010-06-15 18:55:14Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "andrewrk",
                "usuario_id": null
            },
            {
                "_id": 321,
                "_Comentario__descripcion": "This is a Shlemiel the painter's algorithm joelonsoftware.com/articles/fog0000000319.html -- unnecessarily inefficient as well as unnecessarily ugly.",
                "_Comentario__fecha": "2012-04-25 18:24:57Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mike Graham",
                "usuario_id": null
            },
            {
                "_id": 322,
                "_Comentario__descripcion": "The append operation on lists forms a Monoid, which is one of the most convenient abstractions for thinking of a + operation in a general sense (not limited to numbers only). So this answer deserves a +1 from me for (correct) treatment of lists as a monoid. The performance is concerning though...",
                "_Comentario__fecha": "2014-12-03 10:35:23Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ulidtko",
                "usuario_id": null
            },
            {
                "_id": 323,
                "_Comentario__descripcion": "this is a very inefficient way because of the quadratic aspect of the sum.",
                "_Comentario__fecha": "2017-07-31 18:04:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Jean-Fran\u00e7ois Fabre\u2666",
                "usuario_id": null
            },
            {
                "_id": 324,
                "_Comentario__descripcion": "This article explains the maths of the inefficiency mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python",
                "_Comentario__fecha": "2018-01-04 16:46:19Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ds4940",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 218,
        "_Respuesta__fecha": "2021-07-16 05:39:21Z",
        "_Respuesta__descripcion": "\nI tested most suggested solutions with perfplot (a pet project of mine, essentially a wrapper around timeit), and found\nimport functools\nimport operator\nfunctools.reduce(operator.iconcat, a, [])\n\nto be the fastest solution, both when many small lists and few long lists are concatenated. (operator.iadd is equally fast.)\n\n\n\nCode to reproduce the plot:\nimport functools\nimport itertools\nimport numpy\nimport operator\nimport perfplot\n\n\ndef forfor(a):\n    return [item for sublist in a for item in sublist]\n\n\ndef sum_brackets(a):\n    return sum(a, [])\n\n\ndef functools_reduce(a):\n    return functools.reduce(operator.concat, a)\n\n\ndef functools_reduce_iconcat(a):\n    return functools.reduce(operator.iconcat, a, [])\n\n\ndef itertools_chain(a):\n    return list(itertools.chain.from_iterable(a))\n\n\ndef numpy_flat(a):\n    return list(numpy.array(a).flat)\n\n\ndef numpy_concatenate(a):\n    return list(numpy.concatenate(a))\n\n\nperfplot.show(\n    setup=lambda n: [list(range(10))] * n,\n    # setup=lambda n: [list(range(n))] * 10,\n    kernels=[\n        forfor,\n        sum_brackets,\n        functools_reduce,\n        functools_reduce_iconcat,\n        itertools_chain,\n        numpy_flat,\n        numpy_concatenate,\n    ],\n    n_range=[2 ** k for k in range(16)],\n    xlabel=\"num lists (of length 10)\",\n    # xlabel=\"len lists (10 lists total)\"\n)\n\n    ",
        "_Respuesta__votes": 670,
        "comentarios": [
            {
                "_id": 325,
                "_Comentario__descripcion": "For huge nested lists,' list(numpy.array(a).flat)' is the fastest among all functions above.",
                "_Comentario__fecha": "2019-01-20 13:57:20Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Sara",
                "usuario_id": null
            },
            {
                "_id": 326,
                "_Comentario__descripcion": "Is there a way to do a 3-d perfplot? number of arrays by average size of array?",
                "_Comentario__fecha": "2020-04-30 00:31:34Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Leo",
                "usuario_id": null
            },
            {
                "_id": 327,
                "_Comentario__descripcion": "@Sara can you define \"huge\" please?",
                "_Comentario__fecha": "2020-11-14 06:05:23Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Boris",
                "usuario_id": null
            },
            {
                "_id": 328,
                "_Comentario__descripcion": "Tried numpy_flat on the test example from Rossetta Code (link) and got VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray",
                "_Comentario__fecha": "2020-12-05 11:08:25Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "mirekphd",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 219,
        "_Respuesta__fecha": "2021-03-18 12:33:47Z",
        "_Respuesta__descripcion": "\n>>> from functools import reduce\n>>> l = [[1,2,3], [4,5,6], [7], [8,9]]\n>>> reduce(lambda x, y: x+y, l)\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nThe extend() method in your example modifies x instead of returning a useful value (which functools.reduce() expects).\nA faster way to do the reduce version would be\n>>> import operator\n>>> l = [[1,2,3], [4,5,6], [7], [8,9]]\n>>> reduce(operator.concat, l)\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    ",
        "_Respuesta__votes": 233,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 220,
        "_Respuesta__fecha": "2021-06-11 13:46:31Z",
        "_Respuesta__descripcion": "\nHere is a general approach that applies to numbers, strings, nested lists and mixed containers.  This can flatten both simple and complicated containers (see also Demo).\nCode\nfrom typing import Iterable \n#from collections import Iterable                            # < py38\n\n\ndef flatten(items):\n    \"\"\"Yield items from any nested iterable; see Reference.\"\"\"\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):\n            for sub_x in flatten(x):\n                yield sub_x\n        else:\n            yield x\n\nNotes:\n\nIn Python 3, yield from flatten(x) can replace for sub_x in flatten(x): yield sub_x\nIn Python 3.8, abstract base classes are moved from collection.abc to the typing module.\n\nDemo\nsimple = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(flatten(simple))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ncomplicated = [[1, [2]], (3, 4, {5, 6}, 7), 8, \"9\"]              # numbers, strs, nested & mixed\nlist(flatten(complicated))\n# [1, 2, 3, 4, 5, 6, 7, 8, '9']\n\nReference\n\nThis solution is modified from a recipe in Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.\nFound an earlier SO post, possibly the original demonstration.\n\n    ",
        "_Respuesta__votes": 139,
        "comentarios": [
            {
                "_id": 329,
                "_Comentario__descripcion": "I just wrote pretty much the same, because I didn't see your solution ... here is what I looked for  \"recursively flatten complete multiple lists\" ... (+1)",
                "_Comentario__fecha": "2017-03-25 15:32:05Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Martin Thoma",
                "usuario_id": null
            },
            {
                "_id": 330,
                "_Comentario__descripcion": "@MartinThoma Much appreciated.  FYI, if flattening nested iterables is a common practice for you, there are some third-party packages that handle this well.  This may save from reinventing the wheel. I've mentioned more_itertools among others discussed in this post.  Cheers.",
                "_Comentario__fecha": "2017-03-25 17:51:51Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "pylang",
                "usuario_id": null
            },
            {
                "_id": 331,
                "_Comentario__descripcion": "Maybe traverse could also be a good name for this way of a tree, whereas I'd keep it less universal for this answer by sticking to nested lists.",
                "_Comentario__fecha": "2017-06-15 10:22:27Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Wolf",
                "usuario_id": null
            },
            {
                "_id": 332,
                "_Comentario__descripcion": "You can check if hasattr(x, '__iter__') instead of importing/checking against Iterable and that will exclude strings as well.",
                "_Comentario__fecha": "2018-04-30 16:46:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ryan Allen",
                "usuario_id": null
            },
            {
                "_id": 333,
                "_Comentario__descripcion": "the above code doesnt seem to work for if one of the nested lists is having a list of strings. [1, 2, [3, 4], [4], [], 9, 9.5, 'ssssss', ['str', 'sss', 'ss'], [3, 4, 5]] output:- [1, 2, 3, 4, 4, 9, 9.5, 'ssssss', 3, 4, 5]",
                "_Comentario__fecha": "2019-06-12 21:35:28Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "sunnyX",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 221,
        "_Respuesta__fecha": "2021-07-31 18:29:39Z",
        "_Respuesta__descripcion": "\nIf you want to flatten a data-structure where you don't know how deep it's nested you could use iteration_utilities.deepflatten1\n>>> from iteration_utilities import deepflatten\n\n>>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n>>> list(deepflatten(l, depth=1))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> l = [[1, 2, 3], [4, [5, 6]], 7, [8, 9]]\n>>> list(deepflatten(l))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nIt's a generator so you need to cast the result to a list or explicitly iterate over it.\n\nTo flatten only one level and if each of the items is itself iterable you can also use iteration_utilities.flatten which itself is just a thin wrapper around itertools.chain.from_iterable:\n>>> from iteration_utilities import flatten\n>>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n>>> list(flatten(l))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nJust to add some timings (based on Nico Schl\u00f6mer's answer that didn't include the function presented in this answer):\n\nIt's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.\nThe results show that if the iterable contains only a few inner iterables then sum will be fastest, however for long iterables only the itertools.chain.from_iterable, iteration_utilities.deepflatten or the nested comprehension have reasonable performance with itertools.chain.from_iterable being the fastest (as already noticed by Nico Schl\u00f6mer).\nfrom itertools import chain\nfrom functools import reduce\nfrom collections import Iterable  # or from collections.abc import Iterable\nimport operator\nfrom iteration_utilities import deepflatten\n\ndef nested_list_comprehension(lsts):\n    return [item for sublist in lsts for item in sublist]\n\ndef itertools_chain_from_iterable(lsts):\n    return list(chain.from_iterable(lsts))\n\ndef pythons_sum(lsts):\n    return sum(lsts, [])\n\ndef reduce_add(lsts):\n    return reduce(lambda x, y: x + y, lsts)\n\ndef pylangs_flatten(lsts):\n    return list(flatten(lsts))\n\ndef flatten(items):\n    \"\"\"Yield items from any nested iterable; see REF.\"\"\"\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):\n            yield from flatten(x)\n        else:\n            yield x\n\ndef reduce_concat(lsts):\n    return reduce(operator.concat, lsts)\n\ndef iteration_utilities_deepflatten(lsts):\n    return list(deepflatten(lsts, depth=1))\n\n\nfrom simple_benchmark import benchmark\n\nb = benchmark(\n    [nested_list_comprehension, itertools_chain_from_iterable, pythons_sum, reduce_add,\n     pylangs_flatten, reduce_concat, iteration_utilities_deepflatten],\n    arguments={2**i: [[0]*5]*(2**i) for i in range(1, 13)},\n    argument_name='number of inner lists'\n)\n\nb.plot()\n\n\n1 Disclaimer: I'm the author of that library\n    ",
        "_Respuesta__votes": 69,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 222,
        "_Respuesta__fecha": "2020-09-08 19:44:09Z",
        "_Respuesta__descripcion": "\nConsider installing the more_itertools package.\n> pip install more_itertools\n\nIt ships with an implementation for flatten (source, from the itertools recipes):\nimport more_itertools\n\n\nlst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(more_itertools.flatten(lst))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nNote: as mentioned in the docs, flatten requires a list of lists.  See below on flattening more irregular inputs.\n\nAs of version 2.4, you can flatten more complicated, nested iterables with more_itertools.collapse (source, contributed by  abarnet).\nlst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(more_itertools.collapse(lst)) \n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nlst = [[1, 2, 3], [[4, 5, 6]], [[[7]]], 8, 9]              # complex nesting\nlist(more_itertools.collapse(lst))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    ",
        "_Respuesta__votes": 36,
        "comentarios": [
            {
                "_id": 334,
                "_Comentario__descripcion": "If you can afford adding a package to your project - this answer is best",
                "_Comentario__fecha": "2020-03-05 15:53:44Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "viddik13",
                "usuario_id": null
            },
            {
                "_id": 335,
                "_Comentario__descripcion": "it fails when all elements are not list. (e.g. lst=[1, [2,3]]). of course integer is not iterable.",
                "_Comentario__fecha": "2020-09-08 08:32:47Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Sajad.sni",
                "usuario_id": null
            },
            {
                "_id": 336,
                "_Comentario__descripcion": "also, mind that list of strings will be flattened to a list of characters",
                "_Comentario__fecha": "2020-10-30 02:05:13Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "viddik13",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 223,
        "_Respuesta__fecha": "2019-11-19 16:26:36Z",
        "_Respuesta__descripcion": "\nThe reason your function didn't work is because the extend extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:\n\nreduce(lambda x,y: x.extend(y) or x, l)\n\n\nNote: extend is more efficient than + on lists.\n    ",
        "_Respuesta__votes": 29,
        "comentarios": [
            {
                "_id": 337,
                "_Comentario__descripcion": "extend is better used as newlist = [], extend = newlist.extend, for sublist in l: extend(l) as it avoids the (rather large) overhead of the lambda, the attribute lookup on x, and the or.",
                "_Comentario__fecha": "2011-09-24 10:12:35Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "agf",
                "usuario_id": null
            },
            {
                "_id": 338,
                "_Comentario__descripcion": "for python 3 add from functools import reduce",
                "_Comentario__fecha": "2019-07-02 12:24:14Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Markus Dutschke",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 224,
        "_Respuesta__fecha": "2021-07-31 18:46:27Z",
        "_Respuesta__descripcion": "\nThe following seems simplest to me:\n>>> import numpy as np\n>>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n>>> print (np.concatenate(l))\n[1 2 3 4 5 6 7 8 9]\n\n    ",
        "_Respuesta__votes": 19,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 225,
        "_Respuesta__fecha": "2018-07-20 18:16:43Z",
        "_Respuesta__descripcion": "\nmatplotlib.cbook.flatten() will work for nested lists even if they nest more deeply than the example.\n\nimport matplotlib\nl = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nprint(list(matplotlib.cbook.flatten(l)))\nl2 = [[1, 2, 3], [4, 5, 6], [7], [8, [9, 10, [11, 12, [13]]]]]\nprint list(matplotlib.cbook.flatten(l2))\n\n\nResult:\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n\n\nThis is 18x faster than underscore._.flatten:\n\nAverage time over 1000 trials of matplotlib.cbook.flatten: 2.55e-05 sec\nAverage time over 1000 trials of underscore._.flatten: 4.63e-04 sec\n(time for underscore._)/(time for matplotlib.cbook) = 18.1233394636\n\n    ",
        "_Respuesta__votes": 18,
        "comentarios": [
            {
                "_id": 339,
                "_Comentario__descripcion": "I think this is the fast of above all functions",
                "_Comentario__fecha": "2021-09-08 14:33:29Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "abdul",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 226,
        "_Respuesta__fecha": "2021-07-31 18:20:17Z",
        "_Respuesta__descripcion": "\nOne can also use NumPy's flat:\nimport numpy as np\nlist(np.array(l).flat)\n\nIt only works when sublists have identical dimensions.\n    ",
        "_Respuesta__votes": 14,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 227,
        "_Respuesta__fecha": "2020-01-28 13:06:28Z",
        "_Respuesta__descripcion": "\nyou can use list extend method, it shows to be the fastest:\n\nflat_list = []\nfor sublist in l:\n    flat_list.extend(sublist)\n\n\nperformance:\n\nimport functools\nimport itertools\nimport numpy\nimport operator\nimport perfplot\n\n\n\ndef functools_reduce_iconcat(a):\n    return functools.reduce(operator.iconcat, a, [])\n\n\ndef itertools_chain(a):\n    return list(itertools.chain.from_iterable(a))\n\n\ndef numpy_flat(a):\n    return list(numpy.array(a).flat)\n\n\ndef extend(a):\n    n = []\n\n    list(map(n.extend, a))\n\n    return n \n\n\nperfplot.show(\n    setup=lambda n: [list(range(10))] * n,\n    kernels=[\n        functools_reduce_iconcat, extend,itertools_chain, numpy_flat\n        ],\n    n_range=[2**k for k in range(16)],\n    xlabel='num lists',\n    )\n\n\noutput:\n\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 228,
        "_Respuesta__fecha": "2021-07-31 18:25:02Z",
        "_Respuesta__descripcion": "\nIf you are willing to give up a tiny amount of speed for a cleaner look, then you could use numpy.concatenate().tolist() or numpy.concatenate().ravel().tolist():\nimport numpy\n\nl = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] * 99\n\n%timeit numpy.concatenate(l).ravel().tolist()\n1000 loops, best of 3: 313 \u00b5s per loop\n\n%timeit numpy.concatenate(l).tolist()\n1000 loops, best of 3: 312 \u00b5s per loop\n\n%timeit [item for sublist in l for item in sublist]\n1000 loops, best of 3: 31.5 \u00b5s per loop\n\nYou can find out more here in the documentation, numpy.concatenate and numpy.ravel.\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [
            {
                "_id": 340,
                "_Comentario__descripcion": "Doesn't work for unevenly nested lists like [1, 2, [3], [[4]], [5, [6]]]",
                "_Comentario__fecha": "2019-04-22 21:39:37Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "EL_DON",
                "usuario_id": null
            },
            {
                "_id": 341,
                "_Comentario__descripcion": "@EL_DON of course, that isn't what this question is asking, there is another question that deals with that case",
                "_Comentario__fecha": "2021-07-31 18:54:23Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "juanpa.arrivillaga",
                "usuario_id": null
            },
            {
                "_id": 342,
                "_Comentario__descripcion": "@juanpa.arrivillaga it's a simple and natural extension of the question, though. Answers that can handle greater depth of nesting are more likely to be useful to someone who finds this question.",
                "_Comentario__fecha": "2021-08-02 19:53:32Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "EL_DON",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 229,
        "_Respuesta__fecha": "2017-08-08 14:59:07Z",
        "_Respuesta__descripcion": "\ndef flatten(alist):\n    if alist == []:\n        return []\n    elif type(alist) is not list:\n        return [alist]\n    else:\n        return flatten(alist[0]) + flatten(alist[1:])\n\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [
            {
                "_id": 343,
                "_Comentario__descripcion": "Fails for python2.7 for the example nested list in the question: [[1, 2, 3], [4, 5, 6], [7], [8, 9]]",
                "_Comentario__fecha": "2019-04-22 21:34:17Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "EL_DON",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 230,
        "_Respuesta__fecha": "2018-06-19 19:38:25Z",
        "_Respuesta__descripcion": "\nNote: Below applies to Python 3.3+ because it uses yield_from.  six is also a third-party package, though it is stable.  Alternately, you could use sys.version.\n\n\n\nIn the case of obj = [[1, 2,], [3, 4], [5, 6]], all of the solutions here are good, including list comprehension and itertools.chain.from_iterable.\n\nHowever, consider this slightly more complex case:\n\n>>> obj = [[1, 2, 3], [4, 5], 6, 'abc', [7], [8, [9, 10]]]\n\n\nThere are several problems here:\n\n\nOne element, 6, is just a scalar; it's not iterable, so the above routes will fail here.\nOne element, 'abc', is technically iterable (all strs are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.\nThe final element, [8, [9, 10]] is itself a nested iterable.  Basic list comprehension and chain.from_iterable only extract \"1 level down.\"\n\n\nYou can remedy this as follows:\n\n>>> from collections import Iterable\n>>> from six import string_types\n\n>>> def flatten(obj):\n...     for i in obj:\n...         if isinstance(i, Iterable) and not isinstance(i, string_types):\n...             yield from flatten(i)\n...         else:\n...             yield i\n\n\n>>> list(flatten(obj))\n[1, 2, 3, 4, 5, 6, 'abc', 7, 8, 9, 10]\n\n\nHere, you check that the sub-element (1) is iterable with Iterable, an ABC from itertools, but also want to ensure that (2) the element is not \"string-like.\"\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [
            {
                "_id": 344,
                "_Comentario__descripcion": "If you are still interested in Python 2 compatibility, change yield from to a for loop, e.g. for x in flatten(i): yield x",
                "_Comentario__fecha": "2018-06-19 19:06:43Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "pylang",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 231,
        "_Respuesta__fecha": "2018-05-20 08:47:32Z",
        "_Respuesta__descripcion": "\nThis may not be the most efficient way but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python3.5) and recursion.\n\ndef make_list_flat (l):\n    flist = []\n    flist.extend ([l]) if (type (l) is not list) else [flist.extend (make_list_flat (e)) for e in l]\n    return flist\n\na = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]\nflist = make_list_flat(a)\nprint (flist)\n\n\nThe output is\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n\n\nThis works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable flist and then rolls back it to the parent. Whenever flist is returned, it is extended to the parent's flist in the list comprehension. Therefore, at the root, a flat list is returned.\n\nThe above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl flist, like below.\n\na = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]\nflist = []\ndef make_list_flat (l):\n    flist.extend ([l]) if (type (l) is not list) else [make_list_flat (e) for e in l]\n\nmake_list_flat(a)\nprint (flist)\n\n\nThe output is again\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n\n\nAlthough I am not sure at this time about the efficiency.\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [
            {
                "_id": 345,
                "_Comentario__descripcion": "Why extend([l]) instead of append(l)?",
                "_Comentario__fecha": "2020-04-09 18:31:12Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Maciek",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 232,
        "_Respuesta__fecha": "2021-09-01 23:21:13Z",
        "_Respuesta__descripcion": "\nThere are several answers with the same recursive appending scheme as below, but none makes use of try, which makes the solution more robust and Pythonic.\ndef flatten(itr):\n    for x in itr:\n        try:\n            yield from flatten(x)\n        except TypeError:\n            yield x\n\nUsage: this is a generator, you typically want to enclose it in an iterable builder like list() or tuple() or use it in a for loop.\nAdvantages of this solution are:\n\nworks with any kind of iterable (even future ones!)\nworks with any combination and deepness of nesting\nworks also if top level contains bare items\nno dependencies\nefficient (you can flatten the nested iterable partially, without wasting time on the remaining part you don't need)\nversatile (you can use it to build an iterable of your choice or in a loop)\n\nN.B. since ALL iterables are flattened, strings are decomposed into sequences of single characters. If you don't like/want such behavior, you can use the following version which filters out from flattening iterables like strings and bytes:\ndef flatten(itr):\n    if type(itr) in (str,bytes):\n        yield itr\n    else:\n        for x in itr:\n            try:\n                yield from flatten(x)\n            except TypeError:\n                yield x\n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [
            {
                "_id": 346,
                "_Comentario__descripcion": "why would you use a tuple? now your solution is inefficient.",
                "_Comentario__fecha": "2021-07-31 18:53:23Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "juanpa.arrivillaga",
                "usuario_id": null
            },
            {
                "_id": 347,
                "_Comentario__descripcion": "And with any sequence, sum((flatten(e) for e in itr), tuple()) is highly inefficient,",
                "_Comentario__fecha": "2021-07-31 18:53:53Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "juanpa.arrivillaga",
                "usuario_id": null
            },
            {
                "_id": 348,
                "_Comentario__descripcion": "@juanpa.arrivillaga Your comment made me think about improving my answer and I think I found a better one, what do you think?",
                "_Comentario__fecha": "2021-08-01 17:37:17Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "mmj",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 233,
        "_Respuesta__fecha": "2018-09-13 11:34:20Z",
        "_Respuesta__descripcion": "\nAnother unusual approach that works for hetero- and homogeneous lists of integers:\n\nfrom typing import List\n\n\ndef flatten(l: list) -> List[int]:\n    \"\"\"Flatten an arbitrary deep nested list of lists of integers.\n\n    Examples:\n        >>> flatten([1, 2, [1, [10]]])\n        [1, 2, 1, 10]\n\n    Args:\n        l: Union[l, Union[int, List[int]]\n\n    Returns:\n        Flatted list of integer\n    \"\"\"\n    return [int(i.strip('[ ]')) for i in str(l).split(',')]\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [
            {
                "_id": 349,
                "_Comentario__descripcion": "That's just a more complicated and a bit slower way of what \u1d21\u029c\u1d00\u1d04\u1d0b\u1d00\u1d0d\u1d00\u1d05\u1d0f\u1d0f\u1d05\u029f\u1d073000 already posted before. I reinvented his proposal yesterday, so this approach seems quite popular these days ;)",
                "_Comentario__fecha": "2018-01-10 22:03:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Darkonaut",
                "usuario_id": null
            },
            {
                "_id": 350,
                "_Comentario__descripcion": "Not quite:  wierd_list = [[1, 2, 3], [4, 5, 6], [7], [8, 9], 10] >> nice_list=[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0]",
                "_Comentario__fecha": "2018-01-11 08:17:10Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "tharndt",
                "usuario_id": null
            },
            {
                "_id": 351,
                "_Comentario__descripcion": "my code as one liner would be :  flat_list = [int(e.replace('[','').replace(']','')) for e in str(deep_list).split(',')]",
                "_Comentario__fecha": "2018-01-11 08:32:18Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "tharndt",
                "usuario_id": null
            },
            {
                "_id": 352,
                "_Comentario__descripcion": "You are indeed right +1, \u1d21\u029c\u1d00\u1d04\u1d0b\u1d00\u1d0d\u1d00\u1d05\u1d0f\u1d0f\u1d05\u029f\u1d073000's proposal won't work with multiple digit numbers, I also didn't test this before although it should be obvious. You could simplify your code and write [int(e.strip('[ ]')) for e in str(deep_list).split(',')]. But I'd suggest to stick with Deleet's proposal for real use cases. It doesn't contain hacky type transformations, it's faster and more versatile because it naturally also handles lists with mixed types.",
                "_Comentario__fecha": "2018-01-11 16:31:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Darkonaut",
                "usuario_id": null
            },
            {
                "_id": 353,
                "_Comentario__descripcion": "Unfortunately no. But I saw this code recently here: Python Practice Book 6.1.2",
                "_Comentario__fecha": "2018-01-15 08:18:01Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "tharndt",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 234,
        "_Respuesta__fecha": "2020-11-06 17:13:39Z",
        "_Respuesta__descripcion": "\nnp.hstack(listoflist).tolist()\n\n    ",
        "_Respuesta__votes": -2,
        "comentarios": [
            {
                "_id": 354,
                "_Comentario__descripcion": "While this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value. Consider reading How to Answer and edit your answer to improve it.",
                "_Comentario__fecha": "2020-11-06 19:31:40Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Donald Duck",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 236,
        "_Respuesta__fecha": "2021-01-28 13:45:16Z",
        "_Respuesta__descripcion": "\nSolution\nSince Python 3, input returns a string which you have to explicitly convert to ints, with int, like this\nx = int(input(\"Enter a number: \"))\ny = int(input(\"Enter a number: \"))\n\nYou can accept numbers of any base and convert them directly to base-10 with the int function, like this\n>>> data = int(input(\"Enter a number: \"), 8)\nEnter a number: 777\n>>> data\n511\n>>> data = int(input(\"Enter a number: \"), 16)\nEnter a number: FFFF\n>>> data\n65535\n>>> data = int(input(\"Enter a number: \"), 2)\nEnter a number: 10101010101\n>>> data\n1365\n\nThe second parameter tells what is the base of the numbers entered and then internally it understands and converts it. If the entered data is wrong it will throw a ValueError.\n>>> data = int(input(\"Enter a number: \"), 2)\nEnter a number: 1234\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nValueError: invalid literal for int() with base 2: '1234'\n\nFor values that can have a fractional component, the type would be float rather than int:\nx = float(input(\"Enter a number:\"))\n\nDifferences between Python 2 and 3\nSummary\n\nPython 2's input function evaluated the received data, converting it to an integer implicitly (read the next section to understand the implication), but Python 3's input function does not do that anymore.\nPython 2's equivalent of Python 3's input is the raw_input function.\n\nPython 2.x\nThere were two functions to get user input, called input and raw_input. The difference between them is, raw_input doesn't evaluate the data and returns as it is, in string form. But, input will evaluate whatever you entered and the result of evaluation will be returned. For example,\n>>> import sys\n>>> sys.version\n'2.7.6 (default, Mar 22 2014, 22:59:56) \\n[GCC 4.8.2]'\n>>> data = input(\"Enter a number: \")\nEnter a number: 5 + 17\n>>> data, type(data)\n(22, <type 'int'>)\n\nThe data 5 + 17 is evaluated and the result is 22. When it evaluates the expression 5 + 17, it detects that you are adding two numbers and so the result will also be of the same int type. So, the type conversion is done for free and 22 is returned as the result of input and stored in data variable. You can think of input as the raw_input composed with an eval call.\n>>> data = eval(raw_input(\"Enter a number: \"))\nEnter a number: 5 + 17\n>>> data, type(data)\n(22, <type 'int'>)\n\nNote: you should be careful when you are using input in Python 2.x. I explained why one should be careful when using it, in this answer.\nBut, raw_input doesn't evaluate the input and returns as it is, as a string.\n>>> import sys\n>>> sys.version\n'2.7.6 (default, Mar 22 2014, 22:59:56) \\n[GCC 4.8.2]'\n>>> data = raw_input(\"Enter a number: \")\nEnter a number: 5 + 17\n>>> data, type(data)\n('5 + 17', <type 'str'>)\n\nPython 3.x\nPython 3.x's input and Python 2.x's raw_input are similar and raw_input is not available in Python 3.x.\n>>> import sys\n>>> sys.version\n'3.4.0 (default, Apr 11 2014, 13:05:11) \\n[GCC 4.8.2]'\n>>> data = input(\"Enter a number: \")\nEnter a number: 5 + 17\n>>> data, type(data)\n('5 + 17', <class 'str'>)\n\n    ",
        "_Respuesta__votes": 354,
        "comentarios": [
            {
                "_id": 361,
                "_Comentario__descripcion": "Is there any other way, like a function or something so that we dont need to convert to int in 3.x other than doing explicit conversion to int??",
                "_Comentario__fecha": "2016-04-09 06:19:24Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Shreyan Mehta",
                "usuario_id": null
            },
            {
                "_id": 362,
                "_Comentario__descripcion": "@ShreyanMehta eval would work, but don't go for that unless you have pressing reasons.",
                "_Comentario__fecha": "2016-04-09 07:01:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "thefourtheye",
                "usuario_id": null
            },
            {
                "_id": 363,
                "_Comentario__descripcion": "@thefourtheye at least use ast.literal_eval for that. It does not have the security concerns of eval.",
                "_Comentario__fecha": "2018-04-06 12:48:28Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "spectras",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 237,
        "_Respuesta__fecha": "2019-05-17 12:08:00Z",
        "_Respuesta__descripcion": "\nIn Python 3.x, raw_input was renamed to input and the Python 2.x input was removed.  \n\nThis means that, just like raw_input, input in Python 3.x always returns a string object.\n\nTo fix the problem, you need to explicitly make those inputs into integers by putting them in int:\n\nx = int(input(\"Enter a number: \"))\ny = int(input(\"Enter a number: \"))\n\n    ",
        "_Respuesta__votes": 49,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 238,
        "_Respuesta__fecha": "2019-05-17 12:11:57Z",
        "_Respuesta__descripcion": "\nFor multiple integer in a single line, map might be better.\n\narr = map(int, raw_input().split())\n\n\nIf the number is already known, (like 2 integers), you can use\n\nnum1, num2 = map(int, raw_input().split())\n\n    ",
        "_Respuesta__votes": 32,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 239,
        "_Respuesta__fecha": "2019-05-17 12:12:35Z",
        "_Respuesta__descripcion": "\ninput() (Python 3) and raw_input() (Python 2) always return strings. Convert the result to integer explicitly with int().\n\nx = int(input(\"Enter a number: \"))\ny = int(input(\"Enter a number: \"))\n\n    ",
        "_Respuesta__votes": 18,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 240,
        "_Respuesta__fecha": "2020-05-27 09:51:58Z",
        "_Respuesta__descripcion": "\nMultiple questions require input for several integers on single line.  The best way is to input the whole string of numbers one one line and then split them to integers. Here is a Python 3 version:\n\na = []\np = input()\np = p.split()      \nfor i in p:\n    a.append(int(i))\n\n\nAlso a list comprehension can be used\n\np = input().split(\"whatever the seperator is\")\n\n\nAnd to convert all the inputs from string to int we do the following\n\nx = [int(i) for i in p]\nprint(x, end=' ')\n\n\nshall print the list elements in a straight line.\n    ",
        "_Respuesta__votes": 12,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 241,
        "_Respuesta__fecha": "2017-01-26 04:28:51Z",
        "_Respuesta__descripcion": "\nConvert to integers:\n\nmy_number = int(input(\"enter the number\"))\n\n\nSimilarly for floating point numbers:\n\nmy_decimalnumber = float(input(\"enter the number\"))\n\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 242,
        "_Respuesta__fecha": "2018-08-03 16:30:31Z",
        "_Respuesta__descripcion": "\nn=int(input())\nfor i in range(n):\n    n=input()\n    n=int(n)\n    arr1=list(map(int,input().split()))\n\n\nthe for loop shall run 'n' number of times . the second 'n' is the length of the array.\nthe last statement maps the integers to a list and takes input in space separated form .\nyou can also return the array at the end of for loop.\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 243,
        "_Respuesta__fecha": "2014-05-23 11:32:22Z",
        "_Respuesta__descripcion": "\nI encountered a problem of taking integer input while solving a problem on CodeChef, where two integers - separated by space - should be read from one line.\n\nWhile int(input()) is sufficient for a single integer, I did not find a direct way to input two integers.  I tried this:\n\nnum = input()\nnum1 = 0\nnum2 = 0\n\nfor i in range(len(num)):\n    if num[i] == ' ':\n        break\n\nnum1 = int(num[:i])\nnum2 = int(num[i+1:])\n\n\nNow I use num1 and  num2 as integers.  Hope this helps.\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [
            {
                "_id": 364,
                "_Comentario__descripcion": "This looks very interesting.  However, isn't i destroyed when the for loop is exited?",
                "_Comentario__fecha": "2014-05-23 16:33:19Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "NA",
                "usuario_id": null
            },
            {
                "_id": 365,
                "_Comentario__descripcion": "@hosch250 When a loop is exited, the value of the index variable (here, i) remains.  I tried this piece out, and it works correctly.",
                "_Comentario__fecha": "2014-05-24 15:18:11Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Aravind",
                "usuario_id": null
            },
            {
                "_id": 366,
                "_Comentario__descripcion": "For this kind of input manipulation, you can either num1, num2 = map(int, input().split()) if you know how much integers you will encounter or nums = list(map(int, input().split())) if you don't.",
                "_Comentario__fecha": "2018-07-12 12:58:38Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "301_Moved_Permanently",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 244,
        "_Respuesta__fecha": "2019-04-04 08:47:19Z",
        "_Respuesta__descripcion": "\ndef dbz():\n    try:\n        r = raw_input(\"Enter number:\")\n        if r.isdigit():\n            i = int(raw_input(\"Enter divident:\"))\n            d = int(r)/i\n            print \"O/p is -:\",d\n        else:\n            print \"Not a number\"\n    except Exception ,e:\n        print \"Program halted incorrect data entered\",type(e)\ndbz()\n\nOr \n\nnum = input(\"Enter Number:\")#\"input\" will accept only numbers\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 245,
        "_Respuesta__fecha": "2016-11-23 12:19:52Z",
        "_Respuesta__descripcion": "\nWhile in your example, int(input(...)) does the trick in any case, python-future's builtins.input is worth consideration since that makes sure your code works for both Python 2 and 3 and disables Python2's default behaviour of input trying to be \"clever\" about the input data type (builtins.input basically just behaves like raw_input).\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 247,
        "_Respuesta__fecha": "2019-11-28 01:43:27Z",
        "_Respuesta__descripcion": "\nHere's a generator that yields the chunks you want:\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n\n\n\n\nimport pprint\npprint.pprint(list(chunks(range(10, 75), 10)))\n[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n\n\n\n\nIf you're using Python 2, you should use xrange() instead of range():\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in xrange(0, len(lst), n):\n        yield lst[i:i + n]\n\n\n\n\nAlso you can simply use list comprehension instead of writing a function, though it's a good idea to encapsulate operations like this in named functions so that your code is easier to understand. Python 3:\n\n[lst[i:i + n] for i in range(0, len(lst), n)]\n\n\nPython 2 version:\n\n[lst[i:i + n] for i in xrange(0, len(lst), n)]\n\n    ",
        "_Respuesta__votes": 3802,
        "comentarios": [
            {
                "_id": 373,
                "_Comentario__descripcion": "What happens if we can't tell the length of the list? Try this on itertools.repeat([ 1, 2, 3 ]), e.g.",
                "_Comentario__fecha": "2008-11-23 12:51:10Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "jespern",
                "usuario_id": null
            },
            {
                "_id": 374,
                "_Comentario__descripcion": "That's an interesting extension to the question, but the original question clearly asked about operating on a list.",
                "_Comentario__fecha": "2008-11-23 13:53:37Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Ned Batchelder",
                "usuario_id": null
            },
            {
                "_id": 375,
                "_Comentario__descripcion": "this functions needs to be in the damn standard library",
                "_Comentario__fecha": "2018-02-04 14:19:55Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "dgan",
                "usuario_id": null
            },
            {
                "_id": 376,
                "_Comentario__descripcion": "@Calimo: what do you suggest? I hand you a list with 47 elements. How would you like to split it into \"evenly sized chunks\"? The OP accepted the answer, so they are clearly OK with the last differently sized chunk. Perhaps the English phrase is imprecise?",
                "_Comentario__fecha": "2018-06-14 15:29:23Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Ned Batchelder",
                "usuario_id": null
            },
            {
                "_id": 377,
                "_Comentario__descripcion": "Most people will be looking at this for batch processing and rate limiting, so it usually doesn't matter if the last chunk is smaller",
                "_Comentario__fecha": "2019-07-04 12:46:37Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Alvaro",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 248,
        "_Respuesta__fecha": "2020-01-06 10:56:07Z",
        "_Respuesta__descripcion": "\nIf you want something super simple:\n\ndef chunks(l, n):\n    n = max(1, n)\n    return (l[i:i+n] for i in range(0, len(l), n))\n\n\nUse xrange() instead of range() in the case of Python 2.x\n    ",
        "_Respuesta__votes": 609,
        "comentarios": [
            {
                "_id": 378,
                "_Comentario__descripcion": "Or (if we're doing different representations of this particular function) you could define a lambda function via: lambda x,y: [ x[i:i+y] for i in range(0,len(x),y)] . I love this list-comprehension method!",
                "_Comentario__fecha": "2011-08-20 13:54:34Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "J-P",
                "usuario_id": null
            },
            {
                "_id": 379,
                "_Comentario__descripcion": "Using short circuiting, len(l) or 1 to deal with empty lists.",
                "_Comentario__fecha": "2021-08-12 15:24:35Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "keepAlive",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 249,
        "_Respuesta__fecha": "2017-09-21 09:47:29Z",
        "_Respuesta__descripcion": "\nDirectly from the (old) Python documentation (recipes for itertools):\n\nfrom itertools import izip, chain, repeat\n\ndef grouper(n, iterable, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --> ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return izip(*[chain(iterable, repeat(padvalue, n-1))]*n)\n\n\nThe current version, as suggested by J.F.Sebastian:\n\n#from itertools import izip_longest as zip_longest # for Python 2.x\nfrom itertools import zip_longest # for Python 3.x\n#from six.moves import zip_longest # for both (uses the six compat library)\n\ndef grouper(n, iterable, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --> ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)\n\n\nI guess Guido's time machine works\u2014worked\u2014will work\u2014will have worked\u2014was working again.\n\nThese solutions work because [iter(iterable)]*n (or the equivalent in the earlier version) creates one iterator, repeated n times in the list. izip_longest then effectively performs a round-robin of \"each\" iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of n items.\n    ",
        "_Respuesta__votes": 323,
        "comentarios": [
            {
                "_id": 380,
                "_Comentario__descripcion": "upvoted this because it works on generators (no len) and uses the generally faster itertools module.",
                "_Comentario__fecha": "2012-01-30 23:47:08Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Michael Dillon",
                "usuario_id": null
            },
            {
                "_id": 381,
                "_Comentario__descripcion": "A classic example of fancy itertools functional approach turning out some unreadable sludge, when compared to a simple and naive pure python implementation",
                "_Comentario__fecha": "2013-04-12 05:40:11Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "wim",
                "usuario_id": null
            },
            {
                "_id": 382,
                "_Comentario__descripcion": "@wim Given that this answer began as a snippet from the Python documentation, I'd suggest you open an issue on bugs.python.org .",
                "_Comentario__fecha": "2013-04-12 11:36:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "tzot",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 250,
        "_Respuesta__fecha": "2019-10-14 08:16:28Z",
        "_Respuesta__descripcion": "\nI know this is kind of old but nobody yet mentioned numpy.array_split:\n\nimport numpy as np\n\nlst = range(50)\nnp.array_split(lst, 5)\n# [array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n#  array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19]),\n#  array([20, 21, 22, 23, 24, 25, 26, 27, 28, 29]),\n#  array([30, 31, 32, 33, 34, 35, 36, 37, 38, 39]),\n#  array([40, 41, 42, 43, 44, 45, 46, 47, 48, 49])]\n\n    ",
        "_Respuesta__votes": 320,
        "comentarios": [
            {
                "_id": 383,
                "_Comentario__descripcion": "This allows you to set the total number of chunks, not the number of elements per chunk.",
                "_Comentario__fecha": "2015-09-09 03:03:50Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "FizxMike",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 251,
        "_Respuesta__fecha": "2018-11-17 01:16:27Z",
        "_Respuesta__descripcion": "\nI'm surprised nobody has thought of using iter's two-argument form:\n\nfrom itertools import islice\n\ndef chunk(it, size):\n    it = iter(it)\n    return iter(lambda: tuple(islice(it, size)), ())\n\n\nDemo:\n\n>>> list(chunk(range(14), 3))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13)]\n\n\nThis works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice:\n\nfrom itertools import islice, chain, repeat\n\ndef chunk_pad(it, size, padval=None):\n    it = chain(iter(it), repeat(padval))\n    return iter(lambda: tuple(islice(it, size)), (padval,) * size)\n\n\nDemo:\n\n>>> list(chunk_pad(range(14), 3))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, None)]\n>>> list(chunk_pad(range(14), 3, 'a'))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, 'a')]\n\n\nLike the izip_longest-based solutions, the above always pads. As far as I know, there's no one- or two-line itertools recipe for a function that optionally pads. By combining the above two approaches, this one comes pretty close:\n\n_no_padding = object()\n\ndef chunk(it, size, padval=_no_padding):\n    if padval == _no_padding:\n        it = iter(it)\n        sentinel = ()\n    else:\n        it = chain(iter(it), repeat(padval))\n        sentinel = (padval,) * size\n    return iter(lambda: tuple(islice(it, size)), sentinel)\n\n\nDemo:\n\n>>> list(chunk(range(14), 3))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13)]\n>>> list(chunk(range(14), 3, None))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, None)]\n>>> list(chunk(range(14), 3, 'a'))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, 'a')]\n\n\nI believe this is the shortest chunker proposed that offers optional padding.\n\nAs Tomasz Gandor observed, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way:\n\n_no_padding = object()\ndef chunk(it, size, padval=_no_padding):\n    it = iter(it)\n    chunker = iter(lambda: tuple(islice(it, size)), ())\n    if padval == _no_padding:\n        yield from chunker\n    else:\n        for ch in chunker:\n            yield ch if len(ch) == size else ch + (padval,) * (size - len(ch))\n\n\nDemo:\n\n>>> list(chunk([1, 2, (), (), 5], 2))\n[(1, 2), ((), ()), (5,)]\n>>> list(chunk([1, 2, None, None, 5], 2, None))\n[(1, 2), (None, None), (5, None)]\n\n    ",
        "_Respuesta__votes": 226,
        "comentarios": [
            {
                "_id": 384,
                "_Comentario__descripcion": "Wonderful, your simple version is my favorite. Others too came up with the basic islice(it, size) expression and embedded it (like I had done) in a loop construct. Only you thought of the two-argument version of iter() (I was completely unaware of), which makes it super-elegant (and probably most performance-effective). I had no idea that the first argument to iter changes to a 0-argument function when given the sentinel. You return a (pot. infinite) iterator of chunks, can use a (pot. infinite) iterator as input, have no len() and no array slices. Awesome!",
                "_Comentario__fecha": "2016-09-15 19:58:02Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "ThomasH",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 252,
        "_Respuesta__fecha": "2012-09-17 21:22:03Z",
        "_Respuesta__descripcion": "\nHere is a generator that work on arbitrary iterables:\n\ndef split_seq(iterable, size):\n    it = iter(iterable)\n    item = list(itertools.islice(it, size))\n    while item:\n        yield item\n        item = list(itertools.islice(it, size))\n\n\nExample:\n\n>>> import pprint\n>>> pprint.pprint(list(split_seq(xrange(75), 10)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n\n    ",
        "_Respuesta__votes": 106,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 253,
        "_Respuesta__fecha": "2021-04-26 08:35:26Z",
        "_Respuesta__descripcion": "\nSimple yet elegant\nL = range(1, 1000)\nprint [L[x:x+10] for x in xrange(0, len(L), 10)]\n\nor if you prefer:\ndef chunks(L, n): return [L[x: x+n] for x in xrange(0, len(L), n)]\nchunks(L, 10)\n\n    ",
        "_Respuesta__votes": 66,
        "comentarios": [
            {
                "_id": 385,
                "_Comentario__descripcion": "Thou shalt not dub a variable in the likeness of an Arabic number.  In some fonts, 1 and l are indistinguishable.  As are 0 and O.  And sometimes even I and 1.",
                "_Comentario__fecha": "2013-08-14 23:02:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Alfe",
                "usuario_id": null
            },
            {
                "_id": 386,
                "_Comentario__descripcion": "@Alfe Defective fonts.  People shouldn't use such fonts.  Not for programming, not for anything.",
                "_Comentario__fecha": "2013-10-05 08:14:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Jerry B",
                "usuario_id": null
            },
            {
                "_id": 387,
                "_Comentario__descripcion": "Lambdas are meant to be used as unnamed functions. There is no point in using them like that. In addition it makes debugging more difficult as the traceback will report \"in <lambda>\" instead of \"in chunks\" in case of error. I wish you luck finding a problem if you have whole bunch of these :)",
                "_Comentario__fecha": "2013-11-26 19:45:40Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Chris Koston",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 254,
        "_Respuesta__fecha": "2012-09-17 21:22:25Z",
        "_Respuesta__descripcion": "\ndef chunk(input, size):\n    return map(None, *([iter(input)] * size))\n\n    ",
        "_Respuesta__votes": 60,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 255,
        "_Respuesta__fecha": "2021-01-24 04:42:44Z",
        "_Respuesta__descripcion": "\nHow do you split a list into evenly sized chunks?\n\"Evenly sized chunks\", to me, implies that they are all the same length, or barring that option, at minimal variance in length. E.g. 5 baskets for 21 items could have the following results:\n>>> import statistics\n>>> statistics.variance([5,5,5,5,1]) \n3.2\n>>> statistics.variance([5,4,4,4,4]) \n0.19999999999999998\n\nA practical reason to prefer the latter result: if you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard.\nCritique of other answers here\nWhen I originally wrote this answer, none of the other answers were evenly sized chunks - they all leave a runt chunk at the end, so they're not well balanced, and have a higher than necessary variance of lengths.\nFor example, the current top answer ends with:\n[60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n[70, 71, 72, 73, 74]]\n\nOthers, like list(grouper(3, range(7))), and chunk(range(7), 3) both return: [(0, 1, 2), (3, 4, 5), (6, None, None)]. The None's are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables.\nWhy can't we divide these better?\nCycle Solution\nA high-level balanced solution using itertools.cycle, which is the way I might do it today. Here's the setup:\nfrom itertools import cycle\nitems = range(10, 75)\nnumber_of_baskets = 10\n\nNow we need our lists into which to populate the elements:\nbaskets = [[] for _ in range(number_of_baskets)]\n\nFinally, we zip the elements we're going to allocate together with a cycle of the baskets until we run out of elements, which, semantically, it exactly what we want:\nfor element, basket in zip(items, cycle(baskets)):\n    basket.append(element)\n\nHere's the result:\n>>> from pprint import pprint\n>>> pprint(baskets)\n[[10, 20, 30, 40, 50, 60, 70],\n [11, 21, 31, 41, 51, 61, 71],\n [12, 22, 32, 42, 52, 62, 72],\n [13, 23, 33, 43, 53, 63, 73],\n [14, 24, 34, 44, 54, 64, 74],\n [15, 25, 35, 45, 55, 65],\n [16, 26, 36, 46, 56, 66],\n [17, 27, 37, 47, 57, 67],\n [18, 28, 38, 48, 58, 68],\n [19, 29, 39, 49, 59, 69]]\n\nTo productionize this solution, we write a function, and provide the type annotations:\nfrom itertools import cycle\nfrom typing import List, Any\n\ndef cycle_baskets(items: List[Any], maxbaskets: int) -> List[List[Any]]:\n    baskets = [[] for _ in range(min(maxbaskets, len(items)))]\n    for item, basket in zip(items, cycle(baskets)):\n        basket.append(item)\n    return baskets\n\nIn the above, we take our list of items, and the max number of baskets. We create a list of empty lists, in which to append each element, in a round-robin style.\nSlices\nAnother elegant solution is to use slices - specifically the less-commonly used step argument to slices. i.e.:\nstart = 0\nstop = None\nstep = number_of_baskets\n\nfirst_basket = items[start:stop:step]\n\nThis is especially elegant in that slices don't care how long the data are - the result, our first basket, is only as long as it needs to be. We'll only need to increment the starting point for each basket.\nIn fact this could be a one-liner, but we'll go multiline for readability and to avoid an overlong line of code:\nfrom typing import List, Any\n\ndef slice_baskets(items: List[Any], maxbaskets: int) -> List[List[Any]]:\n    n_baskets = min(maxbaskets, len(items))\n    return [items[i::n_baskets] for i in range(n_baskets)]\n\nAnd islice from the itertools module will provide a lazily iterating approach, like that which was originally asked for in the question.\nI don't expect most use-cases to benefit very much, as the original data is already fully materialized in a list, but for large datasets, it could save nearly half the memory usage.\nfrom itertools import islice\nfrom typing import List, Any, Generator\n    \ndef yield_islice_baskets(items: List[Any], maxbaskets: int) -> Generator[List[Any], None, None]:\n    n_baskets = min(maxbaskets, len(items))\n    for i in range(n_baskets):\n        yield islice(items, i, None, n_baskets)\n\nView results with:\nfrom pprint import pprint\n\nitems = list(range(10, 75))\npprint(cycle_baskets(items, 10))\npprint(slice_baskets(items, 10))\npprint([list(s) for s in yield_islice_baskets(items, 10)])\n\nUpdated prior solutions\nHere's another balanced solution, adapted from a function I've used in production in the past, that uses the modulo operator:\ndef baskets_from(items, maxbaskets=25):\n    baskets = [[] for _ in range(maxbaskets)]\n    for i, item in enumerate(items):\n        baskets[i % maxbaskets].append(item)\n    return filter(None, baskets) \n\nAnd I created a generator that does the same if you put it into a list:\ndef iter_baskets_from(items, maxbaskets=3):\n    '''generates evenly balanced baskets from indexable iterable'''\n    item_count = len(items)\n    baskets = min(item_count, maxbaskets)\n    for x_i in range(baskets):\n        yield [items[y_i] for y_i in range(x_i, item_count, baskets)]\n    \n\nAnd finally, since I see that all of the above functions return elements in a contiguous order (as they were given):\ndef iter_baskets_contiguous(items, maxbaskets=3, item_count=None):\n    '''\n    generates balanced baskets from iterable, contiguous contents\n    provide item_count if providing a iterator that doesn't support len()\n    '''\n    item_count = item_count or len(items)\n    baskets = min(item_count, maxbaskets)\n    items = iter(items)\n    floor = item_count // baskets \n    ceiling = floor + 1\n    stepdown = item_count % baskets\n    for x_i in range(baskets):\n        length = ceiling if x_i < stepdown else floor\n        yield [items.next() for _ in range(length)]\n\nOutput\nTo test them out:\nprint(baskets_from(range(6), 8))\nprint(list(iter_baskets_from(range(6), 8)))\nprint(list(iter_baskets_contiguous(range(6), 8)))\nprint(baskets_from(range(22), 8))\nprint(list(iter_baskets_from(range(22), 8)))\nprint(list(iter_baskets_contiguous(range(22), 8)))\nprint(baskets_from('ABCDEFG', 3))\nprint(list(iter_baskets_from('ABCDEFG', 3)))\nprint(list(iter_baskets_contiguous('ABCDEFG', 3)))\nprint(baskets_from(range(26), 5))\nprint(list(iter_baskets_from(range(26), 5)))\nprint(list(iter_baskets_contiguous(range(26), 5)))\n\nWhich prints out:\n[[0], [1], [2], [3], [4], [5]]\n[[0], [1], [2], [3], [4], [5]]\n[[0], [1], [2], [3], [4], [5]]\n[[0, 8, 16], [1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14], [7, 15]]\n[[0, 8, 16], [1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14], [7, 15]]\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14], [15, 16, 17], [18, 19], [20, 21]]\n[['A', 'D', 'G'], ['B', 'E'], ['C', 'F']]\n[['A', 'D', 'G'], ['B', 'E'], ['C', 'F']]\n[['A', 'B', 'C'], ['D', 'E'], ['F', 'G']]\n[[0, 5, 10, 15, 20, 25], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]]\n[[0, 5, 10, 15, 20, 25], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]]\n[[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]\n\nNotice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements.\n    ",
        "_Respuesta__votes": 49,
        "comentarios": [
            {
                "_id": 388,
                "_Comentario__descripcion": "You say that none of the above provides evenly-sized chunks. But this one does, as does this one.",
                "_Comentario__fecha": "2014-02-26 15:00:56Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "senderle",
                "usuario_id": null
            },
            {
                "_id": 389,
                "_Comentario__descripcion": "@senderle, The first one, list(grouper(3, xrange(7))), and the second one, chunk(xrange(7), 3) both return: [(0, 1, 2), (3, 4, 5), (6, None, None)]. The None's are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables. Thanks for your vote!",
                "_Comentario__fecha": "2014-02-26 16:07:24Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Aaron Hall\u2666",
                "usuario_id": null
            },
            {
                "_id": 390,
                "_Comentario__descripcion": "You raise the question (without doing it explicitly, so I do that now here) whether equally-sized chunks (except the last, if not possible) or whether a balanced (as good as possible) result is more often what will be needed.  You assume that the balanced solution is to prefer; this might be true if what you program is close to the real world (e. g. a card-dealing algorithm for a simulated card game).  In other cases (like filling lines with words) one will rather like to keep the lines as full as possible.  So I can't really prefer one over the other; they are just for different use cases.",
                "_Comentario__fecha": "2014-08-02 23:14:52Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Alfe",
                "usuario_id": null
            },
            {
                "_id": 391,
                "_Comentario__descripcion": "@ChristopherBarrington-Leigh Good point, for DataFrames, you should probably use slices, since I believe DataFrame objects do not usually copy on slicing, e.g. import pandas as pd; [pd.DataFrame(np.arange(7))[i::3] for i in xrange(3)]",
                "_Comentario__fecha": "2014-09-03 17:10:35Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Aaron Hall\u2666",
                "usuario_id": null
            },
            {
                "_id": 392,
                "_Comentario__descripcion": "@AaronHall Oops. I deleted my comment because I second-guessed my critique, but you were quick on the draw. Thanks! In fact, my claim that it doesn't work for dataframes is true.  If items is a dataframe, just use yield items[range(x_i, item_count, baskets)] as the last line. I offered a separate (yet another) answer, in which you specify the desired (minimum) group size.",
                "_Comentario__fecha": "2014-09-03 17:47:40Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "CPBL",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 256,
        "_Respuesta__fecha": "2017-06-21 13:36:41Z",
        "_Respuesta__descripcion": "\nI saw the most awesome Python-ish answer in a duplicate of this question:\n\nfrom itertools import zip_longest\n\na = range(1, 16)\ni = iter(a)\nr = list(zip_longest(i, i, i))\n>>> print(r)\n[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, 15)]\n\n\nYou can create n-tuple for any n. If a = range(1, 15), then the result will be:\n\n[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, None)]\n\n\nIf the list is divided evenly, then you can replace zip_longest with zip, otherwise the triplet (13, 14, None) would be lost. Python 3 is used above. For Python 2, use izip_longest.\n    ",
        "_Respuesta__votes": 45,
        "comentarios": [
            {
                "_id": 393,
                "_Comentario__descripcion": "that is nice if your list and chunks are short, how could you adapt this to split your list in to chunks of 1000 though? you\"re not going to code zip(i,i,i,i,i,i,i,i,i,i.....i=1000)",
                "_Comentario__fecha": "2015-05-18 14:21:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Tom Smith",
                "usuario_id": null
            },
            {
                "_id": 394,
                "_Comentario__descripcion": "zip(i, i, i, ... i) with \"chunk_size\" arguments to zip() can be written as zip(*[i]*chunk_size) Whether that's a good idea or not is debatable, of course.",
                "_Comentario__fecha": "2015-06-28 04:52:00Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Wilson F",
                "usuario_id": null
            },
            {
                "_id": 395,
                "_Comentario__descripcion": "The downside of this is that if you aren't dividing evenly, you'll drop elements, as zip stops at the shortest iterable - & izip_longest would add default elements.",
                "_Comentario__fecha": "2016-07-08 03:37:09Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Aaron Hall\u2666",
                "usuario_id": null
            },
            {
                "_id": 396,
                "_Comentario__descripcion": "zip_longest should be used, as done in: stackoverflow.com/a/434411/1959808",
                "_Comentario__fecha": "2017-06-21 13:28:18Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ioannis Filippidis",
                "usuario_id": null
            },
            {
                "_id": 397,
                "_Comentario__descripcion": "The answer with range(1, 15) is already missing elements, because there are 14 elements in range(1, 15), not 15.",
                "_Comentario__fecha": "2017-06-21 13:34:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ioannis Filippidis",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 257,
        "_Respuesta__fecha": "2019-04-18 11:18:24Z",
        "_Respuesta__descripcion": "\nIf you know list size:\n\ndef SplitList(mylist, chunk_size):\n    return [mylist[offs:offs+chunk_size] for offs in range(0, len(mylist), chunk_size)]\n\n\nIf you don't (an iterator):\n\ndef IterChunks(sequence, chunk_size):\n    res = []\n    for item in sequence:\n        res.append(item)\n        if len(res) >= chunk_size:\n            yield res\n            res = []\n    if res:\n        yield res  # yield the last, incomplete, portion\n\n\nIn the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk).\n    ",
        "_Respuesta__votes": 44,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 258,
        "_Respuesta__fecha": "2011-04-19 05:27:19Z",
        "_Respuesta__descripcion": "\nIf you had a chunk size of 3 for example, you could do:\n\nzip(*[iterable[i::3] for i in range(3)]) \n\n\nsource:\nhttp://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/\n\nI would use this when my chunk size is fixed number I can type, e.g. '3', and would never change.\n    ",
        "_Respuesta__votes": 23,
        "comentarios": [
            {
                "_id": 398,
                "_Comentario__descripcion": "This doesn't work if len(iterable)%3 != 0.  The last (short) group of numbers won't be returned.",
                "_Comentario__fecha": "2012-07-03 19:28:27Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "sherbang",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 259,
        "_Respuesta__fecha": "2015-12-16 21:42:56Z",
        "_Respuesta__descripcion": "\n[AA[i:i+SS] for i in range(len(AA))[::SS]]\n\n\nWhere AA is array, SS is chunk size. For example:\n\n>>> AA=range(10,21);SS=3\n>>> [AA[i:i+SS] for i in range(len(AA))[::SS]]\n[[10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20]]\n# or [range(10, 13), range(13, 16), range(16, 19), range(19, 21)] in py3\n\n    ",
        "_Respuesta__votes": 22,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 260,
        "_Respuesta__fecha": "2013-11-20 20:55:22Z",
        "_Respuesta__descripcion": "\nThe toolz library has the partition function for this:\n\nfrom toolz.itertoolz.core import partition\n\nlist(partition(2, [1, 2, 3, 4]))\n[(1, 2), (3, 4)]\n\n    ",
        "_Respuesta__votes": 21,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 261,
        "_Respuesta__fecha": "2019-12-10 11:59:57Z",
        "_Respuesta__descripcion": "\nWith Assignment Expressions in Python 3.8 it becomes quite nice:\n\nimport itertools\n\ndef batch(iterable, size):\n    it = iter(iterable)\n    while item := list(itertools.islice(it, size)):\n        yield item\n\n\nThis works on an arbitrary iterable, not just a list.\n\n>>> import pprint\n>>> pprint.pprint(list(batch(range(75), 10)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n\n    ",
        "_Respuesta__votes": 21,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 262,
        "_Respuesta__fecha": "2013-11-09 08:21:23Z",
        "_Respuesta__descripcion": "\nI like the Python doc's version proposed by tzot and J.F.Sebastian a lot,\n but it has two shortcomings:\n\n\nit is not very explicit\nI usually don't want a fill value in the last chunk\n\n\nI'm using this one a lot in my code:\n\nfrom itertools import islice\n\ndef chunks(n, iterable):\n    iterable = iter(iterable)\n    while True:\n        yield tuple(islice(iterable, n)) or iterable.next()\n\n\nUPDATE: A lazy chunks version:\n\nfrom itertools import chain, islice\n\ndef chunks(n, iterable):\n   iterable = iter(iterable)\n   while True:\n       yield chain([next(iterable)], islice(iterable, n-1))\n\n    ",
        "_Respuesta__votes": 17,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 263,
        "_Respuesta__fecha": "2018-01-07 08:58:54Z",
        "_Respuesta__descripcion": "\nI was curious about the performance of different approaches and here it is:\n\nTested on Python 3.5.1\n\nimport time\nbatch_size = 7\narr_len = 298937\n\n#---------slice-------------\n\nprint(\"\\r\\nslice\")\nstart = time.time()\narr = [i for i in range(0, arr_len)]\nwhile True:\n    if not arr:\n        break\n\n    tmp = arr[0:batch_size]\n    arr = arr[batch_size:-1]\nprint(time.time() - start)\n\n#-----------index-----------\n\nprint(\"\\r\\nindex\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor i in range(0, round(len(arr) / batch_size + 1)):\n    tmp = arr[batch_size * i : batch_size * (i + 1)]\nprint(time.time() - start)\n\n#----------batches 1------------\n\ndef batch(iterable, n=1):\n    l = len(iterable)\n    for ndx in range(0, l, n):\n        yield iterable[ndx:min(ndx + n, l)]\n\nprint(\"\\r\\nbatches 1\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor x in batch(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n#----------batches 2------------\n\nfrom itertools import islice, chain\n\ndef batch(iterable, size):\n    sourceiter = iter(iterable)\n    while True:\n        batchiter = islice(sourceiter, size)\n        yield chain([next(batchiter)], batchiter)\n\n\nprint(\"\\r\\nbatches 2\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor x in batch(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n#---------chunks-------------\ndef chunks(l, n):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n    for i in range(0, len(l), n):\n        yield l[i:i + n]\nprint(\"\\r\\nchunks\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor x in chunks(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n#-----------grouper-----------\n\nfrom itertools import zip_longest # for Python 3.x\n#from six.moves import zip_longest # for both (uses the six compat library)\n\ndef grouper(iterable, n, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --> ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)\n\narr = [i for i in range(0, arr_len)]\nprint(\"\\r\\ngrouper\")\nstart = time.time()\nfor x in grouper(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n\nResults:\n\nslice\n31.18285083770752\n\nindex\n0.02184295654296875\n\nbatches 1\n0.03503894805908203\n\nbatches 2\n0.22681021690368652\n\nchunks\n0.019841909408569336\n\ngrouper\n0.006506919860839844\n\n    ",
        "_Respuesta__votes": 17,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 264,
        "_Respuesta__fecha": "2016-08-31 17:30:54Z",
        "_Respuesta__descripcion": "\ncode:\n\ndef split_list(the_list, chunk_size):\n    result_list = []\n    while the_list:\n        result_list.append(the_list[:chunk_size])\n        the_list = the_list[chunk_size:]\n    return result_list\n\na_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint split_list(a_list, 3)\n\n\nresult:\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n\n    ",
        "_Respuesta__votes": 14,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 265,
        "_Respuesta__fecha": "2017-01-27 23:12:07Z",
        "_Respuesta__descripcion": "\nYou may also use get_chunks function of utilspie library as:\n\n>>> from utilspie import iterutils\n>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> list(iterutils.get_chunks(a, 5))\n[[1, 2, 3, 4, 5], [6, 7, 8, 9]]\n\n\nYou can install utilspie via pip:\n\nsudo pip install utilspie\n\n\nDisclaimer: I am the creator of utilspie library.\n    ",
        "_Respuesta__votes": 14,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 266,
        "_Respuesta__fecha": "2021-09-08 00:57:12Z",
        "_Respuesta__descripcion": "\nDon't reinvent the wheel.\nGiven\nimport itertools as it\nimport collections as ct\n\nimport more_itertools as mit\n\n\niterable = range(11)\nn = 3\n\nCode\nmore_itertools+\nlist(mit.chunked(iterable, n))\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n\nlist(mit.sliced(iterable, n))\n# [range(0, 3), range(3, 6), range(6, 9), range(9, 11)]\n\nlist(mit.grouper(n, iterable))\n# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, None)]\n\nlist(mit.windowed(iterable, len(iterable)//n, step=n))\n# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, None)]\n\nlist(mit.chunked_even(iterable, n))\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n\n(or DIY, if you want)\nThe Standard Library\nlist(it.zip_longest(*[iter(iterable)] * n))\n# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, None)]\n\n\nd = {}\nfor i, x in enumerate(iterable):\n    d.setdefault(i//n, []).append(x)\n    \n\nlist(d.values())\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n\n\ndd = ct.defaultdict(list)\nfor i, x in enumerate(iterable):\n    dd[i//n].append(x)\n    \n\nlist(dd.values())\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n\nReferences\n\nmore_itertools.chunked (related posted)\nmore_itertools.sliced\nmore_itertools.grouper (related post)\nmore_itertools.windowed (see also stagger, zip_offset)\nmore_itertools.chunked_even\nzip_longest (related post, related post)\nsetdefault (ordered results requires Python 3.6+)\ncollections.defaultdict  (ordered results requires Python 3.6+)\n\n+ A third-party library that implements itertools recipes and more. > pip install more_itertools \n    ",
        "_Respuesta__votes": 13,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 267,
        "_Respuesta__fecha": "2015-11-03 23:42:58Z",
        "_Respuesta__descripcion": "\nAt this point, I think we need a recursive generator, just in case...\n\nIn python 2:\n\ndef chunks(li, n):\n    if li == []:\n        return\n    yield li[:n]\n    for e in chunks(li[n:], n):\n        yield e\n\n\nIn python 3:\n\ndef chunks(li, n):\n    if li == []:\n        return\n    yield li[:n]\n    yield from chunks(li[n:], n)\n\n\nAlso, in case of massive Alien invasion, a decorated recursive generator might become handy:\n\ndef dec(gen):\n    def new_gen(li, n):\n        for e in gen(li, n):\n            if e == []:\n                return\n            yield e\n    return new_gen\n\n@dec\ndef chunks(li, n):\n    yield li[:n]\n    for e in chunks(li[n:], n):\n        yield e\n\n    ",
        "_Respuesta__votes": 12,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 268,
        "_Respuesta__fecha": "2008-11-24 16:56:57Z",
        "_Respuesta__descripcion": "\ndef split_seq(seq, num_pieces):\n    start = 0\n    for i in xrange(num_pieces):\n        stop = start + len(seq[i::num_pieces])\n        yield seq[start:stop]\n        start = stop\n\n\nusage:\n\nseq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor seq in split_seq(seq, 3):\n    print seq\n\n    ",
        "_Respuesta__votes": 10,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 269,
        "_Respuesta__fecha": "2008-11-23 12:51:16Z",
        "_Respuesta__descripcion": "\nheh, one line version\n\nIn [48]: chunk = lambda ulist, step:  map(lambda i: ulist[i:i+step],  xrange(0, len(ulist), step))\n\nIn [49]: chunk(range(1,100), 10)\nOut[49]: \n[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],\n [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n [41, 42, 43, 44, 45, 46, 47, 48, 49, 50],\n [51, 52, 53, 54, 55, 56, 57, 58, 59, 60],\n [61, 62, 63, 64, 65, 66, 67, 68, 69, 70],\n [71, 72, 73, 74, 75, 76, 77, 78, 79, 80],\n [81, 82, 83, 84, 85, 86, 87, 88, 89, 90],\n [91, 92, 93, 94, 95, 96, 97, 98, 99]]\n\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [
            {
                "_id": 399,
                "_Comentario__descripcion": "Please, use \"def chunk\" instead of \"chunk = lambda\".  It works the same.  One line.  Same features.  MUCH easier to the n00bz to read and understand.",
                "_Comentario__fecha": "2008-11-23 13:45:51Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "S.Lott",
                "usuario_id": null
            },
            {
                "_id": 400,
                "_Comentario__descripcion": "@S.Lott: not if the n00bz come from scheme :P this isn't a real problem. there's even a keyword to google! what other features show we avoid for the sake of the n00bz? i guess yield isn't imperative/c-like enough to be n00b friendly either then.",
                "_Comentario__fecha": "2012-05-11 21:10:56Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Janus Troelsen",
                "usuario_id": null
            },
            {
                "_id": 401,
                "_Comentario__descripcion": "The function object resulting from def chunk instead of chunk=lambda has .__name__ attribute 'chunk' instead of '<lambda>'. The specific name is more useful in tracebacks.",
                "_Comentario__fecha": "2012-06-27 04:20:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Terry Jan Reedy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 270,
        "_Respuesta__fecha": "2015-02-28 20:05:03Z",
        "_Respuesta__descripcion": "\nAnother more explicit version.\n\ndef chunkList(initialList, chunkSize):\n    \"\"\"\n    This function chunks a list into sub lists \n    that have a length equals to chunkSize.\n\n    Example:\n    lst = [3, 4, 9, 7, 1, 1, 2, 3]\n    print(chunkList(lst, 3)) \n    returns\n    [[3, 4, 9], [7, 1, 1], [2, 3]]\n    \"\"\"\n    finalList = []\n    for i in range(0, len(initialList), chunkSize):\n        finalList.append(initialList[i:i+chunkSize])\n    return finalList\n\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [
            {
                "_id": 402,
                "_Comentario__descripcion": "(2016 Sep 12) This answer is the most language independent and easiest to read.",
                "_Comentario__fecha": "2016-09-14 00:36:07Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "D Adams",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 271,
        "_Respuesta__fecha": "2016-05-16 06:29:12Z",
        "_Respuesta__descripcion": "\nWithout calling len() which is good for large lists:\n\ndef splitter(l, n):\n    i = 0\n    chunk = l[:n]\n    while chunk:\n        yield chunk\n        i += n\n        chunk = l[i:i+n]\n\n\nAnd this is for iterables:\n\ndef isplitter(l, n):\n    l = iter(l)\n    chunk = list(islice(l, n))\n    while chunk:\n        yield chunk\n        chunk = list(islice(l, n))\n\n\nThe functional flavour of the above:\n\ndef isplitter2(l, n):\n    return takewhile(bool,\n                     (tuple(islice(start, n))\n                            for start in repeat(iter(l))))\n\n\nOR:\n\ndef chunks_gen_sentinel(n, seq):\n    continuous_slices = imap(islice, repeat(iter(seq)), repeat(0), repeat(n))\n    return iter(imap(tuple, continuous_slices).next,())\n\n\nOR:\n\ndef chunks_gen_filter(n, seq):\n    continuous_slices = imap(islice, repeat(iter(seq)), repeat(0), repeat(n))\n    return takewhile(bool,imap(tuple, continuous_slices))\n\n    ",
        "_Respuesta__votes": 9,
        "comentarios": [
            {
                "_id": 403,
                "_Comentario__descripcion": "There is no reason to avoid len() on large lists; it's a constant-time operation.",
                "_Comentario__fecha": "2011-05-30 10:03:12Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Thomas Wouters",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 272,
        "_Respuesta__fecha": "2014-11-14 09:48:42Z",
        "_Respuesta__descripcion": "\nSee this reference\n\n>>> orange = range(1, 1001)\n>>> otuples = list( zip(*[iter(orange)]*10))\n>>> print(otuples)\n[(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), ... (991, 992, 993, 994, 995, 996, 997, 998, 999, 1000)]\n>>> olist = [list(i) for i in otuples]\n>>> print(olist)\n[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], ..., [991, 992, 993, 994, 995, 996, 997, 998, 999, 1000]]\n>>> \n\n\nPython3\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [
            {
                "_id": 404,
                "_Comentario__descripcion": "Nice, but drops elements at the end if the size does not match whole numbers of chunks, e. g. zip(*[iter(range(7))]*3) only returns [(0, 1, 2), (3, 4, 5)] and forgets the 6 from the input.",
                "_Comentario__fecha": "2013-08-14 23:17:34Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Alfe",
                "usuario_id": null
            },
            {
                "_id": 405,
                "_Comentario__descripcion": "OP wrote: 'I have a list of arbitrary length, and I need to split it up into equal size chunks and operate on it.'. Maybe I miss something but how to get 'equal size chunks' from list of arbitrary length without dropping chunk which is shorter than 'equal size'",
                "_Comentario__fecha": "2020-09-27 09:57:46Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Aivar Paalberg",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 273,
        "_Respuesta__fecha": "2012-02-13 04:50:38Z",
        "_Respuesta__descripcion": "\ndef chunks(iterable,n):\n    \"\"\"assumes n is an integer>0\n    \"\"\"\n    iterable=iter(iterable)\n    while True:\n        result=[]\n        for i in range(n):\n            try:\n                a=next(iterable)\n            except StopIteration:\n                break\n            else:\n                result.append(a)\n        if result:\n            yield result\n        else:\n            break\n\ng1=(i*i for i in range(10))\ng2=chunks(g1,3)\nprint g2\n'<generator object chunks at 0x0337B9B8>'\nprint list(g2)\n'[[0, 1, 4], [9, 16, 25], [36, 49, 64], [81]]'\n\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [
            {
                "_id": 406,
                "_Comentario__descripcion": "While this may not look as short or as pretty as many of the itertools based responses this one actually works if you want to print out the second sub-list before accessing the first, i.e., you can set i0=next(g2); i1=next(g2); and use i1 before using i0 and it doesn't break!!",
                "_Comentario__fecha": "2017-12-19 10:25:55Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Peter Gerdes",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 274,
        "_Respuesta__fecha": "2012-03-08 18:27:15Z",
        "_Respuesta__descripcion": "\nConsider using matplotlib.cbook pieces\n\nfor example:\n\nimport matplotlib.cbook as cbook\nsegments = cbook.pieces(np.arange(20), 3)\nfor s in segments:\n     print s\n\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [
            {
                "_id": 407,
                "_Comentario__descripcion": "Looks like you accidentally created two accounts. You can contact the team to have them merged, which will allow you to regain direct editing privileges on your contributions.",
                "_Comentario__fecha": "2019-05-15 15:15:26Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Georgy",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 275,
        "_Respuesta__fecha": "2016-11-03 19:10:45Z",
        "_Respuesta__descripcion": "\nSince everybody here talking about iterators. boltons has perfect method for that, called iterutils.chunked_iter.\n\nfrom boltons import iterutils\n\nlist(iterutils.chunked_iter(list(range(50)), 11))\n\n\nOutput:\n\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],\n [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43],\n [44, 45, 46, 47, 48, 49]]\n\n\nBut if you don't want to be mercy on memory, you can use old-way and store the full list in the first place with iterutils.chunked.\n    ",
        "_Respuesta__votes": 7,
        "comentarios": [
            {
                "_id": 408,
                "_Comentario__descripcion": "And this one actually works regardless of order one looks at the subiterators!!",
                "_Comentario__fecha": "2017-12-19 10:32:55Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Peter Gerdes",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 276,
        "_Respuesta__fecha": "2015-07-15 23:27:19Z",
        "_Respuesta__descripcion": "\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nCHUNK = 4\n[a[i*CHUNK:(i+1)*CHUNK] for i in xrange((len(a) + CHUNK - 1) / CHUNK )]\n\n    ",
        "_Respuesta__votes": 6,
        "comentarios": [
            {
                "_id": 409,
                "_Comentario__descripcion": "Can you explain more your answer please ?",
                "_Comentario__fecha": "2015-07-16 00:06:31Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Zulu",
                "usuario_id": null
            },
            {
                "_id": 410,
                "_Comentario__descripcion": "Working from backwards:      (len(a) + CHUNK -1) / CHUNK  Gives you the number of chunks that you will end up with.  Then, for each chunk at index i, we are generating a sub-array of the original array like this:      a[ i * CHUNK : (i + 1) * CHUNK ]  where,      i * CHUNK is the index of the first element to put into the subarray, and,     (i + 1) * CHUNK is 1 past the last element to put into the subarray.  This solution uses list comprehension, so it might be faster for large arrays.",
                "_Comentario__fecha": "2015-07-29 00:29:20Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "AdvilUser",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 278,
        "_Respuesta__fecha": "2017-04-03 02:13:38Z",
        "_Respuesta__descripcion": "\nArguments are passed by assignment. The rationale behind this is twofold:\n\n\nthe parameter passed in is actually a reference to an object (but the reference is passed by value)\nsome data types are mutable, but others aren't\n\n\nSo:\n\n\nIf you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. \nIf you pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object.\n\n\nTo make it even more clear, let's have some examples. \n\nList - a mutable type\n\nLet's try to modify the list that was passed to a method:\n\ndef try_to_change_list_contents(the_list):\n    print('got', the_list)\n    the_list.append('four')\n    print('changed to', the_list)\n\nouter_list = ['one', 'two', 'three']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_contents(outer_list)\nprint('after, outer_list =', outer_list)\n\n\nOutput:\n\nbefore, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n\n\nSince the parameter passed in is a reference to outer_list, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.\n\nNow let's see what happens when we try to change the reference that was passed in as a parameter:\n\ndef try_to_change_list_reference(the_list):\n    print('got', the_list)\n    the_list = ['and', 'we', 'can', 'not', 'lie']\n    print('set to', the_list)\n\nouter_list = ['we', 'like', 'proper', 'English']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_reference(outer_list)\nprint('after, outer_list =', outer_list)\n\n\nOutput:\n\nbefore, outer_list = ['we', 'like', 'proper', 'English']\ngot ['we', 'like', 'proper', 'English']\nset to ['and', 'we', 'can', 'not', 'lie']\nafter, outer_list = ['we', 'like', 'proper', 'English']\n\n\nSince the the_list parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The the_list was a copy of the outer_list reference, and we had the_list point to a new list, but there was no way to change where outer_list pointed.\n\nString - an immutable type\n\nIt's immutable, so there's nothing we can do to change the contents of the string\n\nNow, let's try to change the reference\n\ndef try_to_change_string_reference(the_string):\n    print('got', the_string)\n    the_string = 'In a kingdom by the sea'\n    print('set to', the_string)\n\nouter_string = 'It was many and many a year ago'\n\nprint('before, outer_string =', outer_string)\ntry_to_change_string_reference(outer_string)\nprint('after, outer_string =', outer_string)\n\n\nOutput:\n\nbefore, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n\n\nAgain, since the the_string parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The the_string was a copy of the outer_string reference, and we had the_string point to a new string, but there was no way to change where outer_string pointed.\n\nI hope this clears things up a little.\n\nEDIT: It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\". Let's work on that.\n\nHow do we get around this?\n\nAs @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:\n\ndef return_a_whole_new_string(the_string):\n    new_string = something_to_do_with_the_old_string(the_string)\n    return new_string\n\n# then you could call it like\nmy_string = return_a_whole_new_string(my_string)\n\n\nIf you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:\n\ndef use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[0])\n    stuff_to_change[0] = new_string\n\n# then you could call it like\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[0])\n\n\nAlthough this seems a little cumbersome.\n    ",
        "_Respuesta__votes": 3174,
        "comentarios": [
            {
                "_id": 418,
                "_Comentario__descripcion": "Then the same is in C, when you pass \"by reference\" you're actually passing by value the reference... Define \"by reference\" :P",
                "_Comentario__fecha": "2009-06-12 11:52:33Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Andrea Ambu",
                "usuario_id": null
            },
            {
                "_id": 419,
                "_Comentario__descripcion": "I'm not sure I understand your terms. I've been out of the C game for a while, but back when I was in it, there was no \"pass by reference\" - you could pass things, and it was always pass by value, so whatever was in the parameter list was copied. But sometimes the thing was a pointer, which one could follow to the piece of memory (primitive, array, struct, whatever), but you couldn't change the pointer that was copied from the outer scope - when you were done with the function, the original pointer still pointed to the same address. C++ introduced references, which behaved differently.",
                "_Comentario__fecha": "2009-06-12 12:09:22Z, License: CC BY-SA 2.5",
                "_Comentario__usuario": "Blair Conrad",
                "usuario_id": null
            },
            {
                "_id": 420,
                "_Comentario__descripcion": "@Zac Bowling I don't really get how what you're saying is relevant, in a practical sense, to this answer. If a Python newcomer wanted to know about passing by ref/val, then the takeaway from this answer is: 1- You can use the reference that a function receives as its arguments, to modify the 'outside' value of a variable, as long as you don't reassign the parameter to refer to a new object. 2- Assigning to an immutable type will always create a new object, which breaks the reference that you had to the outside variable.",
                "_Comentario__fecha": "2011-09-08 23:50:34Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Cam Jackson",
                "usuario_id": null
            },
            {
                "_id": 421,
                "_Comentario__descripcion": "@CamJackson, you need a better example - numbers are also immutable objects in Python. Besides, wouldn't it be true to say that any assignment without subscripting on the left side of the equals will reassign the name to a new object whether it is immutable or not? def Foo(alist): alist = [1,2,3] will not modify the contents of the list from the callers perspective.",
                "_Comentario__fecha": "2011-11-15 16:46:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            },
            {
                "_id": 422,
                "_Comentario__descripcion": "-1. The code shown is good, the explanation as to how is completely wrong.  See the answers by DavidCournapeau or DarenThomas for correct explanations as to why.",
                "_Comentario__fecha": "2012-01-07 06:41:59Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ethan Furman",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 279,
        "_Respuesta__fecha": "2017-04-03 00:39:27Z",
        "_Respuesta__descripcion": "\nThe problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:\n\na = 1\na = 2\n\n\nYou believe that a is a memory location that stores the value 1, then is updated to store the value 2. That's not how things work in Python. Rather, a starts as a reference to an object with the value 1, then gets reassigned as a reference to an object with the value 2. Those two objects may continue to coexist even though a doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.\n\nWhen you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:\n\ndef __init__(self):\n    self.variable = 'Original'\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var = 'Changed'\n\n\nself.variable is a reference to the string object 'Original'. When you call Change you create a second reference var to the object. Inside the function you reassign the reference var to a different string object 'Changed', but the reference self.variable is separate and does not change.\n\nThe only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.\n\ndef __init__(self):         \n    self.variable = ['Original']\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var[0] = 'Changed'\n\n    ",
        "_Respuesta__votes": 786,
        "comentarios": [
            {
                "_id": 423,
                "_Comentario__descripcion": "Good succinct explanation. Your paragraph \"When you call a function...\" is one of the best explanations I've heard of the rather cryptic phrase that 'Python function parameters are references, passed by value.' I think if you understand that paragraph alone, everything else kind of just makes sense and flows as a logical conclusion from there. Then you just have to be aware of when you're creating a new object and when you're modifying an existing one.",
                "_Comentario__fecha": "2011-11-16 00:03:53Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Cam Jackson",
                "usuario_id": null
            },
            {
                "_id": 424,
                "_Comentario__descripcion": "But how can you reassign the reference? I thought you can't change the address of 'var' but that your string \"Changed\" was now going to be stored in the 'var' memory address. Your description makes it seem like \"Changed\" and \"Original\" belong to different places in memory instead and you just switch 'var' to a different address. Is that correct?",
                "_Comentario__fecha": "2012-05-07 01:10:29Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Glassjawed",
                "usuario_id": null
            },
            {
                "_id": 425,
                "_Comentario__descripcion": "@Glassjawed, I think you're getting it. \"Changed\" and \"Original\" are two different string objects at different memory addresses and 'var' changes from pointing to one to pointing to the other.",
                "_Comentario__fecha": "2012-05-07 01:46:48Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            },
            {
                "_id": 426,
                "_Comentario__descripcion": "using the id() function helps clarify matters, because it makes it clear when Python creates a new object (so I think, anyway).",
                "_Comentario__fecha": "2015-11-11 10:07:29Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Tim Richardson",
                "usuario_id": null
            },
            {
                "_id": 427,
                "_Comentario__descripcion": "@MinhTran in the simplest terms, a reference is something that \"refers\" to an object. The physical representation of that is most likely a pointer, but that's simply an implementation detail. It really is an abstract notion at heart.",
                "_Comentario__fecha": "2018-10-20 04:21:58Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Mark Ransom",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 280,
        "_Respuesta__fecha": "2016-05-25 15:30:05Z",
        "_Respuesta__descripcion": "\nI found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n\n    ",
        "_Respuesta__votes": 385,
        "comentarios": [
            {
                "_id": 428,
                "_Comentario__descripcion": "lovely, makes it easy to spot the subtle diff that there is an intermediate assignment, not obvious to a casual onlooker. +1",
                "_Comentario__fecha": "2016-01-03 15:02:44Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "user22866",
                "usuario_id": null
            },
            {
                "_id": 429,
                "_Comentario__descripcion": "It doesn't matter if A is mutable or not. If you assign something different to B, A doesn't change. If an object is mutable, you can mutate it, sure. But that has nothing to do with assignment directly to a name..",
                "_Comentario__fecha": "2016-05-25 00:06:08Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Martijn Pieters\u2666",
                "usuario_id": null
            },
            {
                "_id": 430,
                "_Comentario__descripcion": "@Martijn You're right. I removed the part of the answer that mentions mutability. I don't think it can get any simpler now.",
                "_Comentario__fecha": "2016-05-25 16:19:27Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Zenadix",
                "usuario_id": null
            },
            {
                "_id": 431,
                "_Comentario__descripcion": "Thanks for the update, much better! What confuses most people is assignment to a subscription; e.g. B[0] = 2, vs. direct assignment, B = 2.",
                "_Comentario__fecha": "2016-05-25 16:32:34Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Martijn Pieters\u2666",
                "usuario_id": null
            },
            {
                "_id": 432,
                "_Comentario__descripcion": "\"A is assigned to B.\" Is that not ambiguous? I think in ordinary English that can mean either A=B or B=A.",
                "_Comentario__fecha": "2016-07-04 23:06:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Hatshepsut",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 281,
        "_Respuesta__fecha": "2021-05-30 16:36:04Z",
        "_Respuesta__descripcion": "\nIt is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:\nhttp://effbot.org/zone/call-by-object.htm\nHere is a significant quote:\n\n\"...variables [names] are not objects; they cannot be denoted by other variables or referred to by objects.\"\n\nIn your example, when the Change method is called--a namespace is created for it; and var becomes a name, within that namespace, for the string object 'Original'. That object then has a name in two namespaces. Next, var = 'Changed' binds var to a new string object, and thus the method's namespace forgets about 'Original'. Finally, that namespace is forgotten, and the string 'Changed' along with it.\n    ",
        "_Respuesta__votes": 258,
        "comentarios": [
            {
                "_id": 433,
                "_Comentario__descripcion": "I find it hard to buy. To me is just as Java, the parameters are pointers to objects in memory, and those pointers are passed via the stack, or registers.",
                "_Comentario__fecha": "2011-12-13 01:25:55Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Luciano",
                "usuario_id": null
            },
            {
                "_id": 434,
                "_Comentario__descripcion": "This is not like java. One of the case where it is not the same is immutable objects. Think about the trivial function lambda x: x. Apply this for x = [1, 2, 3] and x = (1, 2, 3). In the first case, the returned value will be a copy of the input, and identical in the second case.",
                "_Comentario__fecha": "2011-12-14 01:53:45Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "David Cournapeau",
                "usuario_id": null
            },
            {
                "_id": 435,
                "_Comentario__descripcion": "No, it's exactly like Java's semantics for objects. I'm not sure what you mean by \"In the first case, the returned value will be a copy of the input, and identical in the second case.\" but that statement seems to be plainly incorrect.",
                "_Comentario__fecha": "2012-11-14 20:58:57Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Mike Graham",
                "usuario_id": null
            },
            {
                "_id": 436,
                "_Comentario__descripcion": "It is exactly the same as in Java. Object references are passed by value. Anyone who thinks differently should attach the Python code for a swap function that can swap two references, like this:  a = [42] ; b = 'Hello'; swap(a, b) # Now a is 'Hello', b is [42]",
                "_Comentario__fecha": "2012-12-20 03:42:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "cayhorstmann",
                "usuario_id": null
            },
            {
                "_id": 437,
                "_Comentario__descripcion": "It is exactly the same as Java when you pass objects in Java. However, Java also have primitives, which are passed by copying the value of the primitive. Thus they differ in that case.",
                "_Comentario__fecha": "2013-07-17 18:59:25Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Claudiu",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 282,
        "_Respuesta__fecha": "2019-11-20 04:37:51Z",
        "_Respuesta__descripcion": "\nThink of stuff being passed by assignment instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.\n\nSo, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list inside the function will not change the original list, since:\n\na = [1, 2, 3]\nb = a\nb.append(4)\nb = ['a', 'b']\nprint a, b      # prints [1, 2, 3, 4] ['a', 'b']\n\n\nSince immutable types cannot be modified, they seem like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.\n    ",
        "_Respuesta__votes": 202,
        "comentarios": [
            {
                "_id": 438,
                "_Comentario__descripcion": "At first glance this answer seems to sidestep the original question. After a second read I've come to realize that this makes the matter quite clear. A good follow up to this \"name assignment\" concept may be found  here: Code Like a Pythonista: Idiomatic Python",
                "_Comentario__fecha": "2017-11-22 21:45:48Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Christian Groleau",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 283,
        "_Respuesta__fecha": "2020-04-27 10:17:30Z",
        "_Respuesta__descripcion": "\nThere are no variables in Python\n\nThe key to understanding parameter passing is to stop thinking about \"variables\". There are names and objects in Python and together they\nappear like variables, but it is useful to always distinguish the three.\n\n\nPython has names and objects.\nAssignment binds a name to an object.\nPassing an argument into a function also binds a name (the parameter name of the function) to an object.\n\n\nThat is all there is to it. Mutability is irrelevant to this question.\n\nExample:\n\na = 1\n\n\nThis binds the name a to an object of type integer that holds the value 1.\n\nb = x\n\n\nThis binds the name b to the same object that the name x is currently bound to.\nAfterward, the name b has nothing to do with the name x anymore.\n\nSee sections 3.1 and 4.2 in the Python 3 language reference.\n\nHow to read the example in the question\n\nIn the code shown in the question, the statement self.Change(self.variable) binds the name var (in the scope of function Change) to the object that holds the value 'Original' and the assignment var = 'Changed' (in the body of function Change) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).\n\nHow to pass by reference\n\nSo if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.\n\nIf it is an immutable object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.\nThe quick-and-dirty solution for this is a one-element list (instead of self.variable, pass [self.variable] and in the function modify var[0]).\nThe more pythonic approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.\n    ",
        "_Respuesta__votes": 83,
        "comentarios": [
            {
                "_id": 439,
                "_Comentario__descripcion": "\"Python has no variables\" is a silly and confusing slogan, and I really wish people would stop saying it... :(   The rest of this answer is good!",
                "_Comentario__fecha": "2014-06-23 21:53:13Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ned Batchelder",
                "usuario_id": null
            },
            {
                "_id": 440,
                "_Comentario__descripcion": "It may be shocking, but it is not silly. And I don't think it is confusing either: It hopefully opens up the recipient's mind for the explanation that is coming and puts her in a useful \"I wonder what they have instead of variables\" attitude. (Yes, your mileage may vary.)",
                "_Comentario__fecha": "2014-06-25 07:30:38Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Lutz Prechelt",
                "usuario_id": null
            },
            {
                "_id": 441,
                "_Comentario__descripcion": "would you also say that Javascript has no variables? They work the same as Python's.  Also, Java, Ruby, PHP, ....   I think a better teaching technique is, \"Python's variables work differently than C's.\"",
                "_Comentario__fecha": "2014-06-25 11:09:48Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ned Batchelder",
                "usuario_id": null
            },
            {
                "_id": 442,
                "_Comentario__descripcion": "Yes, Java has variables. So does Python, and JavaScript, Ruby, PHP, etc.  You wouldn't say in Java that int declares a variable, but Integer does not.  They both declare variables.  The Integer variable is an object, the int variable is a primitive.  As an example, you demonstrated how your variables work by showing a = 1; b = a; a++ # doesn't modify b.  That's exactly true in Python also (using += 1 since there is no ++ in Python)!",
                "_Comentario__fecha": "2014-10-29 16:29:37Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Ned Batchelder",
                "usuario_id": null
            },
            {
                "_id": 443,
                "_Comentario__descripcion": "The concept of \"variable\" is complex and often vague: A variable is a container for a value, identified by a name. In Python, the values are objects, the containers are objects (see the problem?) and the names are actually separate things. I believe it is much tougher to get an accurate understanding of variables in this manner. The names-and-objects explanation appears more difficult, but is actually simpler.",
                "_Comentario__fecha": "2015-10-09 10:51:43Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Lutz Prechelt",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 284,
        "_Respuesta__fecha": "2013-03-29 04:41:44Z",
        "_Respuesta__descripcion": "\nEffbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  http://effbot.org/zone/call-by-object.htm\n\nObjects are allocated on the heap and pointers to them can be passed around anywhere.  \n\n\nWhen you make an assignment such as x = 1000, a dictionary entry is created that maps the string \"x\" in the current namespace to a pointer to the integer object containing one thousand.   \nWhen you update \"x\" with x = 2000, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).\nWhen you do a new assignment such as y = x, a new dictionary entry \"y\" is created that points to the same object as the entry for \"x\".\nObjects like strings and integers are immutable.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.\nObjects like lists are mutable.  This means that the contents of the object can be changed by anything pointing to the object.  For example, x = []; y = x; x.append(10); print y will print [10].  The empty list was created.  Both \"x\" and \"y\" point to the same list.  The append method mutates (updates) the list object (like adding a record to a database) and the result is visible to both \"x\" and \"y\" (just as a database update would be visible to every connection to that database).\n\n\nHope that clarifies the issue for you. \n    ",
        "_Respuesta__votes": 79,
        "comentarios": [
            {
                "_id": 444,
                "_Comentario__descripcion": "I really appreciate learning about this from a developer. Is it true that the id() function returns the pointer's (object reference's) value, as pepr's answer suggests?",
                "_Comentario__fecha": "2014-01-13 22:21:16Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Honest Abe",
                "usuario_id": null
            },
            {
                "_id": 445,
                "_Comentario__descripcion": "@HonestAbe Yes, in CPython the id() returns the address.  But in other pythons such as PyPy and Jython, the id() is just a unique object identifier.",
                "_Comentario__fecha": "2014-01-14 09:03:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Raymond Hettinger",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 285,
        "_Respuesta__fecha": "2017-05-23 12:18:21Z",
        "_Respuesta__descripcion": "\nTechnically, Python always uses pass by reference values. I am going to repeat my other answer to support my statement.\n\nPython always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.\n\nYou can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.\n\nHere is the example that proves that Python uses passing by reference:\n\n\n\nIf the argument was passed by value, the outer lst could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)\n\nYou can use the id() built-in function to learn what the reference value is (that is, the address of the target object).\n\nIn compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.\n\nReference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.\n    ",
        "_Respuesta__votes": 65,
        "comentarios": [
            {
                "_id": 446,
                "_Comentario__descripcion": "Actually this is confirmed its pass by reference value. +1 for this answer although the example wasnt good.",
                "_Comentario__fecha": "2012-10-04 17:03:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "BugShotGG",
                "usuario_id": null
            },
            {
                "_id": 447,
                "_Comentario__descripcion": "Inventing new terminology (such as \"pass by reference value\" or \"call by object\" is not helpful). \"Call by (value|reference|name)\" are standard terms. \"reference\" is a standard term. Passing references by value accurately describes the behavior of Python, Java, and a host of other languages, using standard terminology.",
                "_Comentario__fecha": "2012-12-20 03:54:47Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "cayhorstmann",
                "usuario_id": null
            },
            {
                "_id": 448,
                "_Comentario__descripcion": "@cayhorstmann: The problem is that Python variable has not the same terminology meaning as in other languages. This way, call by reference does not fit well here. Also, how do you exactly define the term reference? Informally, the Python way could be easily described as passing the address of the object. But it does not fit with a potentially distributed implementation of Python.",
                "_Comentario__fecha": "2012-12-20 08:54:24Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "pepr",
                "usuario_id": null
            },
            {
                "_id": 449,
                "_Comentario__descripcion": "I like this answer, but you might consider if the example is really helping or hurting the flow. Also, if you replaced 'reference value' with 'object reference' you would be using terminology that we could consider 'official', as seen here: Defining Functions",
                "_Comentario__fecha": "2014-01-13 22:10:01Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Honest Abe",
                "usuario_id": null
            },
            {
                "_id": 450,
                "_Comentario__descripcion": "There is a footnote indicated at the end of that quote, which reads: \"Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it...\" I agree with you that confusion is caused by trying to fit terminology established with other languages. Semantics aside, the things that need to be understood are: dictionaries / namespaces, name binding operations and the relationship of name\u2192pointer\u2192object (as you already know).",
                "_Comentario__fecha": "2014-01-16 06:28:53Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Honest Abe",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 286,
        "_Respuesta__fecha": "2011-08-08 10:39:48Z",
        "_Respuesta__descripcion": "\nA simple trick I normally use is to just wrap it in a list:\n\ndef Change(self, var):\n    var[0] = 'Changed'\n\nvariable = ['Original']\nself.Change(variable)      \nprint variable[0]\n\n\n(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)\n    ",
        "_Respuesta__votes": 51,
        "comentarios": [
            {
                "_id": 451,
                "_Comentario__descripcion": "+1 for small amount of text giving the essential workaround to the problem of Python not having pass-by-reference. (As a follow-on comment/question that fits here as well as anywhere on this page: It's not clear to my why python can't provide a \"ref\" keyword like C# does, that simply wraps the caller's argument in a list like this, and treat references to the argument within the function as the 0th element of the list.)",
                "_Comentario__fecha": "2014-09-16 06:33:28Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "M Katz",
                "usuario_id": null
            },
            {
                "_id": 452,
                "_Comentario__descripcion": "Nice. To pass by ref, wrap in [ ]'s.",
                "_Comentario__fecha": "2015-02-01 05:49:17Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Justas",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 287,
        "_Respuesta__fecha": "2015-10-09 15:00:42Z",
        "_Respuesta__descripcion": "\n(edit - Blair has updated his enormously popular answer so that it is now accurate)\n\nI think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.\n\nDavid Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.\n\nTo the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a \"value\" or a \"reference\") must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.\n\nIf you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.\n    ",
        "_Respuesta__votes": 40,
        "comentarios": [
            {
                "_id": 453,
                "_Comentario__descripcion": "It is simply not true that all languages are call by value. In C++ or Pascal (and surely many others that I don't know), you have call by reference. For example, in C++, void swap(int& x, int& y) { int temp = x; x = y; y = temp; } will swap the variables passed to it. In Pascal, you use var instead of &.",
                "_Comentario__fecha": "2012-12-20 03:49:01Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "cayhorstmann",
                "usuario_id": null
            },
            {
                "_id": 454,
                "_Comentario__descripcion": "I thought I had replied to this long ago but I don't see it. For completeness - cayhorstmann misunderstood my answer. I was not saying everything is call by value in the terms that most people first learn regarding C / C++. It was simply that some value is passed (value, name, pointer, etc.) and that the terms used in Blair's original answer were inaccurate.",
                "_Comentario__fecha": "2015-10-09 15:03:12Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "KobeJohn",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 288,
        "_Respuesta__fecha": "2012-01-27 04:28:48Z",
        "_Respuesta__descripcion": "\nYou got some really good answers here.\n\nx = [ 2, 4, 4, 5, 5 ]\nprint x  # 2, 4, 4, 5, 5\n\ndef go( li ) :\n  li = [ 5, 6, 7, 8 ]  # re-assigning what li POINTS TO, does not\n  # change the value of the ORIGINAL variable x\n\ngo( x ) \nprint x  # 2, 4, 4, 5, 5  [ STILL! ]\n\n\nraw_input( 'press any key to continue' )\n\n    ",
        "_Respuesta__votes": 28,
        "comentarios": [
            {
                "_id": 455,
                "_Comentario__descripcion": "yea, however if you do   x = [ 2, 4, 4, 5, 5],  y = x,  X[0] = 1 , print x # [1, 4 ,4, 5, 5]  print y # [1, 4, 4, 5, 5]",
                "_Comentario__fecha": "2014-06-29 03:37:36Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "laycat",
                "usuario_id": null
            },
            {
                "_id": 456,
                "_Comentario__descripcion": "X[0]   or x[0] ? don't get it",
                "_Comentario__fecha": "2021-08-01 07:16:57Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "pippo1980",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 289,
        "_Respuesta__fecha": "2015-03-27 04:38:18Z",
        "_Respuesta__descripcion": "\nPython\u2019s pass-by-assignment scheme isn\u2019t quite the same as C++\u2019s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:\n\n\nImmutable arguments are effectively passed \u201cby value.\u201d Objects such as integers and strings are passed by object reference instead of by copying, but because you can\u2019t change immutable objects in place anyhow, the effect is much like making a copy.\nMutable arguments are effectively passed \u201cby pointer.\u201d Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointers\u2014mutable objects can be changed in place in the function,\nmuch like C arrays.\n\n    ",
        "_Respuesta__votes": 23,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 290,
        "_Respuesta__fecha": "2009-06-12 10:39:59Z",
        "_Respuesta__descripcion": "\nIn this case the variable titled var in the method Change is assigned a reference to self.variable, and you immediately assign a string to var. It's no longer pointing to self.variable. The following code snippet shows what would happen if you modify the data structure pointed to by var and self.variable, in this case a list:\n\n>>> class PassByReference:\n...     def __init__(self):\n...         self.variable = ['Original']\n...         self.change(self.variable)\n...         print self.variable\n...         \n...     def change(self, var):\n...         var.append('Changed')\n... \n>>> q = PassByReference()\n['Original', 'Changed']\n>>> \n\n\nI'm sure someone else could clarify this further.\n    ",
        "_Respuesta__votes": 20,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 291,
        "_Respuesta__fecha": "2016-08-09 02:23:54Z",
        "_Respuesta__descripcion": "\nAs you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!\n\nhttp://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\n\nexample:\n\n>>> def x(y):\n...     global z\n...     z = y\n...\n\n>>> x\n<function x at 0x00000000020E1730>\n>>> y\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'y' is not defined\n>>> z\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'z' is not defined\n\n>>> x(2)\n>>> x\n<function x at 0x00000000020E1730>\n>>> y\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'y' is not defined\n>>> z\n2\n\n    ",
        "_Respuesta__votes": 19,
        "comentarios": [
            {
                "_id": 457,
                "_Comentario__descripcion": "I was tempted to post a similar response- the original questioner may not have known that what he wanted was in fact to use a global variable, shared among functions. Here's the link I would have shared: stackoverflow.com/questions/423379/\u2026  In answer to @Tim, Stack Overflow is not only a question and answer site, it's a vast repository of reference knowledge that only gets stronger and more nuanced- much like an active wiki- with more input.",
                "_Comentario__fecha": "2014-06-30 18:39:20Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Max P Magee",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 292,
        "_Respuesta__fecha": "2014-09-29 07:12:10Z",
        "_Respuesta__descripcion": "\nA lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python  \n\n\"In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function\u2019s body, it\u2019s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as \u2018global\u2019.\nThough a bit surprising at first, a moment\u2019s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you\u2019d be using global all the time. You\u2019d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.\"\n\nEven when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.\n\ndef test(l):\n    print \"Received\", l , id(l)\n    l = [0, 0, 0]\n    print \"Changed to\", l, id(l)  # New local object created, breaking link to global l\n\nl= [1,2,3]\nprint \"Original\", l, id(l)\ntest(l)\nprint \"After\", l, id(l)\n\n\ngives:\n\nOriginal [1, 2, 3] 4454645632\nReceived [1, 2, 3] 4454645632\nChanged to [0, 0, 0] 4474591928\nAfter [1, 2, 3] 4454645632\n\n\nThe assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.\n    ",
        "_Respuesta__votes": 18,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 293,
        "_Respuesta__fecha": "2017-05-23 11:54:59Z",
        "_Respuesta__descripcion": "\nHere is the simple (I hope) explanation of the concept pass by object used in Python.\nWhenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:\n\ndef change_me(list):\n   list = [1, 2, 3]\n\nmy_list = [0, 1]\nchange_me(my_list)\n\n\nThe actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function change_me will try to do something like:\n\n[0, 1] = [1, 2, 3]\n\n\nwhich obviously will not change the object passed to the function. If the function looked like this:\n\ndef change_me(list):\n   list.append(2)\n\n\nThen the call would result in:\n\n[0, 1].append(2)\n\n\nwhich obviously will change the object. This answer explains it well.\n    ",
        "_Respuesta__votes": 12,
        "comentarios": [
            {
                "_id": 458,
                "_Comentario__descripcion": "The problem is that the assignment does something else than you expect. The list = [1, 2, 3] causes reusing the list name for something else and forgeting the originally passed object. However, you can try list[:] = [1, 2, 3] (by the way list is wrong name for a variable. Thinking about [0, 1] = [1, 2, 3] is a complete nonsense. Anyway, what do you think means the object itself is passed? What is copied to the function in your opinion?",
                "_Comentario__fecha": "2012-10-03 20:46:23Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "pepr",
                "usuario_id": null
            },
            {
                "_id": 459,
                "_Comentario__descripcion": "@pepr objects aren't literals. They are objects. The only way to talk about them is giving them some names. That's why it's so simple once you grasp it, but enormously complicated to explain. :-)",
                "_Comentario__fecha": "2014-05-09 09:10:45Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Veky",
                "usuario_id": null
            },
            {
                "_id": 460,
                "_Comentario__descripcion": "@Veky: I am aware of that. Anyway, the list literal is converted to the list object. Actually, any object in Python can exist without a name, and it can be used even when not given any name. And you can think about them as about anonymous objects. Think about objects being the elements of a lists. They need not a name. You can access them through indexing of or iterating through the list. Anyway, I insist on [0, 1] = [1, 2, 3] is simply a bad example. There is nothing like that in Python.",
                "_Comentario__fecha": "2014-05-12 11:05:32Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "pepr",
                "usuario_id": null
            },
            {
                "_id": 461,
                "_Comentario__descripcion": "@pepr: I don't necessarily mean Python-definition names, just ordinary names. Of course alist[2] counts as a name of a third element of alist. But I think I misunderstood what your problem was. :-)",
                "_Comentario__fecha": "2014-05-12 12:35:58Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Veky",
                "usuario_id": null
            },
            {
                "_id": 462,
                "_Comentario__descripcion": "Argh. My English is obviously much worse than my Python. :-) I'll try just once more. I just said you have to give object some names just to talk about them. By that \"names\" I didn't mean \"names as defined by Python\". I know Python mechanisms, don't worry.",
                "_Comentario__fecha": "2014-05-15 05:20:34Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Veky",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 294,
        "_Respuesta__fecha": "2016-08-09 02:23:27Z",
        "_Respuesta__descripcion": "\nAside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.Change()\n        print self.variable\n\n    def Change(self):\n        self.variable = 'Changed'\n\n\nIn instance methods, you normally refer to self to access instance attributes. It is normal to set instance attributes in __init__ and read or change them in instance methods. That is also why you pass self als the first argument to def Change.\n\nAnother solution would be to create a static method like this:\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.variable = PassByReference.Change(self.variable)\n        print self.variable\n\n    @staticmethod\n    def Change(var):\n        var = 'Changed'\n        return var\n\n    ",
        "_Respuesta__votes": 10,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 295,
        "_Respuesta__fecha": "2016-04-21 16:47:42Z",
        "_Respuesta__descripcion": "\nThere is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)\n\nclass PassByReference:\n    def __init__(self, name):\n        self.name = name\n\ndef changeRef(ref):\n    ref[0] = PassByReference('Michael')\n\nobj = PassByReference('Peter')\nprint obj.name\n\np = [obj] # A pointer to obj! ;-)\nchangeRef(p)\n\nprint p[0].name # p->name\n\n\nIt's an ugly hack, but it works. ;-P\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [
            {
                "_id": 463,
                "_Comentario__descripcion": "p is reference to a mutable list object which in turn stores the object obj. The reference 'p', gets passed into changeRef. Inside changeRef, a new reference is created (the new reference is called ref) that points to the same list object that p points to. But because lists are mutable, changes to the list are visible by both references. In this case, you used the ref reference to change the object at index 0 so that it subsequently stores the PassByReference('Michael') object. The change  to the list object was done using ref but this change is visible to p.",
                "_Comentario__fecha": "2018-10-20 03:19:21Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Minh Tran",
                "usuario_id": null
            },
            {
                "_id": 464,
                "_Comentario__descripcion": "So now, the references p and ref point to a list object that stores the single object, PassByReference('Michael'). So it follows that p[0].name returns Michael. Of course, ref has now gone out of scope and may be garbage collected but all the same.",
                "_Comentario__fecha": "2018-10-20 03:22:21Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Minh Tran",
                "usuario_id": null
            },
            {
                "_id": 465,
                "_Comentario__descripcion": "You have not changed the private instance variable, name, of the original PassByReference object associated with the reference obj, though. In fact, obj.name will return Peter. The aforementioned comments assumes the definition Mark Ransom gave.",
                "_Comentario__fecha": "2018-10-20 03:25:29Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Minh Tran",
                "usuario_id": null
            },
            {
                "_id": 466,
                "_Comentario__descripcion": "Point being, I don't agree that it's a hack (which I take to mean to refer to something that works but for reasons unknown, untested, or unintended by the implementer). You simply replaced one PassByReference object with another PassByReference object in your list and referred to the latter of the two objects.",
                "_Comentario__fecha": "2018-10-20 03:32:11Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Minh Tran",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 296,
        "_Respuesta__fecha": "2016-08-09 02:22:25Z",
        "_Respuesta__descripcion": "\nI used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.\n\na=0\nb=0\nc=0\ndef myfunc(a,b,c):\n    a=1\n    b=2\n    c=3\n    return a,b,c\n\na,b,c = myfunc(a,b,c)\nprint a,b,c\n\n    ",
        "_Respuesta__votes": 8,
        "comentarios": [
            {
                "_id": 467,
                "_Comentario__descripcion": "Yes, this solves the 'pass by reference' in my use case as well. I have a function that basically cleans up values in a dict and then returns the dict. However, while cleaning up it may become apparent a rebuild of a part of the system is required. Therefore, the function must not only return the cleaned dict but also be able to signal the rebuild. I tried to pass a bool by reference, but ofc that doesn't work. Figuring out how to solve this, I found your solution (basically returning a tuple) to work best while also not being a hack/workaround at all (IMHO).",
                "_Comentario__fecha": "2020-05-01 16:08:54Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "kasimir",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 297,
        "_Respuesta__fecha": "2016-10-31 15:33:23Z",
        "_Respuesta__descripcion": "\ngiven the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:\n\nclass PassByReferenceIsh:\n    def __init__(self):\n        self.variable = 'Original'\n        self.change('variable')\n        print self.variable\n\n    def change(self, var):\n        self.__dict__[var] = 'Changed'\n\n\nin real code you would, of course, add error checking on the dict lookup.\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 298,
        "_Respuesta__fecha": "2021-06-01 08:29:19Z",
        "_Respuesta__descripcion": "\nSince dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.\n# returns the result of adding numbers `a` and `b`\ndef AddNumbers(a, b, ref): # using a dict for reference\n    result = a + b\n    ref['multi'] = a * b # reference the multi. ref['multi'] is number\n    ref['msg'] = \"The result: \" + str(result) + \" was nice!\"\n    return result\n\nnumber1 = 5\nnumber2 = 10\nref = {} # init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.\n\nsum = AddNumbers(number1, number2, ref)\nprint(\"sum: \", sum)             # the returned value\nprint(\"multi: \", ref['multi'])  # a referenced value\nprint(\"msg: \", ref['msg'])      # a referenced value\n\n    ",
        "_Respuesta__votes": 5,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 299,
        "_Respuesta__fecha": "2017-09-10 02:19:53Z",
        "_Respuesta__descripcion": "\nSince your example happens to be object-oriented, you could make the following change to achieve a similar result:\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.change('variable')\n        print(self.variable)\n\n    def change(self, var):\n        setattr(self, var, 'Changed')\n\n# o.variable will equal 'Changed'\no = PassByReference()\nassert o.variable == 'Changed'\n\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [
            {
                "_id": 468,
                "_Comentario__descripcion": "Although this works. It is not pass by reference. It is 'pass by object reference'.",
                "_Comentario__fecha": "2018-03-14 11:48:30Z, License: CC BY-SA 3.0",
                "_Comentario__usuario": "Bishwas Mishra",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 300,
        "_Respuesta__fecha": "2019-05-10 00:37:33Z",
        "_Respuesta__descripcion": "\nSince it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an \"update\" function and pass that instead of the actual variable (or rather, \"name\"):\n\ndef need_to_modify(update):\n    update(42) # set new value 42\n    # other code\n\ndef call_it():\n    value = 21\n    def update_value(new_value):\n        nonlocal value\n        value = new_value\n    need_to_modify(update_value)\n    print(value) # prints 42\n\n\nThis is mostly useful for \"out-only references\" or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).\n\nObviously the above does not allow reading the value, only updating it.\n    ",
        "_Respuesta__votes": 4,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 301,
        "_Respuesta__fecha": "2016-08-20 14:02:37Z",
        "_Respuesta__descripcion": "\nWhile pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.\n\nThe basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.\n\nOne way is to use global (for global variables) or nonlocal (for local variables in a function) in a wrapper function.\n\ndef change(wrapper):\n    wrapper(7)\n\nx = 5\ndef setter(val):\n    global x\n    x = val\nprint(x)\n\n\nThe same idea works for reading and deleting a variable.\n\nFor just reading there is even a shorter way of just using lambda: x which returns a callable that when called returns the current value of x. This is somewhat like \"call by name\" used in languages in the distant past.\n\nPassing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:\n\nclass ByRef:\n    def __init__(self, r, w, d):\n        self._read = r\n        self._write = w\n        self._delete = d\n    def set(self, val):\n        self._write(val)\n    def get(self):\n        return self._read()\n    def remove(self):\n        self._delete()\n    wrapped = property(get, set, remove)\n\n# left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal\nr = ByRef(get, set, remove)\nr.wrapped = 15\n\n\nPythons \"reflection\" support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:\n\nclass ByRef:\n    def __init__(self, locs, name):\n        self._locs = locs\n        self._name = name\n    def set(self, val):\n        self._locs[self._name] = val\n    def get(self):\n        return self._locs[self._name]\n    def remove(self):\n        del self._locs[self._name]\n    wrapped = property(get, set, remove)\n\ndef change(x):\n    x.wrapped = 7\n\ndef test_me():\n    x = 6\n    print(x)\n    change(ByRef(locals(), \"x\"))\n    print(x)\n\n\nHere the ByRef class wraps a dictionary access. So attribute access to wrapped is translated to a item access in the passed dictionary. By passing the result of the builtin locals and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 302,
        "_Respuesta__fecha": "2019-06-13 04:11:38Z",
        "_Respuesta__descripcion": "\nPass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. \n\n\nJava&C#: primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.\nC++: Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.\nPython: \nPython is \u201cpass-by-object-reference\u201d, of which it is often said: \u201cObject references are passed by value.\u201d[Read here]1. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.\n\n    ",
        "_Respuesta__votes": 3,
        "comentarios": [
            {
                "_id": 469,
                "_Comentario__descripcion": "Old but I feel obliged to correct it. Strings are passed by reference in both Java and C#, NOT by value",
                "_Comentario__fecha": "2019-09-11 16:39:19Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "John",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 303,
        "_Respuesta__fecha": "2018-05-03 14:14:11Z",
        "_Respuesta__descripcion": "\nYou can merely use an empty class as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.\n\nclass RefsObj(object):\n    \"A class which helps to create references to variables.\"\n    pass\n\n...\n\n# an example of usage\ndef change_ref_var(ref_obj):\n    ref_obj.val = 24\n\nref_obj = RefsObj()\nref_obj.val = 1\nprint(ref_obj.val) # or print ref_obj.val for python2\nchange_ref_var(ref_obj)\nprint(ref_obj.val)\n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 304,
        "_Respuesta__fecha": "2020-07-21 20:38:03Z",
        "_Respuesta__descripcion": "\nI am new to Python, started yesterday (though I have been programming for 45 years).\nI came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn't get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed two such out-parameters I felt I needed to sort it out.\nIn this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.\nFrom the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality.\nBut then I found something neat in Python that I don't think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this:\ndef somefunction(p):\n    a=p+1\n    b=p+2\n    c=-p\n    return a, b, c\n\nand that you can handle that on the calling side similarly, like this\nx, y, z = somefunction(w)\n\nThat was good enough for me and I was satisfied. No need to use some workaround.\nIn other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.\nThe Python way of doing it was nice and simple.\nIf you want to mimic by reference even more, you could do as follows:\ndef somefunction(a, b, c):\n    a = a * 2\n    b = b + a\n    c = a * b * c\n    return a, b, c\n\nx = 3\ny = 5\nz = 10\nprint(F\"Before : {x}, {y}, {z}\")\n\nx, y, z = somefunction(x, y, z)\n\nprint(F\"After  : {x}, {y}, {z}\")\n\nwhich gives this result\nBefore : 3, 5, 10  \nAfter  : 6, 11, 660  \n\n    ",
        "_Respuesta__votes": 2,
        "comentarios": [
            {
                "_id": 470,
                "_Comentario__descripcion": "\"But then I found something neat in Python that I don't think I have seen in other languages before, namely that you can return more than one value from a function\" No, you can't. What you are doing is returning a single value, a tuple, which is what the expression a, b, c creates. You then use iterable unpacking to unpack that tuple into separate variables. Of course, in effect, you can think of this as \"returning multiple values\", but you aren't actually doing that, you are returning a container.",
                "_Comentario__fecha": "2020-08-12 19:45:59Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "juanpa.arrivillaga",
                "usuario_id": null
            },
            {
                "_id": 471,
                "_Comentario__descripcion": "@juanpa.arrivillaga, yes, I was aware of that when I wrote my answer, I had just read about it. But I just described the whole thing in a practical way without going into the details of how it works and add unnecessary length to my answer. You can indeed return multiple values from a function, if it is done in an object or similar, like in a tuple (which in Python is taken care of in the neat way I showed). When I order things from a company, they can send me multiple things, even if it is all in one package.",
                "_Comentario__fecha": "2020-08-13 09:01:53Z, License: CC BY-SA 4.0",
                "_Comentario__usuario": "Magnus",
                "usuario_id": null
            }
        ],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 305,
        "_Respuesta__fecha": "2021-01-28 11:06:18Z",
        "_Respuesta__descripcion": "\nalternatively you could use ctypes witch would look something like this\nimport ctypes\n\ndef f(a):\n    a.value=2398 ## resign the value in a function\n\na = ctypes.c_int(0)\nprint(\"pre f\", a)\nf(a)\nprint(\"post f\", a)\n\nas a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 306,
        "_Respuesta__fecha": "2021-03-26 14:49:25Z",
        "_Respuesta__descripcion": "\nMost likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don't want to do:\nimport builtins\n\nclass sstr(str):\n    def __str__(self):\n        if hasattr(self, 'changed'):\n            return self.changed\n\n        return self\n\n    def change(self, value):\n        self.changed = value\n\nbuiltins.str = sstr\n\ndef change_the_value(val):\n    val.change('After')\n\nval = str('Before')\nprint (val)\nchange_the_value(val)\nprint (val)\n\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    },
    {
        "_id": 307,
        "_Respuesta__fecha": "2021-06-28 17:29:12Z",
        "_Respuesta__descripcion": "\nWhat about dataclasses? Also, it allows you to apply type restriction (aka \"type hint\").\nfrom dataclasses import dataclass\n\n@dataclass\nclass Holder:\n    obj: your_type # Need any type? Use \"obj: object\" then.\n\ndef foo(ref: Holder):\n    ref.obj = do_something()\n\nI agree with folks that in most cases you'd better consider not to use it.\nAnd yet, when we're talking about contexts it's worth to know that way.\nYou can design explicit context class though. When prototyping I prefer dataclasses, just because it's easy to serialize them back and forth.\nCheers!\n    ",
        "_Respuesta__votes": 1,
        "comentarios": [],
        "_Respuesta__usuario": "ANON",
        "usuario_id": null
    }
]